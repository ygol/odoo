odoo.define('web_editor.jabberwock', function(require) {
'use strict';
var JWEditor =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 23);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

/**
 * We define here a simple event bus: it can
 * - emit events
 * - add/remove listeners.
 *
 * This is a useful pattern of communication in many cases.  For OWL, each
 * components and stores are event buses.
 */
//------------------------------------------------------------------------------
// EventBus
//------------------------------------------------------------------------------
class EventBus {
    constructor() {
        this.subscriptions = {};
    }
    /**
     * Add a listener for the 'eventType' events.
     *
     * Note that the 'owner' of this event can be anything, but will more likely
     * be a component or a class. The idea is that the callback will be called with
     * the proper owner bound.
     *
     * Also, the owner should be kind of unique. This will be used to remove the
     * listener.
     */
    on(eventType, owner, callback) {
        if (!callback) {
            throw new Error("Missing callback");
        }
        if (!this.subscriptions[eventType]) {
            this.subscriptions[eventType] = [];
        }
        this.subscriptions[eventType].push({
            owner,
            callback
        });
    }
    /**
     * Remove a listener
     */
    off(eventType, owner) {
        const subs = this.subscriptions[eventType];
        if (subs) {
            this.subscriptions[eventType] = subs.filter(s => s.owner !== owner);
        }
    }
    /**
     * Emit an event of type 'eventType'.  Any extra arguments will be passed to
     * the listeners callback.
     */
    trigger(eventType, ...args) {
        const subs = this.subscriptions[eventType] || [];
        for (let i = 0, iLen = subs.length; i < iLen; i++) {
            const sub = subs[i];
            sub.callback.call(sub.owner, ...args);
        }
    }
    /**
     * Remove all subscriptions.
     */
    clear() {
        this.subscriptions = {};
    }
}

/**
 * Owl Observer
 *
 * This code contains the logic that allows Owl to observe and react to state
 * changes.
 *
 * This is a Observer class that can observe any JS values.  The way it works
 * can be summarized thusly:
 * - primitive values are not observed at all
 * - Objects and arrays are observed by replacing them with a Proxy
 * - each object/array metadata are tracked in a weakmap, and keep a revision
 *   number
 *
 * Note that this code is loosely inspired by Vue.
 */
//------------------------------------------------------------------------------
// Observer
//------------------------------------------------------------------------------
class Observer {
    constructor() {
        this.rev = 1;
        this.allowMutations = true;
        this.weakMap = new WeakMap();
    }
    notifyCB() { }
    observe(value, parent) {
        if (value === null || typeof value !== "object" || value instanceof Date) {
            // fun fact: typeof null === 'object'
            return value;
        }
        let metadata = this.weakMap.get(value) || this._observe(value, parent);
        return metadata.proxy;
    }
    revNumber(value) {
        const metadata = this.weakMap.get(value);
        return metadata ? metadata.rev : 0;
    }
    _observe(value, parent) {
        var self = this;
        const proxy = new Proxy(value, {
            get(target, k) {
                const targetValue = target[k];
                return self.observe(targetValue, value);
            },
            set(target, key, newVal) {
                const value = target[key];
                if (newVal !== value) {
                    if (!self.allowMutations) {
                        throw new Error(`Observed state cannot be changed here! (key: "${key}", val: "${newVal}")`);
                    }
                    self._updateRevNumber(target);
                    target[key] = newVal;
                    self.notifyCB();
                }
                return true;
            },
            deleteProperty(target, key) {
                if (key in target) {
                    delete target[key];
                    self._updateRevNumber(target);
                    self.notifyCB();
                }
                return true;
            }
        });
        const metadata = {
            value,
            proxy,
            rev: this.rev,
            parent
        };
        this.weakMap.set(value, metadata);
        this.weakMap.set(metadata.proxy, metadata);
        return metadata;
    }
    _updateRevNumber(target) {
        this.rev++;
        let metadata = this.weakMap.get(target);
        let parent = target;
        do {
            metadata = this.weakMap.get(parent);
            metadata.rev++;
        } while ((parent = metadata.parent) && parent !== target);
    }
}

//------------------------------------------------------------------------------
// module/props.ts
//------------------------------------------------------------------------------
function updateProps(oldVnode, vnode) {
    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;
    if (!oldProps && !props)
        return;
    if (oldProps === props)
        return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== "value" || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
const propsModule = {
    create: updateProps,
    update: updateProps
};
//------------------------------------------------------------------------------
// module/eventlisteners.ts
//------------------------------------------------------------------------------
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    }
    else if (typeof handler === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            }
            else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        }
        else {
            // call multiple handlers
            for (let i = 0, iLen = handler.length; i < iLen; i++) {
                invokeHandler(handler[i], vnode, event);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type, on = vnode.data.on;
    // call event handler(s) if exists
    if (on) {
        if (on[name]) {
            invokeHandler(on[name], vnode, event);
        }
        else if (on["!" + name]) {
            invokeHandler(on["!" + name], vnode, event);
        }
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                const capture = name.charAt(0) === "!";
                name = capture ? name.slice(1) : name;
                oldElm.removeEventListener(name, oldListener, capture);
            }
        }
        else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    const capture = name.charAt(0) === "!";
                    name = capture ? name.slice(1) : name;
                    oldElm.removeEventListener(name, oldListener, capture);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = (vnode.listener = oldVnode.listener || createListener());
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                const capture = name.charAt(0) === "!";
                name = capture ? name.slice(1) : name;
                elm.addEventListener(name, listener, capture);
            }
        }
        else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    const capture = name.charAt(0) === "!";
                    name = capture ? name.slice(1) : name;
                    elm.addEventListener(name, listener, capture);
                }
            }
        }
    }
}
const eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
//------------------------------------------------------------------------------
// attributes.ts
//------------------------------------------------------------------------------
const xlinkNS = "http://www.w3.org/1999/xlink";
const xmlNS = "http://www.w3.org/XML/1998/namespace";
const colonChar = 58;
const xChar = 120;
function updateAttrs(oldVnode, vnode) {
    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs)
        return;
    if (oldAttrs === attrs)
        return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        const cur = attrs[key];
        const old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) {
                elm.setAttribute(key, "");
            }
            else if (cur === false) {
                elm.removeAttribute(key);
            }
            else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                }
                else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
const attrsModule = {
    create: updateAttrs,
    update: updateAttrs
};
//------------------------------------------------------------------------------
// class.ts
//------------------------------------------------------------------------------
function updateClass(oldVnode, vnode) {
    var cur, name, elm, oldClass = oldVnode.data.class, klass = vnode.data.class;
    if (!oldClass && !klass)
        return;
    if (oldClass === klass)
        return;
    oldClass = oldClass || {};
    klass = klass || {};
    elm = vnode.elm;
    for (name in oldClass) {
        if (name && !klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? "add" : "remove"](name);
        }
    }
}
const classModule = { create: updateClass, update: updateClass };

/**
 * Owl VDOM
 *
 * This file contains an implementation of a virtual DOM, which is a system that
 * can generate in-memory representations of a DOM tree, compare them, and
 * eventually change a concrete DOM tree to match its representation, in an
 * hopefully efficient way.
 *
 * Note that this code is a fork of Snabbdom, slightly tweaked/optimized for our
 * needs (see https://github.com/snabbdom/snabbdom).
 *
 * The main exported values are:
 * - interface VNode
 * - h function (a helper function to generate a vnode)
 * - patch function (to apply a vnode to an actual DOM node)
 */
function vnode(sel, data, children, text, elm) {
    let key = data === undefined ? undefined : data.key;
    return { sel, data, children, text, elm, key };
}
//------------------------------------------------------------------------------
// snabbdom.ts
//------------------------------------------------------------------------------
function isUndef(s) {
    return s === undefined;
}
function isDef(s) {
    return s !== undefined;
}
const emptyNode = vnode("", {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    let i, map = {}, key, ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined)
                map[key] = i;
        }
    }
    return map;
}
const hooks = ["create", "update", "remove", "destroy", "pre", "post"];
function init(modules, domApi) {
    let i, j, cbs = {};
    const api = domApi !== undefined ? domApi : htmlDomApi;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            const hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        const id = elm.id ? "#" + elm.id : "";
        const c = elm.className ? "." + elm.className.split(" ").join(".") : "";
        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                const parent = api.parentNode(childElm);
                api.removeChild(parent, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        let i, iLen, data = vnode.data;
        if (data !== undefined) {
            if (isDef((i = data.hook)) && isDef((i = i.init))) {
                i(vnode);
                data = vnode.data;
            }
        }
        let children = vnode.children, sel = vnode.sel;
        if (sel === "!") {
            if (isUndef(vnode.text)) {
                vnode.text = "";
            }
            vnode.elm = api.createComment(vnode.text);
        }
        else if (sel !== undefined) {
            const elm = vnode.elm ||
                (vnode.elm =
                    isDef(data) && isDef((i = data.ns))
                        ? api.createElementNS(i, sel)
                        : api.createElement(sel));
            for (i = 0, iLen = cbs.create.length; i < iLen; ++i)
                cbs.create[i](emptyNode, vnode);
            if (array(children)) {
                for (i = 0, iLen = children.length; i < iLen; ++i) {
                    const ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            }
            else if (primitive(vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create)
                    i.create(emptyNode, vnode);
                if (i.insert)
                    insertedVnodeQueue.push(vnode);
            }
        }
        else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        let i, iLen, j, jLen, data = vnode.data;
        if (data !== undefined) {
            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
                i(vnode);
            for (i = 0, iLen = cbs.destroy.length; i < iLen; ++i)
                cbs.destroy[i](vnode);
            if (vnode.children !== undefined) {
                for (j = 0, jLen = vnode.children.length; j < jLen; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            let i, iLen, listeners, rm, ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i = 0, iLen = cbs.remove.length; i < iLen; ++i)
                        cbs.remove[i](ch, rm);
                    if (isDef((i = ch.data)) && isDef((i = i.hook)) && isDef((i = i.remove))) {
                        i(ch, rm);
                    }
                    else {
                        rm();
                    }
                }
                else {
                    // Text node
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        let oldStartIdx = 0, newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    // New element
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    }
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        let i, iLen, hook;
        if (isDef((i = vnode.data)) && isDef((hook = i.hook)) && isDef((i = hook.prepatch))) {
            i(oldVnode, vnode);
        }
        const elm = (vnode.elm = oldVnode.elm);
        let oldCh = oldVnode.children;
        let ch = vnode.children;
        if (oldVnode === vnode)
            return;
        if (vnode.data !== undefined) {
            for (i = 0, iLen = cbs.update.length; i < iLen; ++i)
                cbs.update[i](oldVnode, vnode);
            i = vnode.data.hook;
            if (isDef(i) && isDef((i = i.update)))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            }
            else if (isDef(ch)) {
                if (isDef(oldVnode.text))
                    api.setTextContent(elm, "");
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, "");
            }
        }
        else if (oldVnode.text !== vnode.text) {
            if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef((i = hook.postpatch))) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        let i, iLen, elm, parent;
        const insertedVnodeQueue = [];
        for (i = 0, iLen = cbs.pre.length; i < iLen; ++i)
            cbs.pre[i]();
        if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        }
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0, iLen = insertedVnodeQueue.length; i < iLen; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0, iLen = cbs.post.length; i < iLen; ++i)
            cbs.post[i]();
        return vnode;
    };
}
//------------------------------------------------------------------------------
// is.ts
//------------------------------------------------------------------------------
const array = Array.isArray;
function primitive(s) {
    return typeof s === "string" || typeof s === "number";
}
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
const htmlDomApi = {
    createElement,
    createElementNS,
    createTextNode,
    createComment,
    insertBefore,
    removeChild,
    appendChild,
    parentNode,
    nextSibling,
    tagName,
    setTextContent
};
function addNS(data, children, sel) {
    if (sel === "dummy") {
        // we do not need to add the namespace on dummy elements, they come from a
        // subcomponent, which will handle the namespace itself
        return;
    }
    data.ns = "http://www.w3.org/2000/svg";
    if (sel !== "foreignObject" && children !== undefined) {
        for (let i = 0, iLen = children.length; i < iLen; ++i) {
            const child = children[i];
            let childData = child.data;
            if (childData !== undefined) {
                addNS(childData, child.children, child.sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i, iLen;
    if (c !== undefined) {
        data = b;
        if (array(c)) {
            children = c;
        }
        else if (primitive(c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (array(b)) {
            children = b;
        }
        else if (primitive(b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (children !== undefined) {
        for (i = 0, iLen = children.length; i < iLen; ++i) {
            if (primitive(children[i]))
                children[i] = vnode(undefined, undefined, undefined, children[i], undefined);
        }
    }
    return vnode(sel, data, children, text, undefined);
}

const patch = init([eventListenersModule, attrsModule, propsModule, classModule]);

/**
 * Owl QWeb Expression Parser
 *
 * Owl needs in various contexts to be able to understand the structure of a
 * string representing a javascript expression.  The usual goal is to be able
 * to rewrite some variables.  For example, if a template has
 *
 *  ```xml
 *  <t t-if="computeSomething({val: state.val})">...</t>
 * ```
 *
 * this needs to be translated in something like this:
 *
 * ```js
 *   if (context["computeSomething"]({val: context["state"].val})) { ... }
 * ```
 *
 * This file contains the implementation of an extremely naive tokenizer/parser
 * and evaluator for javascript expressions.  The supported grammar is basically
 * only expressive enough to understand the shape of objects, of arrays, and
 * various operators.
 */
//------------------------------------------------------------------------------
// Misc types, constants and helpers
//------------------------------------------------------------------------------
const RESERVED_WORDS = "true,false,NaN,null,undefined,debugger,console,window,in,instanceof,new,function,return,this,eval,void,Math,RegExp,Array,Object,Date".split(",");
const WORD_REPLACEMENT = {
    and: "&&",
    or: "||",
    gt: ">",
    gte: ">=",
    lt: "<",
    lte: "<="
};
const STATIC_TOKEN_MAP = {
    "{": "LEFT_BRACE",
    "}": "RIGHT_BRACE",
    "[": "LEFT_BRACKET",
    "]": "RIGHT_BRACKET",
    ":": "COLON",
    ",": "COMMA",
    "(": "LEFT_PAREN",
    ")": "RIGHT_PAREN"
};
// note that the space after typeof is relevant. It makes sure that the formatted
// expression has a space after typeof
const OPERATORS = "...,.,===,==,+,!==,!=,!,||,&&,>=,>,<=,<,?,-,*,/,%,typeof ,=>,=,;,in ".split(",");
let tokenizeString = function (expr) {
    let s = expr[0];
    let start = s;
    if (s !== "'" && s !== '"') {
        return false;
    }
    let i = 1;
    let cur;
    while (expr[i] && expr[i] !== start) {
        cur = expr[i];
        s += cur;
        if (cur === "\\") {
            i++;
            cur = expr[i];
            if (!cur) {
                throw new Error("Invalid expression");
            }
            s += cur;
        }
        i++;
    }
    if (expr[i] !== start) {
        throw new Error("Invalid expression");
    }
    s += start;
    return { type: "VALUE", value: s };
};
let tokenizeNumber = function (expr) {
    let s = expr[0];
    if (s && s.match(/[0-9]/)) {
        let i = 1;
        while (expr[i] && expr[i].match(/[0-9]|\./)) {
            s += expr[i];
            i++;
        }
        return { type: "VALUE", value: s };
    }
    else {
        return false;
    }
};
let tokenizeSymbol = function (expr) {
    let s = expr[0];
    if (s && s.match(/[a-zA-Z_\$]/)) {
        let i = 1;
        while (expr[i] && expr[i].match(/\w/)) {
            s += expr[i];
            i++;
        }
        if (s in WORD_REPLACEMENT) {
            return { type: "OPERATOR", value: WORD_REPLACEMENT[s], size: s.length };
        }
        return { type: "SYMBOL", value: s };
    }
    else {
        return false;
    }
};
const tokenizeStatic = function (expr) {
    const char = expr[0];
    if (char && char in STATIC_TOKEN_MAP) {
        return { type: STATIC_TOKEN_MAP[char], value: char };
    }
    return false;
};
const tokenizeOperator = function (expr) {
    for (let op of OPERATORS) {
        if (expr.startsWith(op)) {
            return { type: "OPERATOR", value: op };
        }
    }
    return false;
};
const TOKENIZERS = [
    tokenizeString,
    tokenizeNumber,
    tokenizeOperator,
    tokenizeSymbol,
    tokenizeStatic
];
/**
 * Convert a javascript expression (as a string) into a list of tokens. For
 * example: `tokenize("1 + b")` will return:
 * ```js
 *  [
 *   {type: "VALUE", value: "1"},
 *   {type: "OPERATOR", value: "+"},
 *   {type: "SYMBOL", value: "b"}
 * ]
 * ```
 */
function tokenize(expr) {
    const result = [];
    let token = true;
    while (token) {
        expr = expr.trim();
        if (expr) {
            for (let tokenizer of TOKENIZERS) {
                token = tokenizer(expr);
                if (token) {
                    result.push(token);
                    expr = expr.slice(token.size || token.value.length);
                    break;
                }
            }
        }
        else {
            token = false;
        }
    }
    if (expr.length) {
        throw new Error(`Tokenizer error: could not tokenize "${expr}"`);
    }
    return result;
}
//------------------------------------------------------------------------------
// Expression "evaluator"
//------------------------------------------------------------------------------
/**
 * This is the main function exported by this file. This is the code that will
 * process an expression (given as a string) and returns another expression with
 * proper lookups in the context.
 *
 * Usually, this kind of code would be very simple to do if we had an AST (so,
 * if we had a javascript parser), since then, we would only need to find the
 * variables and replace them.  However, a parser is more complicated, and there
 * are no standard builtin parser API.
 *
 * Since this method is applied to simple javasript expressions, and the work to
 * be done is actually quite simple, we actually can get away with not using a
 * parser, which helps with the code size.
 *
 * Here is the heuristic used by this method to determine if a token is a
 * variable:
 * - by default, all symbols are considered a variable
 * - unless the previous token is a dot (in that case, this is a property: `a.b`)
 * - or if the previous token is a left brace or a comma, and the next token is
 *   a colon (in that case, this is an object key: `{a: b}`)
 *
 * Some specific code is also required to support arrow functions. If we detect
 * the arrow operator, then we add the current (or some previous tokens) token to
 * the list of variables so it does not get replaced by a lookup in the context
 */
function compileExprToArray(expr, scope) {
    scope = Object.create(scope);
    const tokens = tokenize(expr);
    for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        let prevToken = tokens[i - 1];
        let nextToken = tokens[i + 1];
        let isVar = token.type === "SYMBOL" && !RESERVED_WORDS.includes(token.value);
        if (token.type === "SYMBOL" && !RESERVED_WORDS.includes(token.value)) {
            if (prevToken) {
                if (prevToken.type === "OPERATOR" && prevToken.value === ".") {
                    isVar = false;
                }
                else if (prevToken.type === "LEFT_BRACE" || prevToken.type === "COMMA") {
                    if (nextToken && nextToken.type === "COLON") {
                        isVar = false;
                    }
                }
            }
        }
        if (nextToken && nextToken.type === "OPERATOR" && nextToken.value === "=>") {
            if (token.type === "RIGHT_PAREN") {
                let j = i - 1;
                while (j > 0 && tokens[j].type !== "LEFT_PAREN") {
                    if (tokens[j].type === "SYMBOL" && tokens[j].originalValue) {
                        tokens[j].value = tokens[j].originalValue;
                        scope[tokens[j].value] = { id: tokens[j].value, expr: tokens[j].value };
                    }
                    j--;
                }
            }
            else {
                scope[token.value] = { id: token.value, expr: token.value };
            }
        }
        if (isVar) {
            token.varName = token.value;
            if (token.value in scope && "id" in scope[token.value]) {
                token.value = scope[token.value].expr;
            }
            else {
                token.originalValue = token.value;
                token.value = `scope['${token.value}']`;
            }
        }
    }
    return tokens;
}
function compileExpr(expr, scope) {
    return compileExprToArray(expr, scope)
        .map(t => t.value)
        .join("");
}

const INTERP_REGEXP = /\{\{.*?\}\}/g;
//------------------------------------------------------------------------------
// Compilation Context
//------------------------------------------------------------------------------
class CompilationContext {
    constructor(name) {
        this.code = [];
        this.variables = {};
        this.escaping = false;
        this.parentNode = null;
        this.parentTextNode = null;
        this.rootNode = null;
        this.indentLevel = 0;
        this.shouldDefineParent = false;
        this.shouldDefineScope = false;
        this.protectedScopeNumber = 0;
        this.shouldDefineQWeb = false;
        this.shouldDefineUtils = false;
        this.shouldDefineRefs = false;
        this.shouldDefineResult = true;
        this.loopNumber = 0;
        this.inPreTag = false;
        this.allowMultipleRoots = false;
        this.hasParentWidget = false;
        this.hasKey0 = false;
        this.keyStack = [];
        this.rootContext = this;
        this.templateName = name || "noname";
        this.addLine("let h = this.h;");
    }
    generateID() {
        return CompilationContext.nextID++;
    }
    /**
     * This method generates a "template key", which is basically a unique key
     * which depends on the currently set keys, and on the iteration numbers (if
     * we are in a loop).
     *
     * Such a key is necessary when we need to associate an id to some element
     * generated by a template (for example, a component)
     */
    generateTemplateKey(prefix = "") {
        const id = this.generateID();
        if (this.loopNumber === 0 && !this.hasKey0) {
            return `'${prefix}__${id}__'`;
        }
        let key = `\`${prefix}__${id}__`;
        let start = this.hasKey0 ? 0 : 1;
        for (let i = start; i < this.loopNumber + 1; i++) {
            key += `\${key${i}}__`;
        }
        this.addLine(`let k${id} = ${key}\`;`);
        return `k${id}`;
    }
    generateCode() {
        if (this.shouldDefineResult) {
            this.code.unshift("    let result;");
        }
        if (this.shouldDefineScope) {
            this.code.unshift("    let scope = Object.create(context);");
        }
        if (this.shouldDefineRefs) {
            this.code.unshift("    context.__owl__.refs = context.__owl__.refs || {};");
        }
        if (this.shouldDefineParent) {
            if (this.hasParentWidget) {
                this.code.unshift("    let parent = extra.parent;");
            }
            else {
                this.code.unshift("    let parent = context;");
            }
        }
        if (this.shouldDefineQWeb) {
            this.code.unshift("    let QWeb = this.constructor;");
        }
        if (this.shouldDefineUtils) {
            this.code.unshift("    let utils = this.constructor.utils;");
        }
        return this.code;
    }
    withParent(node) {
        if (!this.allowMultipleRoots &&
            this === this.rootContext &&
            (this.parentNode || this.parentTextNode)) {
            throw new Error("A template should not have more than one root node");
        }
        if (!this.rootContext.rootNode) {
            this.rootContext.rootNode = node;
        }
        if (!this.parentNode && this.rootContext.shouldDefineResult) {
            this.addLine(`result = vn${node};`);
        }
        return this.subContext("parentNode", node);
    }
    subContext(key, value) {
        const newContext = Object.create(this);
        newContext[key] = value;
        return newContext;
    }
    indent() {
        this.rootContext.indentLevel++;
    }
    dedent() {
        this.rootContext.indentLevel--;
    }
    addLine(line) {
        const prefix = new Array(this.indentLevel + 2).join("    ");
        this.code.push(prefix + line);
        return this.code.length - 1;
    }
    addIf(condition) {
        this.addLine(`if (${condition}) {`);
        this.indent();
    }
    addElse() {
        this.dedent();
        this.addLine("} else {");
        this.indent();
    }
    closeIf() {
        this.dedent();
        this.addLine("}");
    }
    getValue(val) {
        return val in this.variables ? this.getValue(this.variables[val]) : val;
    }
    /**
     * Prepare an expression for being consumed at render time.  Its main job
     * is to
     * - replace unknown variables by a lookup in the context
     * - replace already defined variables by their internal name
     */
    formatExpression(expr) {
        this.rootContext.shouldDefineScope = true;
        return compileExpr(expr, this.variables);
    }
    captureExpression(expr) {
        this.rootContext.shouldDefineScope = true;
        const argId = this.generateID();
        const tokens = compileExprToArray(expr, this.variables);
        const done = new Set();
        return tokens
            .map(tok => {
            if (tok.varName) {
                if (!done.has(tok.varName)) {
                    done.add(tok.varName);
                    this.addLine(`const ${tok.varName}_${argId} = ${tok.value};`);
                }
                tok.value = `${tok.varName}_${argId}`;
            }
            return tok.value;
        })
            .join("");
    }
    /**
     * Perform string interpolation on the given string. Note that if the whole
     * string is an expression, it simply returns it (formatted and enclosed in
     * parentheses).
     * For instance:
     *   'Hello {{x}}!' -> `Hello ${x}`
     *   '{{x ? 'a': 'b'}}' -> (x ? 'a' : 'b')
     */
    interpolate(s) {
        let matches = s.match(INTERP_REGEXP);
        if (matches && matches[0].length === s.length) {
            return `(${this.formatExpression(s.slice(2, -2))})`;
        }
        let r = s.replace(/\{\{.*?\}\}/g, s => "${" + this.formatExpression(s.slice(2, -2)) + "}");
        return "`" + r + "`";
    }
    startProtectScope(codeBlock) {
        const protectID = this.generateID();
        this.rootContext.protectedScopeNumber++;
        this.rootContext.shouldDefineScope = true;
        const scopeExpr = `Object.create(scope);`;
        this.addLine(`let _origScope${protectID} = scope;`);
        this.addLine(`scope = ${scopeExpr}`);
        if (!codeBlock) {
            this.addLine(`scope.__access_mode__ = 'ro';`);
        }
        return protectID;
    }
    stopProtectScope(protectID) {
        this.rootContext.protectedScopeNumber--;
        this.addLine(`scope = _origScope${protectID};`);
    }
}
CompilationContext.nextID = 1;

const browser = {
    setTimeout: window.setTimeout.bind(window),
    clearTimeout: window.clearTimeout.bind(window),
    setInterval: window.setInterval.bind(window),
    clearInterval: window.clearInterval.bind(window),
    requestAnimationFrame: window.requestAnimationFrame.bind(window),
    random: Math.random,
    Date: window.Date,
    fetch: (window.fetch || (() => { })).bind(window),
    localStorage: window.localStorage
};

/**
 * Owl Utils
 *
 * We have here a small collection of utility functions:
 *
 * - whenReady
 * - loadJS
 * - loadFile
 * - escape
 * - debounce
 */
function whenReady(fn) {
    return new Promise(function (resolve) {
        if (document.readyState !== "loading") {
            resolve();
        }
        else {
            document.addEventListener("DOMContentLoaded", resolve, false);
        }
    }).then(fn || function () { });
}
const loadedScripts = {};
function loadJS(url) {
    if (url in loadedScripts) {
        return loadedScripts[url];
    }
    const promise = new Promise(function (resolve, reject) {
        const script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.onload = function () {
            resolve();
        };
        script.onerror = function () {
            reject(`Error loading file '${url}'`);
        };
        const head = document.head || document.getElementsByTagName("head")[0];
        head.appendChild(script);
    });
    loadedScripts[url] = promise;
    return promise;
}
async function loadFile(url) {
    const result = await browser.fetch(url);
    if (!result.ok) {
        throw new Error("Error while fetching xml templates");
    }
    return await result.text();
}
function escape(str) {
    if (str === undefined) {
        return "";
    }
    if (typeof str === "number") {
        return String(str);
    }
    const p = document.createElement("p");
    p.textContent = str;
    return p.innerHTML;
}
/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing.
 *
 * Inspired by https://davidwalsh.name/javascript-debounce-function
 */
function debounce(func, wait, immediate) {
    let timeout;
    return function () {
        const context = this;
        const args = arguments;
        function later() {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        }
        const callNow = immediate && !timeout;
        browser.clearTimeout(timeout);
        timeout = browser.setTimeout(later, wait);
        if (callNow) {
            func.apply(context, args);
        }
    };
}
function shallowEqual(p1, p2) {
    for (let k in p1) {
        if (p1[k] !== p2[k]) {
            return false;
        }
    }
    return true;
}

var _utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    whenReady: whenReady,
    loadJS: loadJS,
    loadFile: loadFile,
    escape: escape,
    debounce: debounce,
    shallowEqual: shallowEqual
});

//------------------------------------------------------------------------------
// Const/global stuff/helpers
//------------------------------------------------------------------------------
const DISABLED_TAGS = ["input", "textarea", "button", "select", "option", "optgroup"];
const TRANSLATABLE_ATTRS = ["label", "title", "placeholder", "alt"];
const lineBreakRE = /[\r\n]/;
const whitespaceRE = /\s+/g;
const NODE_HOOKS_PARAMS = {
    create: "(_, n)",
    insert: "vn",
    remove: "(vn, rm)",
    destroy: "()"
};
function isComponent(obj) {
    return obj && obj.hasOwnProperty("__owl__");
}
const UTILS = {
    zero: Symbol("zero"),
    toObj(expr) {
        if (typeof expr === "string") {
            expr = expr.trim();
            if (!expr) {
                return {};
            }
            let words = expr.split(/\s+/);
            let result = {};
            for (let i = 0; i < words.length; i++) {
                result[words[i]] = true;
            }
            return result;
        }
        return expr;
    },
    shallowEqual,
    addNameSpace(vnode) {
        addNS(vnode.data, vnode.children, vnode.sel);
    },
    VDomArray: class VDomArray extends Array {
    },
    vDomToString: function (vdom) {
        return vdom
            .map(vnode => {
            if (vnode.sel) {
                const node = document.createElement(vnode.sel);
                const result = patch(node, vnode);
                return result.elm.outerHTML;
            }
            else {
                return vnode.text;
            }
        })
            .join("");
    },
    getComponent(obj) {
        while (obj && !isComponent(obj)) {
            obj = obj.__proto__;
        }
        return obj;
    },
    getScope(obj, property) {
        const obj0 = obj;
        while (obj &&
            !obj.hasOwnProperty(property) &&
            !(obj.hasOwnProperty("__access_mode__") && obj.__access_mode__ === "ro")) {
            const newObj = obj.__proto__;
            if (!newObj || isComponent(newObj)) {
                return obj0;
            }
            obj = newObj;
        }
        return obj;
    }
};
function parseXML(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, "text/xml");
    if (doc.getElementsByTagName("parsererror").length) {
        let msg = "Invalid XML in template.";
        const parsererrorText = doc.getElementsByTagName("parsererror")[0].textContent;
        if (parsererrorText) {
            msg += "\nThe parser has produced the following error message:\n" + parsererrorText;
            const re = /\d+/g;
            const firstMatch = re.exec(parsererrorText);
            if (firstMatch) {
                const lineNumber = Number(firstMatch[0]);
                const line = xml.split("\n")[lineNumber - 1];
                const secondMatch = re.exec(parsererrorText);
                if (line && secondMatch) {
                    const columnIndex = Number(secondMatch[0]) - 1;
                    if (line[columnIndex]) {
                        msg +=
                            `\nThe error might be located at xml line ${lineNumber} column ${columnIndex}\n` +
                                `${line}\n${"-".repeat(columnIndex - 1)}^`;
                    }
                }
            }
        }
        throw new Error(msg);
    }
    return doc;
}
function escapeQuotes(str) {
    return str.replace(/\'/g, "\\'");
}
//------------------------------------------------------------------------------
// QWeb rendering engine
//------------------------------------------------------------------------------
class QWeb extends EventBus {
    constructor(config = {}) {
        super();
        this.h = h;
        // recursiveTemplates contains sub templates called with t-call, but which
        // ends up in recursive situations.  This is very similar to the slot situation,
        // as in we need to propagate the scope.
        this.subTemplates = {};
        this.isUpdating = false;
        this.templates = Object.create(QWeb.TEMPLATES);
        if (config.templates) {
            this.addTemplates(config.templates);
        }
        if (config.translateFn) {
            this.translateFn = config.translateFn;
        }
    }
    static addDirective(directive) {
        if (directive.name in QWeb.DIRECTIVE_NAMES) {
            throw new Error(`Directive "${directive.name} already registered`);
        }
        QWeb.DIRECTIVES.push(directive);
        QWeb.DIRECTIVE_NAMES[directive.name] = 1;
        QWeb.DIRECTIVES.sort((d1, d2) => d1.priority - d2.priority);
        if (directive.extraNames) {
            directive.extraNames.forEach(n => (QWeb.DIRECTIVE_NAMES[n] = 1));
        }
    }
    static registerComponent(name, Component) {
        if (QWeb.components[name]) {
            throw new Error(`Component '${name}' has already been registered`);
        }
        QWeb.components[name] = Component;
    }
    /**
     * Register globally a template.  All QWeb instances will obtain their
     * templates from their own template map, and then, from the global static
     * TEMPLATES property.
     */
    static registerTemplate(name, template) {
        if (QWeb.TEMPLATES[name]) {
            throw new Error(`Template '${name}' has already been registered`);
        }
        const qweb = new QWeb();
        qweb.addTemplate(name, template);
        QWeb.TEMPLATES[name] = qweb.templates[name];
    }
    /**
     * Add a template to the internal template map.  Note that it is not
     * immediately compiled.
     */
    addTemplate(name, xmlString, allowDuplicate) {
        if (allowDuplicate && name in this.templates) {
            return;
        }
        const doc = parseXML(xmlString);
        if (!doc.firstChild) {
            throw new Error("Invalid template (should not be empty)");
        }
        this._addTemplate(name, doc.firstChild);
    }
    /**
     * Load templates from a xml (as a string or xml document).  This will look up
     * for the first <templates> tag, and will consider each child of this as a
     * template, with the name given by the t-name attribute.
     */
    addTemplates(xmlstr) {
        const doc = typeof xmlstr === "string" ? parseXML(xmlstr) : xmlstr;
        const templates = doc.getElementsByTagName("templates")[0];
        if (!templates) {
            return;
        }
        for (let elem of templates.children) {
            const name = elem.getAttribute("t-name");
            this._addTemplate(name, elem);
        }
    }
    _addTemplate(name, elem) {
        if (name in this.templates) {
            throw new Error(`Template ${name} already defined`);
        }
        this._processTemplate(elem);
        const template = {
            elem,
            fn: function (context, extra) {
                const compiledFunction = this._compile(name, elem);
                template.fn = compiledFunction;
                return compiledFunction.call(this, context, extra);
            }
        };
        this.templates[name] = template;
    }
    _processTemplate(elem) {
        let tbranch = elem.querySelectorAll("[t-elif], [t-else]");
        for (let i = 0, ilen = tbranch.length; i < ilen; i++) {
            let node = tbranch[i];
            let prevElem = node.previousElementSibling;
            let pattr = function (name) {
                return prevElem.getAttribute(name);
            };
            let nattr = function (name) {
                return +!!node.getAttribute(name);
            };
            if (prevElem && (pattr("t-if") || pattr("t-elif"))) {
                if (pattr("t-foreach")) {
                    throw new Error("t-if cannot stay at the same level as t-foreach when using t-elif or t-else");
                }
                if (["t-if", "t-elif", "t-else"].map(nattr).reduce(function (a, b) {
                    return a + b;
                }) > 1) {
                    throw new Error("Only one conditional branching directive is allowed per node");
                }
                // All text (with only spaces) and comment nodes (nodeType 8) between
                // branch nodes are removed
                let textNode;
                while ((textNode = node.previousSibling) !== prevElem) {
                    if (textNode.nodeValue.trim().length && textNode.nodeType !== 8) {
                        throw new Error("text is not allowed between branching directives");
                    }
                    textNode.remove();
                }
            }
            else {
                throw new Error("t-elif and t-else directives must be preceded by a t-if or t-elif directive");
            }
        }
    }
    /**
     * Render a template
     *
     * @param {string} name the template should already have been added
     */
    render(name, context = {}, extra = null) {
        const template = this.templates[name];
        if (!template) {
            throw new Error(`Template ${name} does not exist`);
        }
        return template.fn.call(this, context, extra);
    }
    /**
     * Render a template to a html string.
     *
     * Note that this is more limited than the `render` method: it is not suitable
     * to render a full component tree, since this is an asynchronous operation.
     * This method can only render templates without components.
     */
    renderToString(name, context = {}, extra) {
        const vnode = this.render(name, context, extra);
        if (vnode.sel === undefined) {
            return vnode.text;
        }
        const node = document.createElement(vnode.sel);
        const elem = patch(node, vnode).elm;
        function escapeTextNodes(node) {
            if (node.nodeType === 3) {
                node.textContent = escape(node.textContent);
            }
            for (let n of node.childNodes) {
                escapeTextNodes(n);
            }
        }
        escapeTextNodes(elem);
        return elem.outerHTML;
    }
    /**
     * Force all widgets connected to this QWeb instance to rerender themselves.
     *
     * This method is mostly useful for external code that want to modify the
     * application in some cases.  For example, a router plugin.
     */
    forceUpdate() {
        this.isUpdating = true;
        Promise.resolve().then(() => {
            if (this.isUpdating) {
                this.isUpdating = false;
                this.trigger("update");
            }
        });
    }
    _compile(name, elem, parentContext, defineKey) {
        const isDebug = elem.attributes.hasOwnProperty("t-debug");
        const ctx = new CompilationContext(name);
        if (elem.tagName !== "t") {
            ctx.shouldDefineResult = false;
        }
        if (parentContext) {
            ctx.variables = Object.create(parentContext.variables);
            ctx.parentNode = parentContext.parentNode || ctx.generateID();
            ctx.allowMultipleRoots = true;
            ctx.hasParentWidget = true;
            ctx.shouldDefineResult = false;
            ctx.addLine(`let c${ctx.parentNode} = extra.parentNode;`);
            if (defineKey) {
                ctx.addLine(`let key0 = extra.key || "";`);
                ctx.hasKey0 = true;
            }
        }
        this._compileNode(elem, ctx);
        if (!parentContext) {
            if (ctx.shouldDefineResult) {
                ctx.addLine(`return result;`);
            }
            else {
                if (!ctx.rootNode) {
                    throw new Error(`A template should have one root node (${ctx.templateName})`);
                }
                ctx.addLine(`return vn${ctx.rootNode};`);
            }
        }
        let code = ctx.generateCode();
        const templateName = ctx.templateName.replace(/`/g, "'").slice(0, 200);
        code.unshift(`    // Template name: "${templateName}"`);
        let template;
        try {
            template = new Function("context, extra", code.join("\n"));
        }
        catch (e) {
            console.groupCollapsed(`Invalid Code generated by ${templateName}`);
            console.warn(code.join("\n"));
            console.groupEnd();
            throw new Error(`Invalid generated code while compiling template '${templateName}': ${e.message}`);
        }
        if (isDebug) {
            const tpl = this.templates[name];
            if (tpl) {
                const msg = `Template: ${tpl.elem.outerHTML}\nCompiled code:\n${template.toString()}`;
                console.log(msg);
            }
        }
        return template;
    }
    /**
     * Generate code from an xml node
     *
     */
    _compileNode(node, ctx) {
        if (!(node instanceof Element)) {
            // this is a text node, there are no directive to apply
            let text = node.textContent;
            if (!ctx.inPreTag) {
                if (lineBreakRE.test(text) && !text.trim()) {
                    return;
                }
                text = text.replace(whitespaceRE, " ");
            }
            if (this.translateFn) {
                if (node.parentNode.getAttribute("t-translation") !== "off") {
                    text = this.translateFn(text);
                }
            }
            if (ctx.parentNode) {
                if (node.nodeType === 3) {
                    ctx.addLine(`c${ctx.parentNode}.push({text: \`${text}\`});`);
                }
                else if (node.nodeType === 8) {
                    ctx.addLine(`c${ctx.parentNode}.push(h('!', \`${text}\`));`);
                }
            }
            else if (ctx.parentTextNode) {
                ctx.addLine(`vn${ctx.parentTextNode}.text += \`${text}\`;`);
            }
            else {
                // this is an unusual situation: this text node is the result of the
                // template rendering.
                let nodeID = ctx.generateID();
                ctx.addLine(`let vn${nodeID} = {text: \`${text}\`};`);
                ctx.addLine(`result = vn${nodeID};`);
                ctx.rootContext.rootNode = nodeID;
                ctx.rootContext.parentTextNode = nodeID;
            }
            return;
        }
        const firstLetter = node.tagName[0];
        if (firstLetter === firstLetter.toUpperCase()) {
            // this is a component, we modify in place the xml document to change
            // <SomeComponent ... /> to <t t-component="SomeComponent" ... />
            node.setAttribute("t-component", node.tagName);
        }
        else if (node.tagName !== "t" && node.hasAttribute("t-component")) {
            throw new Error(`Directive 't-component' can only be used on <t> nodes (used on a <${node.tagName}>)`);
        }
        const attributes = node.attributes;
        const validDirectives = [];
        const finalizers = [];
        // maybe this is not optimal: we iterate on all attributes here, and again
        // just after for each directive.
        for (let i = 0; i < attributes.length; i++) {
            let attrName = attributes[i].name;
            if (attrName.startsWith("t-")) {
                let dName = attrName.slice(2).split(/-|\./)[0];
                if (!(dName in QWeb.DIRECTIVE_NAMES)) {
                    throw new Error(`Unknown QWeb directive: '${attrName}'`);
                }
                if (node.tagName !== "t" && (attrName === "t-esc" || attrName === "t-raw")) {
                    const tNode = document.createElement("t");
                    tNode.setAttribute(attrName, node.getAttribute(attrName));
                    for (let child of Array.from(node.childNodes)) {
                        tNode.appendChild(child);
                    }
                    node.appendChild(tNode);
                    node.removeAttribute(attrName);
                }
            }
        }
        const DIR_N = QWeb.DIRECTIVES.length;
        const ATTR_N = attributes.length;
        let withHandlers = false;
        for (let i = 0; i < DIR_N; i++) {
            let directive = QWeb.DIRECTIVES[i];
            let fullName;
            let value;
            for (let j = 0; j < ATTR_N; j++) {
                const name = attributes[j].name;
                if (name === "t-" + directive.name ||
                    name.startsWith("t-" + directive.name + "-") ||
                    name.startsWith("t-" + directive.name + ".")) {
                    fullName = name;
                    value = attributes[j].textContent;
                    validDirectives.push({ directive, value, fullName });
                    if (directive.name === "on" || directive.name === "model") {
                        withHandlers = true;
                    }
                }
            }
        }
        for (let { directive, value, fullName } of validDirectives) {
            if (directive.finalize) {
                finalizers.push({ directive, value, fullName });
            }
            if (directive.atNodeEncounter) {
                const isDone = directive.atNodeEncounter({
                    node,
                    qweb: this,
                    ctx,
                    fullName,
                    value
                });
                if (isDone) {
                    for (let { directive, value, fullName } of finalizers) {
                        directive.finalize({ node, qweb: this, ctx, fullName, value });
                    }
                    return;
                }
            }
        }
        if (node.nodeName !== "t") {
            let nodeID = this._compileGenericNode(node, ctx, withHandlers);
            ctx = ctx.withParent(nodeID);
            let nodeHooks = {};
            let addNodeHook = function (hook, handler) {
                nodeHooks[hook] = nodeHooks[hook] || [];
                nodeHooks[hook].push(handler);
            };
            for (let { directive, value, fullName } of validDirectives) {
                if (directive.atNodeCreation) {
                    directive.atNodeCreation({
                        node,
                        qweb: this,
                        ctx,
                        fullName,
                        value,
                        nodeID,
                        addNodeHook
                    });
                }
            }
            if (Object.keys(nodeHooks).length) {
                ctx.addLine(`p${nodeID}.hook = {`);
                for (let hook in nodeHooks) {
                    ctx.addLine(`  ${hook}: ${NODE_HOOKS_PARAMS[hook]} => {`);
                    for (let handler of nodeHooks[hook]) {
                        ctx.addLine(`    ${handler}`);
                    }
                    ctx.addLine(`  },`);
                }
                ctx.addLine(`};`);
            }
        }
        if (node.nodeName === "pre") {
            ctx = ctx.subContext("inPreTag", true);
        }
        this._compileChildren(node, ctx);
        // svg support
        // we hadd svg namespace if it is a svg or if it is a g, but only if it is
        // the root node.  This is the easiest way to support svg sub components:
        // they need to have a g tag as root. Otherwise, we would need a complete
        // list of allowed svg tags.
        const shouldAddNS = node.nodeName === "svg" || (node.nodeName === "g" && ctx.rootNode === ctx.parentNode);
        if (shouldAddNS) {
            ctx.rootContext.shouldDefineUtils = true;
            ctx.addLine(`utils.addNameSpace(vn${ctx.parentNode});`);
        }
        for (let { directive, value, fullName } of finalizers) {
            directive.finalize({ node, qweb: this, ctx, fullName, value });
        }
    }
    _compileGenericNode(node, ctx, withHandlers = true) {
        // nodeType 1 is generic tag
        if (node.nodeType !== 1) {
            throw new Error("unsupported node type");
        }
        const attributes = node.attributes;
        const attrs = [];
        const props = [];
        const tattrs = [];
        function handleBooleanProps(key, val) {
            let isProp = false;
            if (node.nodeName === "input" && key === "checked") {
                let type = node.getAttribute("type");
                if (type === "checkbox" || type === "radio") {
                    isProp = true;
                }
            }
            if (node.nodeName === "option" && key === "selected") {
                isProp = true;
            }
            if (key === "disabled" && DISABLED_TAGS.indexOf(node.nodeName) > -1) {
                isProp = true;
            }
            if ((key === "readonly" && node.nodeName === "input") || node.nodeName === "textarea") {
                isProp = true;
            }
            if (isProp) {
                props.push(`${key}: _${val}`);
            }
        }
        let classObj = "";
        for (let i = 0; i < attributes.length; i++) {
            let name = attributes[i].name;
            let value = attributes[i].textContent;
            if (this.translateFn && TRANSLATABLE_ATTRS.includes(name)) {
                value = this.translateFn(value);
            }
            // regular attributes
            if (!name.startsWith("t-") && !node.getAttribute("t-attf-" + name)) {
                const attID = ctx.generateID();
                if (name === "class") {
                    if ((value = value.trim())) {
                        let classDef = value
                            .split(/\s+/)
                            .map(a => `'${escapeQuotes(a)}':true`)
                            .join(",");
                        classObj = `_${ctx.generateID()}`;
                        ctx.addLine(`let ${classObj} = {${classDef}};`);
                    }
                }
                else {
                    ctx.addLine(`let _${attID} = '${escapeQuotes(value)}';`);
                    if (!name.match(/^[a-zA-Z]+$/)) {
                        // attribute contains 'non letters' => we want to quote it
                        name = '"' + name + '"';
                    }
                    attrs.push(`${name}: _${attID}`);
                    handleBooleanProps(name, attID);
                }
            }
            // dynamic attributes
            if (name.startsWith("t-att-")) {
                let attName = name.slice(6);
                const v = ctx.getValue(value);
                let formattedValue = typeof v === "string" ? ctx.formatExpression(v) : `scope.${v.id}`;
                if (attName === "class") {
                    ctx.rootContext.shouldDefineUtils = true;
                    formattedValue = `utils.toObj(${formattedValue})`;
                    if (classObj) {
                        ctx.addLine(`Object.assign(${classObj}, ${formattedValue})`);
                    }
                    else {
                        classObj = `_${ctx.generateID()}`;
                        ctx.addLine(`let ${classObj} = ${formattedValue};`);
                    }
                }
                else {
                    const attID = ctx.generateID();
                    if (!attName.match(/^[a-zA-Z]+$/)) {
                        // attribute contains 'non letters' => we want to quote it
                        attName = '"' + attName + '"';
                    }
                    // we need to combine dynamic with non dynamic attributes:
                    // class="a" t-att-class="'yop'" should be rendered as class="a yop"
                    const attValue = node.getAttribute(attName);
                    if (attValue) {
                        const attValueID = ctx.generateID();
                        ctx.addLine(`let _${attValueID} = ${formattedValue};`);
                        formattedValue = `'${attValue}' + (_${attValueID} ? ' ' + _${attValueID} : '')`;
                        const attrIndex = attrs.findIndex(att => att.startsWith(attName + ":"));
                        attrs.splice(attrIndex, 1);
                    }
                    ctx.addLine(`let _${attID} = ${formattedValue};`);
                    attrs.push(`${attName}: _${attID}`);
                    handleBooleanProps(attName, attID);
                }
            }
            if (name.startsWith("t-attf-")) {
                let attName = name.slice(7);
                if (!attName.match(/^[a-zA-Z]+$/)) {
                    // attribute contains 'non letters' => we want to quote it
                    attName = '"' + attName + '"';
                }
                const formattedExpr = ctx.interpolate(value);
                const attID = ctx.generateID();
                let staticVal = node.getAttribute(attName);
                if (staticVal) {
                    ctx.addLine(`let _${attID} = '${staticVal} ' + ${formattedExpr};`);
                }
                else {
                    ctx.addLine(`let _${attID} = ${formattedExpr};`);
                }
                attrs.push(`${attName}: _${attID}`);
            }
            // t-att= attributes
            if (name === "t-att") {
                let id = ctx.generateID();
                ctx.addLine(`let _${id} = ${ctx.formatExpression(value)};`);
                tattrs.push(id);
            }
        }
        let nodeID = ctx.generateID();
        let key = ctx.loopNumber || ctx.hasKey0 ? `\`\${key${ctx.loopNumber}}_${nodeID}\`` : nodeID;
        const parts = [`key:${key}`];
        if (attrs.length + tattrs.length > 0) {
            parts.push(`attrs:{${attrs.join(",")}}`);
        }
        if (props.length > 0) {
            parts.push(`props:{${props.join(",")}}`);
        }
        if (classObj) {
            parts.push(`class:${classObj}`);
        }
        if (withHandlers) {
            parts.push(`on:{}`);
        }
        ctx.addLine(`let c${nodeID} = [], p${nodeID} = {${parts.join(",")}};`);
        for (let id of tattrs) {
            ctx.addIf(`_${id} instanceof Array`);
            ctx.addLine(`p${nodeID}.attrs[_${id}[0]] = _${id}[1];`);
            ctx.addElse();
            ctx.addLine(`for (let key in _${id}) {`);
            ctx.indent();
            ctx.addLine(`p${nodeID}.attrs[key] = _${id}[key];`);
            ctx.dedent();
            ctx.addLine(`}`);
            ctx.closeIf();
        }
        ctx.addLine(`let vn${nodeID} = h('${node.nodeName}', p${nodeID}, c${nodeID});`);
        if (ctx.parentNode) {
            ctx.addLine(`c${ctx.parentNode}.push(vn${nodeID});`);
        }
        else if (ctx.loopNumber || ctx.hasKey0) {
            ctx.rootContext.shouldDefineResult = true;
            ctx.addLine(`result = vn${nodeID};`);
        }
        return nodeID;
    }
    _compileChildren(node, ctx) {
        if (node.childNodes.length > 0) {
            for (let child of Array.from(node.childNodes)) {
                this._compileNode(child, ctx);
            }
        }
    }
}
QWeb.utils = UTILS;
QWeb.components = Object.create(null);
QWeb.DIRECTIVE_NAMES = {
    name: 1,
    att: 1,
    attf: 1,
    translation: 1
};
QWeb.DIRECTIVES = [];
QWeb.TEMPLATES = {};
QWeb.nextId = 1;
// dev mode enables better error messages or more costly validations
QWeb.dev = false;
// slots contains sub templates defined with t-set inside t-component nodes, and
// are meant to be used by the t-slot directive.
QWeb.slots = {};
QWeb.nextSlotId = 1;

const parser = new DOMParser();
function htmlToVDOM(html) {
    const doc = parser.parseFromString(html, "text/html");
    const result = [];
    for (let child of doc.body.childNodes) {
        result.push(htmlToVNode(child));
    }
    return result;
}
function htmlToVNode(node) {
    if (!(node instanceof Element)) {
        return { text: node.textContent };
    }
    const attrs = {};
    for (let attr of node.attributes) {
        attrs[attr.name] = attr.textContent;
    }
    const children = [];
    for (let c of node.childNodes) {
        children.push(htmlToVNode(c));
    }
    return h(node.tagName, { attrs }, children);
}

/**
 * Owl QWeb Directives
 *
 * This file contains the implementation of most standard QWeb directives:
 * - t-esc
 * - t-raw
 * - t-set/t-value
 * - t-if/t-elif/t-else
 * - t-call
 * - t-foreach/t-as
 * - t-debug
 * - t-log
 */
//------------------------------------------------------------------------------
// t-esc and t-raw
//------------------------------------------------------------------------------
QWeb.utils.htmlToVDOM = htmlToVDOM;
function compileValueNode(value, node, qweb, ctx) {
    ctx.rootContext.shouldDefineScope = true;
    if (value === "0") {
        if (ctx.parentNode) {
            // the 'zero' magical symbol is where we can find the result of the rendering
            // of  the body of the t-call.
            ctx.rootContext.shouldDefineUtils = true;
            const zeroArgs = ctx.escaping
                ? `{text: utils.vDomToString(scope[utils.zero])}`
                : `...scope[utils.zero]`;
            ctx.addLine(`c${ctx.parentNode}.push(${zeroArgs});`);
        }
        return;
    }
    let exprID;
    if (typeof value === "string") {
        exprID = `_${ctx.generateID()}`;
        ctx.addLine(`let ${exprID} = ${ctx.formatExpression(value)};`);
    }
    else {
        exprID = `scope.${value.id}`;
    }
    ctx.addIf(`${exprID} != null`);
    if (ctx.escaping) {
        let protectID;
        if (value.hasBody) {
            protectID = ctx.startProtectScope();
            ctx.addLine(`${exprID} = ${exprID} instanceof utils.VDomArray ? utils.vDomToString(${exprID}) : ${exprID};`);
        }
        if (ctx.parentTextNode) {
            ctx.addLine(`vn${ctx.parentTextNode}.text += ${exprID};`);
        }
        else if (ctx.parentNode) {
            ctx.addLine(`c${ctx.parentNode}.push({text: ${exprID}});`);
        }
        else {
            let nodeID = ctx.generateID();
            ctx.rootContext.rootNode = nodeID;
            ctx.rootContext.parentTextNode = nodeID;
            ctx.addLine(`let vn${nodeID} = {text: ${exprID}};`);
            if (ctx.rootContext.shouldDefineResult) {
                ctx.addLine(`result = vn${nodeID}`);
            }
        }
        if (value.hasBody) {
            ctx.stopProtectScope(protectID);
        }
    }
    else {
        ctx.rootContext.shouldDefineUtils = true;
        if (value.hasBody) {
            ctx.addLine(`const vnodeArray = ${exprID} instanceof utils.VDomArray ? ${exprID} : utils.htmlToVDOM(${exprID});`);
            ctx.addLine(`c${ctx.parentNode}.push(...vnodeArray);`);
        }
        else {
            ctx.addLine(`c${ctx.parentNode}.push(...utils.htmlToVDOM(${exprID}));`);
        }
    }
    if (node.childNodes.length) {
        ctx.addElse();
        qweb._compileChildren(node, ctx);
    }
    ctx.closeIf();
}
QWeb.addDirective({
    name: "esc",
    priority: 70,
    atNodeEncounter({ node, qweb, ctx }) {
        let value = ctx.getValue(node.getAttribute("t-esc"));
        compileValueNode(value, node, qweb, ctx.subContext("escaping", true));
        return true;
    }
});
QWeb.addDirective({
    name: "raw",
    priority: 80,
    atNodeEncounter({ node, qweb, ctx }) {
        let value = ctx.getValue(node.getAttribute("t-raw"));
        compileValueNode(value, node, qweb, ctx);
        return true;
    }
});
//------------------------------------------------------------------------------
// t-set
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "set",
    extraNames: ["value"],
    priority: 60,
    atNodeEncounter({ node, qweb, ctx }) {
        ctx.rootContext.shouldDefineScope = true;
        const variable = node.getAttribute("t-set");
        let value = node.getAttribute("t-value");
        ctx.variables[variable] = ctx.variables[variable] || {};
        let qwebvar = ctx.variables[variable];
        const hasBody = node.hasChildNodes();
        qwebvar.id = variable;
        qwebvar.expr = `scope.${variable}`;
        if (value) {
            const formattedValue = ctx.formatExpression(value);
            let scopeExpr = `scope`;
            if (ctx.protectedScopeNumber) {
                ctx.rootContext.shouldDefineUtils = true;
                scopeExpr = `utils.getScope(scope, '${variable}')`;
            }
            ctx.addLine(`${scopeExpr}.${variable} = ${formattedValue};`);
            qwebvar.value = formattedValue;
        }
        if (hasBody) {
            ctx.rootContext.shouldDefineUtils = true;
            if (value) {
                ctx.addIf(`!(${qwebvar.expr})`);
            }
            const tempParentNodeID = ctx.generateID();
            const _parentNode = ctx.parentNode;
            ctx.parentNode = tempParentNodeID;
            ctx.addLine(`let c${tempParentNodeID} = new utils.VDomArray();`);
            const nodeCopy = node.cloneNode(true);
            for (let attr of ["t-set", "t-value", "t-if", "t-else", "t-elif"]) {
                nodeCopy.removeAttribute(attr);
            }
            qweb._compileNode(nodeCopy, ctx);
            ctx.addLine(`${qwebvar.expr} = c${tempParentNodeID}`);
            qwebvar.value = `c${tempParentNodeID}`;
            qwebvar.hasBody = true;
            ctx.parentNode = _parentNode;
            if (value) {
                ctx.closeIf();
            }
        }
        return true;
    }
});
//------------------------------------------------------------------------------
// t-if, t-elif, t-else
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "if",
    priority: 20,
    atNodeEncounter({ node, ctx }) {
        let cond = ctx.getValue(node.getAttribute("t-if"));
        ctx.addIf(typeof cond === "string" ? ctx.formatExpression(cond) : `scope.${cond.id}`);
        return false;
    },
    finalize({ ctx }) {
        ctx.closeIf();
    }
});
QWeb.addDirective({
    name: "elif",
    priority: 30,
    atNodeEncounter({ node, ctx }) {
        let cond = ctx.getValue(node.getAttribute("t-elif"));
        ctx.addLine(`else if (${typeof cond === "string" ? ctx.formatExpression(cond) : `scope.${cond.id}`}) {`);
        ctx.indent();
        return false;
    },
    finalize({ ctx }) {
        ctx.closeIf();
    }
});
QWeb.addDirective({
    name: "else",
    priority: 40,
    atNodeEncounter({ ctx }) {
        ctx.addLine(`else {`);
        ctx.indent();
        return false;
    },
    finalize({ ctx }) {
        ctx.closeIf();
    }
});
//------------------------------------------------------------------------------
// t-call
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "call",
    priority: 50,
    atNodeEncounter({ node, qweb, ctx }) {
        // Step 1: sanity checks
        // ------------------------------------------------
        ctx.rootContext.shouldDefineScope = true;
        ctx.rootContext.shouldDefineUtils = true;
        if (node.nodeName !== "t") {
            throw new Error("Invalid tag for t-call directive (should be 't')");
        }
        const subTemplate = node.getAttribute("t-call");
        const nodeTemplate = qweb.templates[subTemplate];
        if (!nodeTemplate) {
            throw new Error(`Cannot find template "${subTemplate}" (t-call)`);
        }
        // Step 2: compile target template in sub templates
        // ------------------------------------------------
        if (!qweb.subTemplates[subTemplate]) {
            qweb.subTemplates[subTemplate] = true;
            const subTemplateFn = qweb._compile(subTemplate, nodeTemplate.elem, ctx, true);
            qweb.subTemplates[subTemplate] = subTemplateFn;
        }
        // Step 3: compile t-call body if necessary
        // ------------------------------------------------
        let hasBody = node.hasChildNodes();
        let protectID;
        if (hasBody) {
            // we add a sub scope to protect the ambient scope
            ctx.addLine(`{`);
            ctx.indent();
            protectID = ctx.startProtectScope();
            const nodeCopy = node.cloneNode(true);
            for (let attr of ["t-if", "t-else", "t-elif", "t-call"]) {
                nodeCopy.removeAttribute(attr);
            }
            const parentNode = ctx.parentNode;
            ctx.parentNode = "__0";
            // this local scope is intended to trap c__0
            ctx.addLine(`{`);
            ctx.indent();
            ctx.addLine("let c__0 = [];");
            qweb._compileNode(nodeCopy, ctx);
            ctx.rootContext.shouldDefineUtils = true;
            ctx.addLine("scope[utils.zero] = c__0;");
            ctx.parentNode = parentNode;
            ctx.dedent();
            ctx.addLine(`}`);
        }
        // Step 4: add the appropriate function call to current component
        // ------------------------------------------------
        const callingScope = hasBody ? "scope" : "Object.assign(Object.create(context), scope)";
        const parentComponent = `utils.getComponent(context)`;
        const key = ctx.generateTemplateKey();
        const parentNode = ctx.parentNode ? `c${ctx.parentNode}` : "result";
        const extra = `Object.assign({}, extra, {parentNode: ${parentNode}, parent: ${parentComponent}, key: ${key}})`;
        if (ctx.parentNode) {
            ctx.addLine(`this.subTemplates['${subTemplate}'].call(this, ${callingScope}, ${extra});`);
        }
        else {
            // this is a t-call with no parentnode, we need to extract the result
            ctx.rootContext.shouldDefineResult = true;
            ctx.addLine(`result = []`);
            ctx.addLine(`this.subTemplates['${subTemplate}'].call(this, ${callingScope}, ${extra});`);
            ctx.addLine(`result = result[0]`);
        }
        // Step 5: restore previous scope
        // ------------------------------------------------
        if (hasBody) {
            ctx.stopProtectScope(protectID);
            ctx.dedent();
            ctx.addLine(`}`);
        }
        return true;
    }
});
//------------------------------------------------------------------------------
// t-foreach
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "foreach",
    extraNames: ["as"],
    priority: 10,
    atNodeEncounter({ node, qweb, ctx }) {
        ctx.rootContext.shouldDefineScope = true;
        ctx = ctx.subContext("loopNumber", ctx.loopNumber + 1);
        const elems = node.getAttribute("t-foreach");
        const name = node.getAttribute("t-as");
        let arrayID = ctx.generateID();
        ctx.addLine(`let _${arrayID} = ${ctx.formatExpression(elems)};`);
        ctx.addLine(`if (!_${arrayID}) { throw new Error('QWeb error: Invalid loop expression')}`);
        let keysID = ctx.generateID();
        let valuesID = ctx.generateID();
        ctx.addLine(`let _${keysID} = _${valuesID} = _${arrayID};`);
        ctx.addIf(`!(_${arrayID} instanceof Array)`);
        ctx.addLine(`_${keysID} = Object.keys(_${arrayID});`);
        ctx.addLine(`_${valuesID} = Object.values(_${arrayID});`);
        ctx.closeIf();
        ctx.addLine(`let _length${keysID} = _${keysID}.length;`);
        let varsID = ctx.startProtectScope(true);
        const loopVar = `i${ctx.loopNumber}`;
        ctx.addLine(`for (let ${loopVar} = 0; ${loopVar} < _length${keysID}; ${loopVar}++) {`);
        ctx.indent();
        ctx.addLine(`scope.${name}_first = ${loopVar} === 0`);
        ctx.addLine(`scope.${name}_last = ${loopVar} === _length${keysID} - 1`);
        ctx.addLine(`scope.${name}_index = ${loopVar}`);
        ctx.addLine(`scope.${name} = _${keysID}[${loopVar}]`);
        ctx.addLine(`scope.${name}_value = _${valuesID}[${loopVar}]`);
        const nodeCopy = node.cloneNode(true);
        let shouldWarn = !nodeCopy.hasAttribute("t-key") &&
            node.children.length === 1 &&
            node.children[0].tagName !== "t" &&
            !node.children[0].hasAttribute("t-key");
        if (shouldWarn) {
            console.warn(`Directive t-foreach should always be used with a t-key! (in template: '${ctx.templateName}')`);
        }
        if (nodeCopy.hasAttribute("t-key")) {
            const expr = ctx.formatExpression(nodeCopy.getAttribute("t-key"));
            ctx.addLine(`let key${ctx.loopNumber} = ${expr};`);
            nodeCopy.removeAttribute("t-key");
        }
        else {
            ctx.addLine(`let key${ctx.loopNumber} = i${ctx.loopNumber};`);
        }
        nodeCopy.removeAttribute("t-foreach");
        qweb._compileNode(nodeCopy, ctx);
        ctx.dedent();
        ctx.addLine("}");
        ctx.stopProtectScope(varsID);
        return true;
    }
});
//------------------------------------------------------------------------------
// t-debug
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "debug",
    priority: 1,
    atNodeEncounter({ ctx }) {
        ctx.addLine("debugger;");
    }
});
//------------------------------------------------------------------------------
// t-log
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "log",
    priority: 1,
    atNodeEncounter({ ctx, value }) {
        const expr = ctx.formatExpression(value);
        ctx.addLine(`console.log(${expr})`);
    }
});

/**
 * Owl QWeb Extensions
 *
 * This file contains the implementation of non standard QWeb directives, added
 * by Owl and that will only work on Owl projects:
 *
 * - t-on
 * - t-ref
 * - t-transition
 * - t-mounted
 * - t-slot
 * - t-model
 */
//------------------------------------------------------------------------------
// t-on
//------------------------------------------------------------------------------
// these are pieces of code that will be injected into the event handler if
// modifiers are specified
const MODS_CODE = {
    prevent: "e.preventDefault();",
    self: "if (e.target !== this.elm) {return}",
    stop: "e.stopPropagation();"
};
const FNAMEREGEXP = /^[$A-Z_][0-9A-Z_$]*$/i;
function makeHandlerCode(ctx, fullName, value, putInCache, modcodes = MODS_CODE) {
    let [event, ...mods] = fullName.slice(5).split(".");
    if (mods.includes("capture")) {
        event = "!" + event;
    }
    if (!event) {
        throw new Error("Missing event name with t-on directive");
    }
    let code;
    // check if it is a method with no args, a method with args or an expression
    let args = "";
    const name = value.replace(/\(.*\)/, function (_args) {
        args = _args.slice(1, -1);
        return "";
    });
    const isMethodCall = name.match(FNAMEREGEXP);
    // then generate code
    if (isMethodCall) {
        ctx.rootContext.shouldDefineUtils = true;
        const comp = `utils.getComponent(context)`;
        if (args) {
            const argId = ctx.generateID();
            ctx.addLine(`let args${argId} = [${ctx.formatExpression(args)}];`);
            code = `${comp}['${name}'](...args${argId}, e);`;
            putInCache = false;
        }
        else {
            code = `${comp}['${name}'](e);`;
        }
    }
    else {
        // if we get here, then it is an expression
        // we need to capture every variable in it
        putInCache = false;
        code = ctx.captureExpression(value);
    }
    const modCode = mods.map(mod => modcodes[mod]).join("");
    let handler = `function (e) {if (!context.__owl__.isMounted){return}${modCode}${code}}`;
    if (putInCache) {
        const key = ctx.generateTemplateKey(event);
        ctx.addLine(`extra.handlers[${key}] = extra.handlers[${key}] || ${handler};`);
        handler = `extra.handlers[${key}]`;
    }
    return { event, handler };
}
QWeb.addDirective({
    name: "on",
    priority: 90,
    atNodeCreation({ ctx, fullName, value, nodeID }) {
        const { event, handler } = makeHandlerCode(ctx, fullName, value, true);
        ctx.addLine(`p${nodeID}.on['${event}'] = ${handler};`);
    }
});
//------------------------------------------------------------------------------
// t-ref
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "ref",
    priority: 95,
    atNodeCreation({ ctx, value, addNodeHook }) {
        ctx.rootContext.shouldDefineRefs = true;
        const refKey = `ref${ctx.generateID()}`;
        ctx.addLine(`const ${refKey} = ${ctx.interpolate(value)};`);
        addNodeHook("create", `context.__owl__.refs[${refKey}] = n.elm;`);
        addNodeHook("destroy", `delete context.__owl__.refs[${refKey}];`);
    }
});
//------------------------------------------------------------------------------
// t-transition
//------------------------------------------------------------------------------
QWeb.utils.nextFrame = function (cb) {
    requestAnimationFrame(() => requestAnimationFrame(cb));
};
QWeb.utils.transitionInsert = function (vn, name) {
    const elm = vn.elm;
    // remove potential duplicated vnode that is currently being removed, to
    // prevent from having twice the same node in the DOM during an animation
    const dup = elm.parentElement && elm.parentElement.querySelector(`*[data-owl-key='${vn.key}']`);
    if (dup) {
        dup.remove();
    }
    elm.classList.add(name + "-enter");
    elm.classList.add(name + "-enter-active");
    elm.classList.remove(name + "-leave-active");
    elm.classList.remove(name + "-leave-to");
    const finalize = () => {
        elm.classList.remove(name + "-enter-active");
        elm.classList.remove(name + "-enter-to");
    };
    this.nextFrame(() => {
        elm.classList.remove(name + "-enter");
        elm.classList.add(name + "-enter-to");
        whenTransitionEnd(elm, finalize);
    });
};
QWeb.utils.transitionRemove = function (vn, name, rm) {
    const elm = vn.elm;
    elm.setAttribute("data-owl-key", vn.key);
    elm.classList.add(name + "-leave");
    elm.classList.add(name + "-leave-active");
    const finalize = () => {
        if (!elm.classList.contains(name + "-leave-active")) {
            return;
        }
        elm.classList.remove(name + "-leave-active");
        elm.classList.remove(name + "-leave-to");
        rm();
    };
    this.nextFrame(() => {
        elm.classList.remove(name + "-leave");
        elm.classList.add(name + "-leave-to");
        whenTransitionEnd(elm, finalize);
    });
};
function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map((d, i) => {
        return toMs(d) + toMs(delays[i]);
    }));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1000;
}
function whenTransitionEnd(elm, cb) {
    if (!elm.parentNode) {
        // if we get here, this means that the element was removed for some other
        // reasons, and in that case, we don't want to work on animation since nothing
        // will be displayed anyway.
        return;
    }
    const styles = window.getComputedStyle(elm);
    const delays = (styles.transitionDelay || "").split(", ");
    const durations = (styles.transitionDuration || "").split(", ");
    const timeout = getTimeout(delays, durations);
    if (timeout > 0) {
        elm.addEventListener("transitionend", cb, { once: true });
    }
    else {
        cb();
    }
}
QWeb.addDirective({
    name: "transition",
    priority: 96,
    atNodeCreation({ ctx, value, addNodeHook }) {
        ctx.rootContext.shouldDefineUtils = true;
        let name = value;
        const hooks = {
            insert: `utils.transitionInsert(vn, '${name}');`,
            remove: `utils.transitionRemove(vn, '${name}', rm);`
        };
        for (let hookName in hooks) {
            addNodeHook(hookName, hooks[hookName]);
        }
    }
});
//------------------------------------------------------------------------------
// t-slot
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "slot",
    priority: 80,
    atNodeEncounter({ ctx, value, node, qweb }) {
        const slotKey = ctx.generateID();
        ctx.addLine(`const slot${slotKey} = this.constructor.slots[context.__owl__.slotId + '_' + '${value}'];`);
        ctx.addIf(`slot${slotKey}`);
        let parentNode = `c${ctx.parentNode}`;
        if (!ctx.parentNode) {
            ctx.rootContext.shouldDefineResult = true;
            ctx.rootContext.shouldDefineUtils = true;
            parentNode = `children${ctx.generateID()}`;
            ctx.addLine(`let ${parentNode}= []`);
            ctx.addLine(`result = {}`);
        }
        ctx.addLine(`slot${slotKey}.call(this, context.__owl__.scope, Object.assign({}, extra, {parentNode: ${parentNode}, parent: extra.parent || context}));`);
        if (!ctx.parentNode) {
            ctx.addLine(`utils.defineProxy(result, ${parentNode}[0]);`);
        }
        if (node.hasChildNodes()) {
            ctx.addElse();
            const nodeCopy = node.cloneNode(true);
            nodeCopy.removeAttribute("t-slot");
            qweb._compileNode(nodeCopy, ctx);
        }
        ctx.closeIf();
        return true;
    }
});
//------------------------------------------------------------------------------
// t-model
//------------------------------------------------------------------------------
QWeb.utils.toNumber = function (val) {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
QWeb.addDirective({
    name: "model",
    priority: 42,
    atNodeCreation({ ctx, nodeID, value, node, fullName, addNodeHook }) {
        const type = node.getAttribute("type");
        let handler;
        let event = fullName.includes(".lazy") ? "change" : "input";
        // we keep here a reference to the "base expression" (if the expression
        // is `t-model="some.expr.value", then the base expression is "some.expr").
        // This is necessary so we can capture it in the handler closure.
        let expr = ctx.formatExpression(value);
        const index = expr.lastIndexOf(".");
        const baseExpr = expr.slice(0, index);
        ctx.addLine(`let expr${nodeID} = ${baseExpr};`);
        expr = `expr${nodeID}.${expr.slice(index + 1)}`;
        const key = ctx.generateTemplateKey();
        if (node.tagName === "select") {
            ctx.addLine(`p${nodeID}.props = {value: ${expr}};`);
            addNodeHook("create", `n.elm.value=${expr};`);
            event = "change";
            handler = `(ev) => {${expr} = ev.target.value}`;
        }
        else if (type === "checkbox") {
            ctx.addLine(`p${nodeID}.props = {checked: ${expr}};`);
            handler = `(ev) => {${expr} = ev.target.checked}`;
        }
        else if (type === "radio") {
            const nodeValue = node.getAttribute("value");
            ctx.addLine(`p${nodeID}.props = {checked:${expr} === '${nodeValue}'};`);
            handler = `(ev) => {${expr} = ev.target.value}`;
            event = "click";
        }
        else {
            ctx.addLine(`p${nodeID}.props = {value: ${expr}};`);
            const trimCode = fullName.includes(".trim") ? ".trim()" : "";
            let valueCode = `ev.target.value${trimCode}`;
            if (fullName.includes(".number")) {
                ctx.rootContext.shouldDefineUtils = true;
                valueCode = `utils.toNumber(${valueCode})`;
            }
            handler = `(ev) => {${expr} = ${valueCode}}`;
        }
        ctx.addLine(`extra.handlers[${key}] = extra.handlers[${key}] || (${handler});`);
        ctx.addLine(`p${nodeID}.on['${event}'] = extra.handlers[${key}];`);
    }
});
//------------------------------------------------------------------------------
// t-key
//------------------------------------------------------------------------------
QWeb.addDirective({
    name: "key",
    priority: 45,
    atNodeEncounter({ ctx, value, node }) {
        if (ctx.loopNumber === 0) {
            ctx.keyStack.push(ctx.rootContext.hasKey0);
            ctx.rootContext.hasKey0 = true;
        }
        ctx.addLine("{");
        ctx.indent();
        ctx.addLine(`let key${ctx.loopNumber} = ${ctx.formatExpression(value)};`);
    },
    finalize({ ctx }) {
        ctx.dedent();
        ctx.addLine("}");
        if (ctx.loopNumber === 0) {
            ctx.rootContext.hasKey0 = ctx.keyStack.pop();
        }
    }
});

const config = {};
Object.defineProperty(config, "mode", {
    get() {
        return QWeb.dev ? "dev" : "prod";
    },
    set(mode) {
        QWeb.dev = mode === "dev";
        if (QWeb.dev) {
            const url = `https://github.com/odoo/owl/blob/master/doc/reference/config.md#mode`;
            console.warn(`Owl is running in 'dev' mode.  This is not suitable for production use. See ${url} for more information.`);
        }
        else {
            console.log(`Owl is now running in 'prod' mode.`);
        }
    }
});

/**
 * We define here OwlEvent, a subclass of CustomEvent, with an additional
 * attribute:
 *  - originalComponent: the component that triggered the event
 */
class OwlEvent extends CustomEvent {
    constructor(component, eventType, options) {
        super(eventType, options);
        this.originalComponent = component;
    }
}

//------------------------------------------------------------------------------
// t-component
//------------------------------------------------------------------------------
const T_COMPONENT_MODS_CODE = Object.assign({}, MODS_CODE, {
    self: "if (e.target !== vn.elm) {return}"
});
QWeb.utils.defineProxy = function defineProxy(target, source) {
    for (let k in source) {
        Object.defineProperty(target, k, {
            get() {
                return source[k];
            },
            set(val) {
                source[k] = val;
            }
        });
    }
};
QWeb.utils.assignHooks = function assignHooks(dataObj, hooks) {
    if ("hook" in dataObj) {
        const hookObject = dataObj.hook;
        for (let name in hooks) {
            const current = hookObject[name];
            const fn = hooks[name];
            if (current) {
                hookObject[name] = (...args) => {
                    current(...args);
                    fn(...args);
                };
            }
            else {
                hookObject[name] = fn;
            }
        }
    }
    else {
        dataObj.hook = hooks;
    }
};
/**
 * The t-component directive is certainly a complicated and hard to maintain piece
 * of code.  To help you, fellow developer, if you have to maintain it, I offer
 * you this advice: Good luck...
 *
 * Since it is not 'direct' code, but rather code that generates other code, it
 * is not easy to understand.  To help you, here  is a detailed and commented
 * explanation of the code generated by the t-component directive for the following
 * situation:
 * ```xml
 *   <Child
 *      t-key="'somestring'"
 *      flag="state.flag"
 *      t-transition="fade"/>
 * ```
 *
 * ```js
 * // we assign utils on top of the function because it will be useful for
 * // each components
 * let utils = this.utils;
 *
 * // this is the virtual node representing the parent div
 * let c1 = [], p1 = { key: 1 };
 * var vn1 = h("div", p1, c1);
 *
 * // t-component directive: we start by evaluating the expression given by t-key:
 * let key5 = "somestring";
 *
 * // def3 is the promise that will contain later either the new component
 * // creation, or the props update...
 * let def3;
 *
 * // this is kind of tricky: we need here to find if the component was already
 * // created by a previous rendering.  This is done by checking the internal
 * // `cmap` (children map) of the parent component: it maps keys to component ids,
 * // and, then, if there is an id, we look into the children list to get the
 * // instance
 * let w4 =
 *   key5 in context.__owl__.cmap
 *   ? context.__owl__.children[context.__owl__.cmap[key5]]
 *   : false;
 *
 * // We keep the index of the position of the component in the closure.  We push
 * // null to reserve the slot, and will replace it later by the component vnode,
 * // when it will be ready (do not forget that preparing/rendering a component is
 * // asynchronous)
 * let _2_index = c1.length;
 * c1.push(null);
 *
 * // we evaluate here the props given to the component. It is done here to be
 * // able to easily reference it later, and also, it might be an expensive
 * // computation, so it is certainly better to do it only once
 * let props4 = { flag: context["state"].flag };
 *
 * // If we have a component, currently rendering, but not ready yet, we do not want
 * // to wait for it to be ready if we can avoid it
 * if (w4 && w4.__owl__.renderPromise && !w4.__owl__.vnode) {
 *   // we check if the props are the same.  In that case, we can simply reuse
 *   // the previous rendering and skip all useless work
 *   if (utils.shallowEqual(props4, w4.__owl__.renderProps)) {
 *     def3 = w4.__owl__.renderPromise;
 *   } else {
 *     // if the props are not the same, we destroy the component and starts anew.
 *     // this will be faster than waiting for its rendering, then updating it
 *     w4.destroy();
 *     w4 = false;
 *   }
 * }
 *
 * if (!w4) {
 *   // in this situation, we need to create a new component.  First step is
 *   // to get a reference to the class, then create an instance with
 *   // current context as parent, and the props.
 *   let W4 = context.component && context.components[componentKey4] || QWeb.component[componentKey4];

 *   if (!W4) {
 *     throw new Error("Cannot find the definition of component 'child'");
 *   }
 *   w4 = new W4(owner, props4);
 *
 *   // Whenever we rerender the parent component, we need to be sure that we
 *   // are able to find the component instance. To do that, we register it to
 *   // the parent cmap (children map).  Note that the 'template' key is
 *   // used here, since this is what identify the component from the template
 *   // perspective.
 *   context.__owl__.cmap[key5] = w4.__owl__.id;
 *
 *   // __prepare is called, to basically call willStart, then render the
 *   // component
 *   def3 = w4.__prepare();
 *
 *   def3 = def3.then(vnode => {
 *     // we create here a virtual node for the parent (NOT the component). This
 *     // means that the vdom of the parent will be stopped here, and from
 *     // the parent's perspective, it simply is a vnode with no children.
 *     // However, it shares the same dom element with the component root
 *     // vnode.
 *     let pvnode = h(vnode.sel, { key: key5 });
 *
 *     // we add hooks to the parent vnode so we can interact with the new
 *     // component at the proper time
 *     pvnode.data.hook = {
 *       insert(vn) {
 *         // the __mount method will patch the component vdom into the elm vn.elm,
 *         // then call the mounted hooks. However, suprisingly, the snabbdom
 *         // patch method actually replace the elm by a new elm, so we need
 *         // to synchronise the pvnode elm with the resulting elm
 *         let nvn = w4.__mount(vnode, vn.elm);
 *         pvnode.elm = nvn.elm;
 *         // what follows is only present if there are animations on the component
 *         utils.transitionInsert(vn, "fade");
 *       },
 *       remove() {
 *         // override with empty function to prevent from removing the node
 *         // directly. It will be removed when destroy is called anyway, which
 *         // delays the removal if there are animations.
 *       },
 *       destroy() {
 *         // if there are animations, we delay the call to destroy on the
 *         // component, if not, we call it directly.
 *         let finalize = () => {
 *           w4.destroy();
 *         };
 *         utils.transitionRemove(vn, "fade", finalize);
 *       }
 *     };
 *     // the pvnode is inserted at the correct position in the div's children
 *     c1[_2_index] = pvnode;
 *
 *     // we keep here a reference to the parent vnode (representing the
 *     // component, so we can reuse it later whenever we update the component
 *     w4.__owl__.pvnode = pvnode;
 *   });
 * } else {
 *   // this is the 'update' path of the directive.
 *   // the call to __updateProps is the actual component update
 *   // Note that we only update the props if we cannot reuse the previous
 *   // rendering work (in the case it was rendered with the same props)
 *   def3 = def3 || w4.__updateProps(props4, extra.forceUpdate, extra.patchQueue);
 *   def3 = def3.then(() => {
 *     // if component was destroyed in the meantime, we do nothing (so, this
 *     // means that the parent's element children list will have a null in
 *     // the component's position, which will cause the pvnode to be removed
 *     // when it is patched.
 *     if (w4.__owl__.isDestroyed) {
 *       return;
 *     }
 *     // like above, we register the pvnode to the children list, so it
 *     // will not be patched out of the dom.
 *     let pvnode = w4.__owl__.pvnode;
 *     c1[_2_index] = pvnode;
 *   });
 * }
 *
 * // we register the deferred here so the parent can coordinate its patch operation
 * // with all the children.
 * extra.promises.push(def3);
 * return vn1;
 * ```
 */
QWeb.addDirective({
    name: "component",
    extraNames: ["props"],
    priority: 100,
    atNodeEncounter({ ctx, value, node, qweb }) {
        ctx.addLine(`// Component '${value}'`);
        ctx.rootContext.shouldDefineQWeb = true;
        ctx.rootContext.shouldDefineParent = true;
        ctx.rootContext.shouldDefineUtils = true;
        ctx.rootContext.shouldDefineScope = true;
        let hasDynamicProps = node.getAttribute("t-props") ? true : false;
        // t-on- events and t-transition
        const events = [];
        let transition = "";
        const attributes = node.attributes;
        const props = {};
        for (let i = 0; i < attributes.length; i++) {
            const name = attributes[i].name;
            const value = attributes[i].textContent;
            if (name.startsWith("t-on-")) {
                events.push([name, value]);
            }
            else if (name === "t-transition") {
                transition = value;
            }
            else if (!name.startsWith("t-")) {
                if (name !== "class" && name !== "style") {
                    // this is a prop!
                    props[name] = ctx.formatExpression(value) || "undefined";
                }
            }
        }
        // computing the props string representing the props object
        let propStr = Object.keys(props)
            .map(k => k + ":" + props[k])
            .join(",");
        let componentID = ctx.generateID();
        const templateKey = ctx.generateTemplateKey();
        let ref = node.getAttribute("t-ref");
        let refExpr = "";
        let refKey = "";
        if (ref) {
            ctx.rootContext.shouldDefineRefs = true;
            refKey = `ref${ctx.generateID()}`;
            ctx.addLine(`const ${refKey} = ${ctx.interpolate(ref)};`);
            refExpr = `context.__owl__.refs[${refKey}] = w${componentID};`;
        }
        let finalizeComponentCode = `w${componentID}.destroy();`;
        if (ref) {
            finalizeComponentCode += `delete context.__owl__.refs[${refKey}];`;
        }
        if (transition) {
            finalizeComponentCode = `let finalize = () => {
          ${finalizeComponentCode}
        };
        delete w${componentID}.__owl__.transitionInserted;
        utils.transitionRemove(vn, '${transition}', finalize);`;
        }
        let createHook = "";
        let classAttr = node.getAttribute("class");
        let tattClass = node.getAttribute("t-att-class");
        let styleAttr = node.getAttribute("style");
        let tattStyle = node.getAttribute("t-att-style");
        if (tattStyle) {
            const attVar = `_${ctx.generateID()}`;
            ctx.addLine(`const ${attVar} = ${ctx.formatExpression(tattStyle)};`);
            tattStyle = attVar;
        }
        let classObj = "";
        if (classAttr || tattClass || styleAttr || tattStyle || events.length) {
            if (classAttr) {
                let classDef = classAttr
                    .trim()
                    .split(/\s+/)
                    .map(a => `'${a}':true`)
                    .join(",");
                classObj = `_${ctx.generateID()}`;
                ctx.addLine(`let ${classObj} = {${classDef}};`);
            }
            if (tattClass) {
                let tattExpr = ctx.formatExpression(tattClass);
                if (tattExpr[0] !== "{" || tattExpr[tattExpr.length - 1] !== "}") {
                    tattExpr = `utils.toObj(${tattExpr})`;
                }
                if (classAttr) {
                    ctx.addLine(`Object.assign(${classObj}, ${tattExpr})`);
                }
                else {
                    classObj = `_${ctx.generateID()}`;
                    ctx.addLine(`let ${classObj} = ${tattExpr};`);
                }
            }
            let eventsCode = events
                .map(function ([name, value]) {
                const capture = name.match(/\.capture/);
                name = capture ? name.replace(/\.capture/, "") : name;
                const { event, handler } = makeHandlerCode(ctx, name, value, false, T_COMPONENT_MODS_CODE);
                if (capture) {
                    return `vn.elm.addEventListener('${event}', ${handler}, true);`;
                }
                return `vn.elm.addEventListener('${event}', ${handler});`;
            })
                .join("");
            const styleExpr = tattStyle || (styleAttr ? `'${styleAttr}'` : false);
            const styleCode = styleExpr ? `vn.elm.style = ${styleExpr};` : "";
            createHook = `utils.assignHooks(vnode.data, {create(_, vn){${styleCode}${eventsCode}}});`;
        }
        ctx.addLine(`let w${componentID} = ${templateKey} in parent.__owl__.cmap ? parent.__owl__.children[parent.__owl__.cmap[${templateKey}]] : false;`);
        let shouldProxy = !ctx.parentNode;
        if (shouldProxy) {
            let id = ctx.generateID();
            ctx.rootContext.rootNode = id;
            shouldProxy = true;
            ctx.rootContext.shouldDefineResult = true;
            ctx.addLine(`let vn${id} = {};`);
            ctx.addLine(`result = vn${id};`);
        }
        if (hasDynamicProps) {
            const dynamicProp = ctx.formatExpression(node.getAttribute("t-props"));
            ctx.addLine(`let props${componentID} = Object.assign({${propStr}}, ${dynamicProp});`);
        }
        else {
            ctx.addLine(`let props${componentID} = {${propStr}};`);
        }
        ctx.addIf(`w${componentID} && w${componentID}.__owl__.currentFiber && !w${componentID}.__owl__.vnode`);
        ctx.addLine(`w${componentID}.destroy();`);
        ctx.addLine(`w${componentID} = false;`);
        ctx.closeIf();
        let registerCode = "";
        if (shouldProxy) {
            registerCode = `utils.defineProxy(vn${ctx.rootNode}, pvnode);`;
        }
        // SLOTS
        const hasSlots = node.childNodes.length;
        let scope = hasSlots ? `Object.assign(Object.create(context), scope)` : "undefined";
        ctx.addIf(`w${componentID}`);
        // need to update component
        let styleCode = "";
        if (tattStyle) {
            styleCode = `.then(()=>{if (w${componentID}.__owl__.isDestroyed) {return};w${componentID}.el.style=${tattStyle};});`;
        }
        ctx.addLine(`w${componentID}.__updateProps(props${componentID}, extra.fiber, ${scope})${styleCode};`);
        ctx.addLine(`let pvnode = w${componentID}.__owl__.pvnode;`);
        if (registerCode) {
            ctx.addLine(registerCode);
        }
        if (ctx.parentNode) {
            ctx.addLine(`c${ctx.parentNode}.push(pvnode);`);
        }
        ctx.addElse();
        // new component
        let dynamicFallback = "";
        if (!value.match(INTERP_REGEXP)) {
            dynamicFallback = `|| ${ctx.formatExpression(value)}`;
        }
        const interpValue = ctx.interpolate(value);
        ctx.addLine(`let componentKey${componentID} = ${interpValue};`);
        ctx.addLine(`let W${componentID} = context.constructor.components[componentKey${componentID}] || QWeb.components[componentKey${componentID}]${dynamicFallback};`);
        // maybe only do this in dev mode...
        ctx.addLine(`if (!W${componentID}) {throw new Error('Cannot find the definition of component "' + componentKey${componentID} + '"')}`);
        ctx.addLine(`w${componentID} = new W${componentID}(parent, props${componentID});`);
        if (transition) {
            ctx.addLine(`const __patch${componentID} = w${componentID}.__patch;`);
            ctx.addLine(`w${componentID}.__patch = (t, vn) => {__patch${componentID}.call(w${componentID}, t, vn); if(!w${componentID}.__owl__.transitionInserted){w${componentID}.__owl__.transitionInserted = true;utils.transitionInsert(w${componentID}.__owl__.vnode, '${transition}');}};`);
        }
        ctx.addLine(`parent.__owl__.cmap[${templateKey}] = w${componentID}.__owl__.id;`);
        if (hasSlots) {
            const clone = node.cloneNode(true);
            const slotNodes = Array.from(clone.querySelectorAll("[t-set-slot]"));
            // The next code is a fallback for compatibility reason. It accepts t-set
            // elements that are direct children with a non empty body as nodes defining
            // the content of a slot.
            //
            // This is wrong, but is necessary to prevent breaking all existing Owl
            // code using slots. This will be removed in v2.0 someday. Meanwhile,
            // please use t-set-slot everywhere you need to set the content of a
            // slot.
            for (let el of clone.children) {
                if (el.getAttribute("t-set") && el.hasChildNodes()) {
                    slotNodes.push(el);
                }
            }
            const slotId = QWeb.nextSlotId++;
            ctx.addLine(`w${componentID}.__owl__.slotId = ${slotId};`);
            if (slotNodes.length) {
                for (let i = 0, length = slotNodes.length; i < length; i++) {
                    const slotNode = slotNodes[i];
                    slotNode.parentElement.removeChild(slotNode);
                    let key = slotNode.getAttribute("t-set-slot");
                    slotNode.removeAttribute("t-set-slot");
                    // here again, this code should be removed when we stop supporting
                    // using t-set to define the content of named slots.
                    if (!key) {
                        key = slotNode.getAttribute("t-set");
                        slotNode.removeAttribute("t-set");
                    }
                    const slotFn = qweb._compile(`slot_${key}_template`, slotNode, ctx);
                    QWeb.slots[`${slotId}_${key}`] = slotFn;
                }
            }
            if (clone.childNodes.length) {
                const t = clone.ownerDocument.createElement("t");
                for (let child of Object.values(clone.childNodes)) {
                    t.appendChild(child);
                }
                const slotFn = qweb._compile(`slot_default_template`, t, ctx);
                QWeb.slots[`${slotId}_default`] = slotFn;
            }
        }
        ctx.addLine(`let fiber = w${componentID}.__prepare(extra.fiber, ${scope}, () => { const vnode = fiber.vnode; pvnode.sel = vnode.sel; ${createHook}});`);
        // hack: specify empty remove hook to prevent the node from being removed from the DOM
        const insertHook = refExpr ? `insert(vn) {${refExpr}},` : "";
        ctx.addLine(`let pvnode = h('dummy', {key: ${templateKey}, hook: {${insertHook}remove() {},destroy(vn) {${finalizeComponentCode}}}});`);
        if (registerCode) {
            ctx.addLine(registerCode);
        }
        if (ctx.parentNode) {
            ctx.addLine(`c${ctx.parentNode}.push(pvnode);`);
        }
        ctx.addLine(`w${componentID}.__owl__.pvnode = pvnode;`);
        ctx.closeIf();
        if (classObj) {
            ctx.addLine(`w${componentID}.__owl__.classObj=${classObj};`);
        }
        ctx.addLine(`w${componentID}.__owl__.parentLastFiberId = extra.fiber.id;`);
        return true;
    }
});

class Scheduler {
    constructor(requestAnimationFrame) {
        this.tasks = [];
        this.isRunning = false;
        this.requestAnimationFrame = requestAnimationFrame;
    }
    start() {
        this.isRunning = true;
        this.scheduleTasks();
    }
    stop() {
        this.isRunning = false;
    }
    addFiber(fiber) {
        // if the fiber was remapped into a larger rendering fiber, it may not be a
        // root fiber.  But we only want to register root fibers
        fiber = fiber.root;
        return new Promise((resolve, reject) => {
            if (fiber.error) {
                return reject(fiber.error);
            }
            this.tasks.push({
                fiber,
                callback: () => {
                    if (fiber.error) {
                        return reject(fiber.error);
                    }
                    resolve();
                }
            });
            if (!this.isRunning) {
                this.start();
            }
        });
    }
    rejectFiber(fiber, reason) {
        fiber = fiber.root;
        const index = this.tasks.findIndex(t => t.fiber === fiber);
        if (index >= 0) {
            const [task] = this.tasks.splice(index, 1);
            fiber.cancel();
            fiber.error = new Error(reason);
            task.callback();
        }
    }
    /**
     * Process all current tasks. This only applies to the fibers that are ready.
     * Other tasks are left unchanged.
     */
    flush() {
        let tasks = this.tasks;
        this.tasks = [];
        tasks = tasks.filter(task => {
            if (task.fiber.isCompleted) {
                task.callback();
                return false;
            }
            if (task.fiber.counter === 0) {
                if (!task.fiber.error) {
                    try {
                        task.fiber.complete();
                    }
                    catch (e) {
                        task.fiber.handleError(e);
                    }
                }
                task.callback();
                return false;
            }
            return true;
        });
        this.tasks = tasks.concat(this.tasks);
        if (this.tasks.length === 0) {
            this.stop();
        }
    }
    scheduleTasks() {
        this.requestAnimationFrame(() => {
            this.flush();
            if (this.isRunning) {
                this.scheduleTasks();
            }
        });
    }
}
const scheduler = new Scheduler(browser.requestAnimationFrame);

/**
 * Owl Fiber Class
 *
 * Fibers are small abstractions designed to contain all the internal state
 * associated with a "rendering work unit", relative to a specific component.
 *
 * A rendering will cause the creation of a fiber for each impacted components.
 *
 * Fibers capture all that necessary information, which is critical to owl
 * asynchronous rendering pipeline. Fibers can be cancelled, can be in different
 * states and in general determine the state of the rendering.
 */
class Fiber {
    constructor(parent, component, force, target, position) {
        this.id = Fiber.nextId++;
        // isCompleted means that the rendering corresponding to this fiber's work is
        // done, either because the component has been mounted or patched, or because
        // fiber has been cancelled.
        this.isCompleted = false;
        // the fibers corresponding to component updates (updateProps) need to call
        // the willPatch and patched hooks from the corresponding component. However,
        // fibers corresponding to a new component do not need to do that. So, the
        // shouldPatch hook is the boolean that we check whenever we need to apply
        // a patch.
        this.shouldPatch = true;
        // isRendered is the last state of a fiber. If true, this means that it has
        // been rendered and is inert (so, it should not be taken into account when
        // counting the number of active fibers).
        this.isRendered = false;
        // the counter number is a critical information. It is only necessary for a
        // root fiber.  For that fiber, this number counts the number of active sub
        // fibers.  When that number reaches 0, the fiber can be applied by the
        // scheduler.
        this.counter = 0;
        this.vnode = null;
        this.child = null;
        this.sibling = null;
        this.lastChild = null;
        this.parent = null;
        this.component = component;
        this.force = force;
        this.target = target;
        this.position = position;
        const __owl__ = component.__owl__;
        this.scope = __owl__.scope;
        this.root = parent ? parent.root : this;
        this.parent = parent;
        let oldFiber = __owl__.currentFiber;
        if (oldFiber && !oldFiber.isCompleted) {
            if (oldFiber.root === oldFiber && !parent) {
                // both oldFiber and this fiber are root fibers
                this._reuseFiber(oldFiber);
                return oldFiber;
            }
            else {
                this._remapFiber(oldFiber);
            }
        }
        this.root.counter++;
        __owl__.currentFiber = this;
    }
    /**
     * When the oldFiber is not completed yet, and both oldFiber and this fiber
     * are root fibers, we want to reuse the oldFiber instead of creating a new
     * one. Doing so will guarantee that the initiator(s) of those renderings will
     * be notified (the promise will resolve) when the last rendering will be done.
     *
     * This function thus assumes that oldFiber is a root fiber.
     */
    _reuseFiber(oldFiber) {
        oldFiber.cancel(); // cancel children fibers
        oldFiber.isCompleted = false; // keep the root fiber alive
        oldFiber.isRendered = false; // the fiber has to be re-rendered
        if (oldFiber.child) {
            // remove relation to children
            oldFiber.child.parent = null;
            oldFiber.child = null;
            oldFiber.lastChild = null;
        }
        oldFiber.counter = 1; // re-initialize counter
        oldFiber.id = Fiber.nextId++;
    }
    /**
     * In some cases, a rendering initiated at some component can detect that it
     * should be part of a larger rendering initiated somewhere up the component
     * tree.  In that case, it needs to cancel the previous rendering and
     * remap itself as a part of the current parent rendering.
     */
    _remapFiber(oldFiber) {
        oldFiber.cancel();
        this.shouldPatch = oldFiber.shouldPatch;
        if (oldFiber === oldFiber.root) {
            oldFiber.counter++;
        }
        if (oldFiber.parent && !this.parent) {
            // re-map links
            this.parent = oldFiber.parent;
            this.root = this.parent.root;
            this.sibling = oldFiber.sibling;
            if (this.parent.lastChild === oldFiber) {
                this.parent.lastChild = this;
            }
            if (this.parent.child === oldFiber) {
                this.parent.child = this;
            }
            else {
                let current = this.parent.child;
                while (true) {
                    if (current.sibling === oldFiber) {
                        current.sibling = this;
                        break;
                    }
                    current = current.sibling;
                }
            }
        }
    }
    /**
     * This function has been taken from
     * https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7
     */
    _walk(doWork) {
        let root = this;
        let current = this;
        while (true) {
            const child = doWork(current);
            if (child) {
                current = child;
                continue;
            }
            if (current === root) {
                return;
            }
            while (!current.sibling) {
                if (!current.parent || current.parent === root) {
                    return;
                }
                current = current.parent;
            }
            current = current.sibling;
        }
    }
    /**
     * Successfully complete the work of the fiber: call the mount or patch hooks
     * and patch the DOM. This function is called once the fiber and its children
     * are ready, and the scheduler decides to process it.
     */
    complete() {
        let component = this.component;
        this.isCompleted = true;
        if (!this.target && !component.__owl__.isMounted) {
            return;
        }
        // build patchQueue
        const patchQueue = [];
        const doWork = function (f) {
            patchQueue.push(f);
            return f.child;
        };
        this._walk(doWork);
        const patchLen = patchQueue.length;
        // call willPatch hook on each fiber of patchQueue
        for (let i = 0; i < patchLen; i++) {
            const fiber = patchQueue[i];
            if (fiber.shouldPatch) {
                component = fiber.component;
                if (component.__owl__.willPatchCB) {
                    component.__owl__.willPatchCB();
                }
                component.willPatch();
            }
        }
        // call __patch on each fiber of (reversed) patchQueue
        for (let i = patchLen - 1; i >= 0; i--) {
            const fiber = patchQueue[i];
            component = fiber.component;
            if (fiber.target && i === 0) {
                let target;
                if (fiber.position === "self") {
                    target = fiber.target;
                    if (target.tagName.toLowerCase() !== fiber.vnode.sel) {
                        throw new Error(`Cannot attach '${component.constructor.name}' to target node (not same tag name)`);
                    }
                    // In self mode, we *know* we are to take possession of the target
                    // Hence we manually create the corresponding VNode and copy the "key" in data
                    const selfVnodeData = fiber.vnode.data ? { key: fiber.vnode.data.key } : {};
                    const selfVnode = h(fiber.vnode.sel, selfVnodeData);
                    selfVnode.elm = target;
                    target = selfVnode;
                }
                else {
                    target = component.__owl__.vnode || document.createElement(fiber.vnode.sel);
                }
                component.__patch(target, fiber.vnode);
            }
            else {
                if (fiber.shouldPatch) {
                    component.__patch(component.__owl__.vnode, fiber.vnode);
                }
                else {
                    component.__patch(document.createElement(fiber.vnode.sel), fiber.vnode);
                    component.__owl__.pvnode.elm = component.__owl__.vnode.elm;
                }
            }
            component.__owl__.currentFiber = null;
        }
        // insert into the DOM (mount case)
        let inDOM = false;
        if (this.target) {
            switch (this.position) {
                case "first-child":
                    this.target.prepend(this.component.el);
                    break;
                case "last-child":
                    this.target.appendChild(this.component.el);
                    break;
            }
            inDOM = document.body.contains(this.component.el);
            this.component.env.qweb.trigger("dom-appended");
        }
        // call patched/mounted hook on each fiber of (reversed) patchQueue
        for (let i = patchLen - 1; i >= 0; i--) {
            const fiber = patchQueue[i];
            component = fiber.component;
            if (fiber.shouldPatch && !this.target) {
                component.patched();
                if (component.__owl__.patchedCB) {
                    component.__owl__.patchedCB();
                }
            }
            else if (this.target ? inDOM : true) {
                component.__callMounted();
            }
        }
    }
    /**
     * Cancel a fiber and all its children.
     */
    cancel() {
        this._walk(f => {
            if (!f.isRendered) {
                f.root.counter--;
            }
            f.isCompleted = true;
            return f.child;
        });
    }
    /**
     * This is the global error handler for errors occurring in Owl main lifecycle
     * methods.  Caught errors are triggered on the QWeb instance, and are
     * potentially given to some parent component which implements `catchError`.
     *
     * If there are no such component, we destroy everything. This is better than
     * being in a corrupted state.
     */
    handleError(error) {
        let component = this.component;
        this.vnode = component.__owl__.vnode || h("div");
        const qweb = component.env.qweb;
        let root = component;
        let canCatch = false;
        while (component && !(canCatch = !!component.catchError)) {
            root = component;
            component = component.__owl__.parent;
        }
        qweb.trigger("error", error);
        if (canCatch) {
            component.catchError(error);
        }
        else {
            // the 3 next lines aim to mark the root fiber as being in error, and
            // to force it to end, without waiting for its children
            this.root.counter = 0;
            this.root.error = error;
            scheduler.flush();
            root.destroy();
        }
    }
}
Fiber.nextId = 1;

//------------------------------------------------------------------------------
// Prop validation helper
//------------------------------------------------------------------------------
/**
 * Validate the component props (or next props) against the (static) props
 * description.  This is potentially an expensive operation: it may needs to
 * visit recursively the props and all the children to check if they are valid.
 * This is why it is only done in 'dev' mode.
 */
QWeb.utils.validateProps = function (Widget, props) {
    const propsDef = Widget.props;
    if (propsDef instanceof Array) {
        // list of strings (prop names)
        for (let i = 0, l = propsDef.length; i < l; i++) {
            const propName = propsDef[i];
            if (propName[propName.length - 1] === "?") {
                // optional prop
                break;
            }
            if (!(propName in props)) {
                throw new Error(`Missing props '${propsDef[i]}' (component '${Widget.name}')`);
            }
        }
        for (let key in props) {
            if (!propsDef.includes(key) && !propsDef.includes(key + "?")) {
                throw new Error(`Unknown prop '${key}' given to component '${Widget.name}'`);
            }
        }
    }
    else if (propsDef) {
        // propsDef is an object now
        for (let propName in propsDef) {
            if (props[propName] === undefined) {
                if (propsDef[propName] && !propsDef[propName].optional) {
                    throw new Error(`Missing props '${propName}' (component '${Widget.name}')`);
                }
                else {
                    break;
                }
            }
            let isValid;
            try {
                isValid = isValidProp(props[propName], propsDef[propName]);
            }
            catch (e) {
                e.message = `Invalid prop '${propName}' in component ${Widget.name} (${e.message})`;
                throw e;
            }
            if (!isValid) {
                throw new Error(`Invalid Prop '${propName}' in component '${Widget.name}'`);
            }
        }
        for (let propName in props) {
            if (!(propName in propsDef)) {
                throw new Error(`Unknown prop '${propName}' given to component '${Widget.name}'`);
            }
        }
    }
};
/**
 * Check if an invidual prop value matches its (static) prop definition
 */
function isValidProp(prop, propDef) {
    if (propDef === true) {
        return true;
    }
    if (typeof propDef === "function") {
        // Check if a value is constructed by some Constructor.  Note that there is a
        // slight abuse of language: we want to consider primitive values as well.
        //
        // So, even though 1 is not an instance of Number, we want to consider that
        // it is valid.
        if (typeof prop === "object") {
            return prop instanceof propDef;
        }
        return typeof prop === propDef.name.toLowerCase();
    }
    else if (propDef instanceof Array) {
        // If this code is executed, this means that we want to check if a prop
        // matches at least one of its descriptor.
        let result = false;
        for (let i = 0, iLen = propDef.length; i < iLen; i++) {
            result = result || isValidProp(prop, propDef[i]);
        }
        return result;
    }
    // propsDef is an object
    if (propDef.optional && prop === undefined) {
        return true;
    }
    let result = propDef.type ? isValidProp(prop, propDef.type) : true;
    if (propDef.validate) {
        result = result && propDef.validate(prop);
    }
    if (propDef.type === Array && propDef.element) {
        for (let i = 0, iLen = prop.length; i < iLen; i++) {
            result = result && isValidProp(prop[i], propDef.element);
        }
    }
    if (propDef.type === Object && propDef.shape) {
        const shape = propDef.shape;
        for (let key in shape) {
            result = result && isValidProp(prop[key], shape[key]);
        }
        if (result) {
            for (let propName in prop) {
                if (!(propName in shape)) {
                    throw new Error(`unknown prop '${propName}'`);
                }
            }
        }
    }
    return result;
}

/**
 * Owl Style System
 *
 * This files contains the Owl code related to processing (extended) css strings
 * and creating/adding <style> tags to the document head.
 */
const STYLESHEETS = {};
function processSheet(str) {
    const tokens = str.split(/(\{|\}|;)/).map(s => s.trim());
    const selectorStack = [];
    const parts = [];
    let rules = [];
    function generateSelector(stackIndex, parentSelector) {
        const parts = [];
        for (const selector of selectorStack[stackIndex]) {
            let part = (parentSelector && parentSelector + " " + selector) || selector;
            if (part.includes("&")) {
                part = selector.replace(/&/g, parentSelector || "");
            }
            if (stackIndex < selectorStack.length - 1) {
                part = generateSelector(stackIndex + 1, part);
            }
            parts.push(part);
        }
        return parts.join(", ");
    }
    function generateRules() {
        if (rules.length) {
            parts.push(generateSelector(0) + " {");
            parts.push(...rules);
            parts.push("}");
            rules = [];
        }
    }
    while (tokens.length) {
        let token = tokens.shift();
        if (token === "}") {
            generateRules();
            selectorStack.pop();
        }
        else {
            if (tokens[0] === "{") {
                generateRules();
                selectorStack.push(token.split(/\s*,\s*/));
                tokens.shift();
            }
            if (tokens[0] === ";") {
                rules.push("  " + token + ";");
            }
        }
    }
    return parts.join("\n");
}
function registerSheet(id, css) {
    const sheet = document.createElement("style");
    sheet.innerHTML = processSheet(css);
    STYLESHEETS[id] = sheet;
}
function activateSheet(id, name) {
    const sheet = STYLESHEETS[id];
    if (!sheet) {
        throw new Error(`Invalid css stylesheet for component '${name}'. Did you forget to use the 'css' tag helper?`);
    }
    sheet.setAttribute("component", name);
    document.head.appendChild(sheet);
}

const portalSymbol = Symbol("portal"); // FIXME
//------------------------------------------------------------------------------
// Component
//------------------------------------------------------------------------------
let nextId = 1;
class Component {
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Creates an instance of Component.
     *
     * Note that most of the time, only the root component needs to be created by
     * hand.  Other components should be created automatically by the framework (with
     * the t-component directive in a template)
     */
    constructor(parent, props) {
        Component.current = this;
        let constr = this.constructor;
        const defaultProps = constr.defaultProps;
        if (defaultProps) {
            props = props || {};
            this.__applyDefaultProps(props, defaultProps);
        }
        this.props = props;
        if (QWeb.dev) {
            QWeb.utils.validateProps(constr, this.props);
        }
        const id = nextId++;
        let depth;
        if (parent) {
            this.env = parent.env;
            const __powl__ = parent.__owl__;
            __powl__.children[id] = this;
            depth = __powl__.depth + 1;
        }
        else {
            // we are the root component
            this.env = this.constructor.env;
            if (!this.env.qweb) {
                this.env.qweb = new QWeb();
            }
            if (!this.env.browser) {
                this.env.browser = browser;
            }
            this.env.qweb.on("update", this, () => {
                if (this.__owl__.isMounted) {
                    this.render(true);
                }
                if (this.__owl__.isDestroyed) {
                    // this is unlikely to happen, but if a root widget is destroyed,
                    // we want to remove our subscription.  The usual way to do that
                    // would be to perform some check in the destroy method, but since
                    // it is very performance sensitive, and since this is a rare event,
                    // we simply do it lazily
                    this.env.qweb.off("update", this);
                }
            });
            depth = 0;
        }
        const qweb = this.env.qweb;
        const template = constr.template || this.__getTemplate(qweb);
        this.__owl__ = {
            id: id,
            depth: depth,
            vnode: null,
            pvnode: null,
            isMounted: false,
            isDestroyed: false,
            parent: parent || null,
            children: {},
            cmap: {},
            currentFiber: null,
            parentLastFiberId: 0,
            boundHandlers: {},
            mountedCB: null,
            willUnmountCB: null,
            willPatchCB: null,
            patchedCB: null,
            willStartCB: null,
            willUpdatePropsCB: null,
            observer: null,
            renderFn: qweb.render.bind(qweb, template),
            classObj: null,
            refs: null,
            scope: null
        };
        if (constr.style) {
            this.__applyStyles(constr);
        }
    }
    /**
     * The `el` is the root element of the component.  Note that it could be null:
     * this is the case if the component is not mounted yet, or is destroyed.
     */
    get el() {
        return this.__owl__.vnode ? this.__owl__.vnode.elm : null;
    }
    /**
     * willStart is an asynchronous hook that can be implemented to perform some
     * action before the initial rendering of a component.
     *
     * It will be called exactly once before the initial rendering. It is useful
     * in some cases, for example, to load external assets (such as a JS library)
     * before the component is rendered.
     *
     * Note that a slow willStart method will slow down the rendering of the user
     * interface.  Therefore, some effort should be made to make this method as
     * fast as possible.
     *
     * Note: this method should not be called manually.
     */
    async willStart() { }
    /**
     * mounted is a hook that is called each time a component is attached to the
     * DOM. This is a good place to add some listeners, or to interact with the
     * DOM, if the component needs to perform some measure for example.
     *
     * Note: this method should not be called manually.
     *
     * @see willUnmount
     */
    mounted() { }
    /**
     * The willUpdateProps is an asynchronous hook, called just before new props
     * are set. This is useful if the component needs some asynchronous task
     * performed, depending on the props (for example, assuming that the props are
     * some record Id, fetching the record data).
     *
     * This hook is not called during the first render (but willStart is called
     * and performs a similar job).
     */
    async willUpdateProps(nextProps) { }
    /**
     * The willPatch hook is called just before the DOM patching process starts.
     * It is not called on the initial render.  This is useful to get some
     * information which are in the DOM.  For example, the current position of the
     * scrollbar
     */
    willPatch() { }
    /**
     * This hook is called whenever a component did actually update its props,
     * state or env.
     *
     * This method is not called on the initial render. It is useful to interact
     * with the DOM (for example, through an external library) whenever the
     * component was updated.
     *
     * Updating the component state in this hook is possible, but not encouraged.
     * One need to be careful, because updates here will cause rerender, which in
     * turn will cause other calls to updated. So, we need to be particularly
     * careful at avoiding endless cycles.
     */
    patched() { }
    /**
     * willUnmount is a hook that is called each time just before a component is
     * unmounted from the DOM. This is a good place to remove some listeners, for
     * example.
     *
     * Note: this method should not be called manually.
     *
     * @see mounted
     */
    willUnmount() { }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Mount the component to a target element.
     *
     * This should only be done if the component was created manually. Components
     * created declaratively in templates are managed by the Owl system.
     *
     * Note that a component can be mounted an unmounted several times
     */
    async mount(target, options = {}) {
        const position = options.position || "last-child";
        const __owl__ = this.__owl__;
        if (__owl__.isMounted) {
            if (position !== "self" && this.el.parentNode !== target) {
                // in this situation, we are trying to mount a component on a different
                // target. In this case, we need to unmount first, otherwise it will
                // not work.
                this.unmount();
            }
            else {
                return Promise.resolve();
            }
        }
        if (__owl__.currentFiber) {
            const currentFiber = __owl__.currentFiber;
            if (currentFiber.target === target && currentFiber.position === position) {
                return scheduler.addFiber(currentFiber);
            }
            else {
                scheduler.rejectFiber(currentFiber, "Mounting operation cancelled");
            }
        }
        if (!(target instanceof HTMLElement || target instanceof DocumentFragment)) {
            let message = `Component '${this.constructor.name}' cannot be mounted: the target is not a valid DOM node.`;
            message += `\nMaybe the DOM is not ready yet? (in that case, you can use owl.utils.whenReady)`;
            throw new Error(message);
        }
        const fiber = new Fiber(null, this, false, target, position);
        fiber.shouldPatch = false;
        if (!__owl__.vnode) {
            this.__prepareAndRender(fiber, () => { });
        }
        else {
            this.__render(fiber);
        }
        return scheduler.addFiber(fiber);
    }
    /**
     * The unmount method is the opposite of the mount method.  It is useful
     * to call willUnmount calls and remove the component from the DOM.
     */
    unmount() {
        if (this.__owl__.isMounted) {
            this.__callWillUnmount();
            this.el.remove();
        }
    }
    /**
     * The render method is the main entry point to render a component (once it
     * is ready. This method is not initially called when the component is
     * rendered the first time).
     *
     * This method will cause all its sub components to potentially rerender
     * themselves.  Note that `render` is not called if a component is updated via
     * its props.
     */
    async render(force = false) {
        const __owl__ = this.__owl__;
        const currentFiber = __owl__.currentFiber;
        if (!__owl__.isMounted && !currentFiber) {
            // if we get here, this means that the component was either never mounted,
            // or was unmounted and some state change  triggered a render. Either way,
            // we do not want to actually render anything in this case.
            return;
        }
        if (currentFiber && !currentFiber.isRendered && !currentFiber.isCompleted) {
            return scheduler.addFiber(currentFiber.root);
        }
        // if we aren't mounted at this point, it implies that there is a
        // currentFiber that is already rendered (isRendered is true), so we are
        // about to be mounted
        const isMounted = __owl__.isMounted;
        const fiber = new Fiber(null, this, force, null, null);
        Promise.resolve().then(() => {
            if (__owl__.isMounted || !isMounted) {
                if (fiber.isCompleted) {
                    return;
                }
                // we are mounted (__owl__.isMounted), or if we are currently being
                // mounted (!isMounted), so we call __render
                this.__render(fiber);
            }
            else {
                // we were mounted when render was called, but we aren't anymore, so we
                // were actually about to be unmounted ; we can thus forget about this
                // fiber
                fiber.isCompleted = true;
                __owl__.currentFiber = null;
            }
        });
        return scheduler.addFiber(fiber);
    }
    /**
     * Destroy the component.  This operation is quite complex:
     *  - it recursively destroy all children
     *  - call the willUnmount hooks if necessary
     *  - remove the dom node from the dom
     *
     * This should only be called manually if you created the component.  Most
     * components will be automatically destroyed.
     */
    destroy() {
        const __owl__ = this.__owl__;
        if (!__owl__.isDestroyed) {
            const el = this.el;
            this.__destroy(__owl__.parent);
            if (el) {
                el.remove();
            }
        }
    }
    /**
     * This method is called by the component system whenever its props are
     * updated. If it returns true, then the component will be rendered.
     * Otherwise, it will skip the rendering (also, its props will not be updated)
     */
    shouldUpdate(nextProps) {
        return true;
    }
    /**
     * Emit a custom event of type 'eventType' with the given 'payload' on the
     * component's el, if it exists. However, note that the event will only bubble
     * up to the parent DOM nodes. Thus, it must be called between mounted() and
     * willUnmount().
     */
    trigger(eventType, payload) {
        this.__trigger(this, eventType, payload);
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Private helper to perform a full destroy, from the point of view of an Owl
     * component. It does not remove the el (this is done only once on the top
     * level destroyed component, for performance reasons).
     *
     * The job of this method is mostly to call willUnmount hooks, and to perform
     * all necessary internal cleanup.
     *
     * Note that it does not call the __callWillUnmount method to avoid visiting
     * all children many times.
     */
    __destroy(parent) {
        const __owl__ = this.__owl__;
        const isMounted = __owl__.isMounted;
        if (isMounted) {
            if (__owl__.willUnmountCB) {
                __owl__.willUnmountCB();
            }
            this.willUnmount();
            __owl__.isMounted = false;
        }
        const children = __owl__.children;
        for (let key in children) {
            children[key].__destroy(this);
        }
        if (parent) {
            let id = __owl__.id;
            delete parent.__owl__.children[id];
            __owl__.parent = null;
        }
        __owl__.isDestroyed = true;
        delete __owl__.vnode;
        if (__owl__.currentFiber) {
            __owl__.currentFiber.isCompleted = true;
        }
    }
    __callMounted() {
        const __owl__ = this.__owl__;
        __owl__.isMounted = true;
        __owl__.currentFiber = null;
        this.mounted();
        if (__owl__.mountedCB) {
            __owl__.mountedCB();
        }
    }
    __callWillUnmount() {
        const __owl__ = this.__owl__;
        if (__owl__.willUnmountCB) {
            __owl__.willUnmountCB();
        }
        this.willUnmount();
        __owl__.isMounted = false;
        if (this.__owl__.currentFiber) {
            this.__owl__.currentFiber.isCompleted = true;
            this.__owl__.currentFiber.root.counter = 0;
        }
        const children = __owl__.children;
        for (let id in children) {
            const comp = children[id];
            if (comp.__owl__.isMounted) {
                comp.__callWillUnmount();
            }
        }
    }
    /**
     * Private trigger method, allows to choose the component which triggered
     * the event in the first place
     */
    __trigger(component, eventType, payload) {
        if (this.el) {
            const ev = new OwlEvent(component, eventType, {
                bubbles: true,
                cancelable: true,
                detail: payload
            });
            const triggerHook = this.env[portalSymbol];
            if (triggerHook) {
                triggerHook(ev);
            }
            this.el.dispatchEvent(ev);
        }
    }
    /**
     * The __updateProps method is called by the t-component directive whenever
     * it updates a component (so, when the parent template is rerendered).
     */
    async __updateProps(nextProps, parentFiber, scope) {
        this.__owl__.scope = scope;
        const shouldUpdate = parentFiber.force || this.shouldUpdate(nextProps);
        if (shouldUpdate) {
            const __owl__ = this.__owl__;
            const fiber = new Fiber(parentFiber, this, parentFiber.force, null, null);
            if (!parentFiber.child) {
                parentFiber.child = fiber;
            }
            else {
                parentFiber.lastChild.sibling = fiber;
            }
            parentFiber.lastChild = fiber;
            const defaultProps = this.constructor.defaultProps;
            if (defaultProps) {
                this.__applyDefaultProps(nextProps, defaultProps);
            }
            if (QWeb.dev) {
                QWeb.utils.validateProps(this.constructor, nextProps);
            }
            await Promise.all([
                this.willUpdateProps(nextProps),
                __owl__.willUpdatePropsCB && __owl__.willUpdatePropsCB(nextProps)
            ]);
            if (fiber.isCompleted) {
                return;
            }
            this.props = nextProps;
            this.__render(fiber);
        }
    }
    /**
     * Main patching method. We call the virtual dom patch method here to convert
     * a virtual dom vnode into some actual dom.
     */
    __patch(target, vnode) {
        this.__owl__.vnode = patch(target, vnode);
    }
    /**
     * The __prepare method is only called by the t-component directive, when a
     * subcomponent is created. It gets its scope, if any, from the
     * parent template.
     */
    __prepare(parentFiber, scope, cb) {
        this.__owl__.scope = scope;
        const fiber = new Fiber(parentFiber, this, parentFiber.force, null, null);
        fiber.shouldPatch = false;
        if (!parentFiber.child) {
            parentFiber.child = fiber;
        }
        else {
            parentFiber.lastChild.sibling = fiber;
        }
        parentFiber.lastChild = fiber;
        this.__prepareAndRender(fiber, cb);
        return fiber;
    }
    /**
     * Apply the stylesheets defined by the component. Note that we need to make
     * sure all inherited stylesheets are applied as well.  We then delete the
     * `style` key from the constructor to make sure we do not apply it again.
     */
    __applyStyles(constr) {
        while (constr && constr.style) {
            if (constr.hasOwnProperty("style")) {
                activateSheet(constr.style, constr.name);
                delete constr.style;
            }
            constr = constr.__proto__;
        }
    }
    __getTemplate(qweb) {
        let p = this.constructor;
        if (!p.hasOwnProperty("_template")) {
            // here, the component and none of its superclasses defines a static `template`
            // key. So we fall back on looking for a template matching its name (or
            // one of its subclass).
            let template = p.name;
            while (!(template in qweb.templates) && p !== Component) {
                p = p.__proto__;
                template = p.name;
            }
            if (p === Component) {
                throw new Error(`Could not find template for component "${this.constructor.name}"`);
            }
            else {
                p._template = template;
            }
        }
        return p._template;
    }
    async __prepareAndRender(fiber, cb) {
        try {
            await Promise.all([this.willStart(), this.__owl__.willStartCB && this.__owl__.willStartCB()]);
        }
        catch (e) {
            fiber.handleError(e);
            return Promise.resolve();
        }
        if (this.__owl__.isDestroyed) {
            return Promise.resolve();
        }
        if (!fiber.isCompleted) {
            this.__render(fiber);
            cb();
        }
    }
    __render(fiber) {
        const __owl__ = this.__owl__;
        if (__owl__.observer) {
            __owl__.observer.allowMutations = false;
        }
        let error;
        try {
            let vnode = __owl__.renderFn(this, {
                handlers: __owl__.boundHandlers,
                fiber: fiber
            });
            // we iterate over the children to detect those that no longer belong to the
            // current rendering: those ones, if not mounted yet, can (and have to) be
            // destroyed right now, because they are not in the DOM, and thus we won't
            // be notified later on (when patching), that they are removed from the DOM
            for (let childKey in __owl__.children) {
                let child = __owl__.children[childKey];
                if (!child.__owl__.isMounted && child.__owl__.parentLastFiberId < fiber.id) {
                    child.destroy();
                }
            }
            if (!vnode) {
                throw new Error(`Rendering '${this.constructor.name}' did not return anything`);
            }
            fiber.vnode = vnode;
            // we apply here the class information described on the component by the
            // template (so, something like <MyComponent class="..."/>) to the actual
            // root vnode
            if (__owl__.classObj) {
                const data = vnode.data;
                data.class = Object.assign(data.class || {}, __owl__.classObj);
            }
        }
        catch (e) {
            error = e;
        }
        if (__owl__.observer) {
            __owl__.observer.allowMutations = true;
        }
        fiber.root.counter--;
        fiber.isRendered = true;
        if (error) {
            fiber.handleError(error);
        }
    }
    /**
     * Only called by qweb t-component directive (when t-keepalive is set)
     */
    __remount() {
        const __owl__ = this.__owl__;
        if (!__owl__.isMounted) {
            __owl__.isMounted = true;
            this.mounted();
        }
    }
    /**
     * Apply default props (only top level).
     *
     * Note that this method does modify in place the props
     */
    __applyDefaultProps(props, defaultProps) {
        for (let propName in defaultProps) {
            if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
            }
        }
    }
}
Component.template = null;
Component._template = null;
Component.current = null;
Component.components = {};
Component.env = {};
// expose scheduler s.t. it can be mocked for testing purposes
Component.scheduler = scheduler;

/**
 * The `Context` object provides a way to share data between an arbitrary number
 * of component. Usually, data is passed from a parent to its children component,
 * but when we have to deal with some mostly global information, this can be
 * annoying, since each component will need to pass the information to each
 * children, even though some or most of them will not use the information.
 *
 * With a `Context` object, each component can subscribe (with the `useContext`
 * hook) to its state, and will be updated whenever the context state is updated.
 */
function partitionBy(arr, fn) {
    let lastGroup = false;
    let lastValue;
    return arr.reduce((acc, cur) => {
        let curVal = fn(cur);
        if (lastGroup) {
            if (curVal === lastValue) {
                lastGroup.push(cur);
            }
            else {
                lastGroup = false;
            }
        }
        if (!lastGroup) {
            lastGroup = [cur];
            acc.push(lastGroup);
        }
        lastValue = curVal;
        return acc;
    }, []);
}
class Context extends EventBus {
    constructor(state = {}) {
        super();
        this.rev = 1;
        // mapping from component id to last observed context id
        this.mapping = {};
        this.observer = new Observer();
        this.observer.notifyCB = () => {
            // notify components in the next microtask tick to ensure that subscribers
            // are notified only once for all changes that occur in the same micro tick
            let rev = this.rev;
            return Promise.resolve().then(() => {
                if (rev === this.rev) {
                    this.__notifyComponents();
                }
            });
        };
        this.state = this.observer.observe(state);
        this.subscriptions.update = [];
    }
    /**
     * Instead of using trigger to emit an update event, we actually implement
     * our own function to do that.  The reason is that we need to be smarter than
     * a simple trigger function: we need to wait for parent components to be
     * done before doing children components.  More precisely, if an update
     * as an effect of destroying a children, we do not want to call any code
     * from the child, and certainly not render it.
     *
     * This method implements a simple grouping algorithm by depth. If we have
     * connected components of depths [2, 4,4,4,4, 3,8,8], the Context will notify
     * them in the following groups: [2], [4,4,4,4], [3], [8,8]. Each group will
     * be updated sequentially, but each components in a given group will be done in
     * parallel.
     *
     * This is a very simple algorithm, but it avoids checking if a given
     * component is a child of another.
     */
    async __notifyComponents() {
        const rev = ++this.rev;
        const subscriptions = this.subscriptions.update;
        const groups = partitionBy(subscriptions, s => (s.owner ? s.owner.__owl__.depth : -1));
        for (let group of groups) {
            const proms = group.map(sub => sub.callback.call(sub.owner, rev));
            // at this point, each component in the current group has registered a
            // top level fiber in the scheduler. It could happen that rendering these
            // components is done (if they have no children).  This is why we manually
            // flush the scheduler.  This will force the scheduler to check
            // immediately if they are done, which will cause their rendering
            // promise to resolve earlier, which means that there is a chance of
            // processing the next group in the same frame.
            scheduler.flush();
            await Promise.all(proms);
        }
    }
}
/**
 * The`useContext` hook is the normal way for a component to register themselve
 * to context state changes. The `useContext` method returns the context state
 */
function useContext(ctx) {
    const component = Component.current;
    return useContextWithCB(ctx, component, component.render.bind(component));
}
function useContextWithCB(ctx, component, method) {
    const __owl__ = component.__owl__;
    const id = __owl__.id;
    const mapping = ctx.mapping;
    if (id in mapping) {
        return ctx.state;
    }
    if (!__owl__.observer) {
        __owl__.observer = new Observer();
        __owl__.observer.notifyCB = component.render.bind(component);
    }
    const currentCB = __owl__.observer.notifyCB;
    __owl__.observer.notifyCB = function () {
        if (ctx.rev > mapping[id]) {
            // in this case, the context has been updated since we were rendering
            // last, and we do not need to render here with the observer. A
            // rendering is coming anyway, with the correct props.
            return;
        }
        currentCB();
    };
    mapping[id] = 0;
    const renderFn = __owl__.renderFn;
    __owl__.renderFn = function (comp, params) {
        mapping[id] = ctx.rev;
        return renderFn(comp, params);
    };
    ctx.on("update", component, async (contextRev) => {
        if (mapping[id] < contextRev) {
            mapping[id] = contextRev;
            await method();
        }
    });
    const __destroy = component.__destroy;
    component.__destroy = parent => {
        ctx.off("update", component);
        delete mapping[id];
        __destroy.call(component, parent);
    };
    return ctx.state;
}

/**
 * Owl Hook System
 *
 * This file introduces the concept of hooks, similar to React or Vue hooks.
 * We have currently an implementation of:
 * - useState (reactive state)
 * - onMounted
 * - onWillUnmount
 * - useRef
 */
// -----------------------------------------------------------------------------
// useState
// -----------------------------------------------------------------------------
/**
 * This is the main way a component can be made reactive.  The useState hook
 * will return an observed object (or array).  Changes to that value will then
 * trigger a rerendering of the current component.
 */
function useState(state) {
    const component = Component.current;
    const __owl__ = component.__owl__;
    if (!__owl__.observer) {
        __owl__.observer = new Observer();
        __owl__.observer.notifyCB = component.render.bind(component);
    }
    return __owl__.observer.observe(state);
}
// -----------------------------------------------------------------------------
// Life cycle hooks
// -----------------------------------------------------------------------------
function makeLifecycleHook(method, reverse = false) {
    if (reverse) {
        return function (cb) {
            const component = Component.current;
            if (component.__owl__[method]) {
                const current = component.__owl__[method];
                component.__owl__[method] = function () {
                    current.call(component);
                    cb.call(component);
                };
            }
            else {
                component.__owl__[method] = cb;
            }
        };
    }
    else {
        return function (cb) {
            const component = Component.current;
            if (component.__owl__[method]) {
                const current = component.__owl__[method];
                component.__owl__[method] = function () {
                    cb.call(component);
                    current.call(component);
                };
            }
            else {
                component.__owl__[method] = cb;
            }
        };
    }
}
function makeAsyncHook(method) {
    return function (cb) {
        const component = Component.current;
        if (component.__owl__[method]) {
            const current = component.__owl__[method];
            component.__owl__[method] = function (...args) {
                return Promise.all([current.call(component, ...args), cb.call(component, ...args)]);
            };
        }
        else {
            component.__owl__[method] = cb;
        }
    };
}
const onMounted = makeLifecycleHook("mountedCB", true);
const onWillUnmount = makeLifecycleHook("willUnmountCB");
const onWillPatch = makeLifecycleHook("willPatchCB");
const onPatched = makeLifecycleHook("patchedCB", true);
const onWillStart = makeAsyncHook("willStartCB");
const onWillUpdateProps = makeAsyncHook("willUpdatePropsCB");
function useRef(name) {
    const __owl__ = Component.current.__owl__;
    return {
        get el() {
            const val = __owl__.refs && __owl__.refs[name];
            if (val instanceof HTMLElement) {
                return val;
            }
            else if (val instanceof Component) {
                return val.el;
            }
            return null;
        },
        get comp() {
            const val = __owl__.refs && __owl__.refs[name];
            return val instanceof Component ? val : null;
        }
    };
}
// -----------------------------------------------------------------------------
// useSubEnv
// -----------------------------------------------------------------------------
/**
 * This hook is a simple way to let components use a sub environment.  Note that
 * like for all hooks, it is important that this is only called in the
 * constructor method.
 */
function useSubEnv(nextEnv) {
    const component = Component.current;
    component.env = Object.assign(Object.create(component.env), nextEnv);
}
// -----------------------------------------------------------------------------
// useExternalListener
// -----------------------------------------------------------------------------
/**
 * When a component needs to listen to DOM Events on element(s) that are not
 * part of his hierarchy, we can use the `useExternalListener` hook.
 * It will correctly add and remove the event listener, whenever the
 * component is mounted and unmounted.
 *
 * Example:
 *  a menu needs to listen to the click on window to be closed automatically
 *
 * Usage:
 *  in the constructor of the OWL component that needs to be notified,
 *  `useExternalListener(window, 'click', this._doSomething);`
 * */
function useExternalListener(target, eventName, handler, eventParams) {
    const boundHandler = handler.bind(Component.current);
    onMounted(() => target.addEventListener(eventName, boundHandler, eventParams));
    onWillUnmount(() => target.removeEventListener(eventName, boundHandler, eventParams));
}

var _hooks = /*#__PURE__*/Object.freeze({
    __proto__: null,
    useState: useState,
    onMounted: onMounted,
    onWillUnmount: onWillUnmount,
    onWillPatch: onWillPatch,
    onPatched: onPatched,
    onWillStart: onWillStart,
    onWillUpdateProps: onWillUpdateProps,
    useRef: useRef,
    useSubEnv: useSubEnv,
    useExternalListener: useExternalListener
});

class Store extends Context {
    constructor(config) {
        super(config.state);
        this.actions = config.actions;
        this.env = config.env;
        this.getters = {};
        this.updateFunctions = [];
        if (config.getters) {
            const firstArg = {
                state: this.state,
                getters: this.getters
            };
            for (let g in config.getters) {
                this.getters[g] = config.getters[g].bind(this, firstArg);
            }
        }
    }
    dispatch(action, ...payload) {
        if (!this.actions[action]) {
            throw new Error(`[Error] action ${action} is undefined`);
        }
        const result = this.actions[action]({
            dispatch: this.dispatch.bind(this),
            env: this.env,
            state: this.state,
            getters: this.getters
        }, ...payload);
        return result;
    }
}
const isStrictEqual = (a, b) => a === b;
function useStore(selector, options = {}) {
    const component = Component.current;
    const componentId = component.__owl__.id;
    const store = options.store || component.env.store;
    if (!(store instanceof Store)) {
        throw new Error(`No store found when connecting '${component.constructor.name}'`);
    }
    let result = selector(store.state, component.props);
    const hashFn = store.observer.revNumber.bind(store.observer);
    let revNumber = hashFn(result);
    const isEqual = options.isEqual || isStrictEqual;
    if (!store.updateFunctions[componentId]) {
        store.updateFunctions[componentId] = [];
    }
    function selectCompareUpdate(state, props) {
        const oldResult = result;
        result = selector(state, props);
        const newRevNumber = hashFn(result);
        if ((newRevNumber > 0 && revNumber !== newRevNumber) || !isEqual(oldResult, result)) {
            revNumber = newRevNumber;
            if (options.onUpdate) {
                options.onUpdate(result);
            }
            return true;
        }
        return false;
    }
    store.updateFunctions[componentId].push(function () {
        return selectCompareUpdate(store.state, component.props);
    });
    useContextWithCB(store, component, function () {
        let shouldRender = false;
        for (let fn of store.updateFunctions[componentId]) {
            shouldRender = fn() || shouldRender;
        }
        if (shouldRender) {
            return component.render();
        }
    });
    onWillUpdateProps(props => {
        selectCompareUpdate(store.state, props);
    });
    const __destroy = component.__destroy;
    component.__destroy = parent => {
        delete store.updateFunctions[componentId];
        __destroy.call(component, parent);
    };
    if (typeof result !== "object" || result === null) {
        return result;
    }
    return new Proxy(result, {
        get(target, k) {
            return result[k];
        },
        set(target, k, v) {
            throw new Error("Store state should only be modified through actions");
        },
        has(target, k) {
            return k in result;
        }
    });
}
function useDispatch(store) {
    store = store || Component.current.env.store;
    return store.dispatch.bind(store);
}
function useGetters(store) {
    store = store || Component.current.env.store;
    return store.getters;
}

/**
 * Owl Tags
 *
 * We have here a (very) small collection of tag functions:
 *
 * - xml
 *
 * The plan is to add a few other tags such as css, globalcss.
 */
/**
 * XML tag helper for defining templates.  With this, one can simply define
 * an inline template with just the template xml:
 * ```js
 *   class A extends Component {
 *     static template = xml`<div>some template</div>`;
 *   }
 * ```
 */
function xml(strings, ...args) {
    const name = `__template__${QWeb.nextId++}`;
    const value = String.raw(strings, ...args);
    QWeb.registerTemplate(name, value);
    return name;
}
/**
 * CSS tag helper for defining inline stylesheets.  With this, one can simply define
 * an inline stylesheet with just the following code:
 * ```js
 *   class A extends Component {
 *     static style = css`.component-a { color: red; }`;
 *   }
 * ```
 */
function css(strings, ...args) {
    const name = `__sheet__${QWeb.nextId++}`;
    const value = String.raw(strings, ...args);
    registerSheet(name, value);
    return name;
}

var _tags = /*#__PURE__*/Object.freeze({
    __proto__: null,
    xml: xml,
    css: css
});

/**
 * AsyncRoot
 *
 * Owl is by default asynchronous, and the user interface will wait for all its
 * subcomponents to be rendered before updating the DOM. This is most of the
 * time what we want, but in some cases, it makes sense to "detach" a component
 * from this coordination.  This is the goal of the AsyncRoot component.
 */
class AsyncRoot extends Component {
    async __updateProps(nextProps, parentFiber) {
        this.render(parentFiber.force);
    }
}
AsyncRoot.template = xml `<t t-slot="default"/>`;

class Portal extends Component {
    constructor(parent, props) {
        super(parent, props);
        // boolean to indicate whether or not we must listen to 'dom-appended' event
        // to hook on the moment when the target is inserted into the DOM (because it
        // is not when the portal is rendered)
        this.doTargetLookUp = true;
        // set of encountered events that need to be redirected
        this._handledEvents = new Set();
        // function that will be the event's tunnel (needs to be an arrow function to
        // avoid having to rebind `this`)
        this._handlerTunnel = (ev) => {
            ev.stopPropagation();
            this.__trigger(ev.originalComponent, ev.type, ev.detail);
        };
        // Storing the parent's env
        this.parentEnv = null;
        // represents the element that is moved somewhere else
        this.portal = null;
        // the target where we will move `portal`
        this.target = null;
        this.parentEnv = parent ? parent.env : {};
        // put a callback in the env that is propagated to children s.t. portal can
        // register an handler to those events just before children will trigger them
        useSubEnv({
            [portalSymbol]: ev => {
                if (!this._handledEvents.has(ev.type)) {
                    this.portal.elm.addEventListener(ev.type, this._handlerTunnel);
                    this._handledEvents.add(ev.type);
                }
            }
        });
    }
    /**
     * Override to revert back to a classic Component's structure
     *
     * @override
     */
    __callWillUnmount() {
        super.__callWillUnmount();
        this.el.appendChild(this.portal.elm);
        this.doTargetLookUp = true;
    }
    /**
     * At each DOM change, we must ensure that the portal contains exactly one
     * child
     */
    __checkVNodeStructure(vnode) {
        const children = vnode.children;
        let countRealNodes = 0;
        for (let child of children) {
            if (child.sel) {
                countRealNodes++;
            }
        }
        if (countRealNodes !== 1) {
            throw new Error(`Portal must have exactly one non-text child (has ${countRealNodes})`);
        }
    }
    /**
     * Ensure the target is still there at whichever time we render
     */
    __checkTargetPresence() {
        if (!this.target || !document.contains(this.target)) {
            throw new Error(`Could not find any match for "${this.props.target}"`);
        }
    }
    /**
     * Move the portal's element to the target
     */
    __deployPortal() {
        this.__checkTargetPresence();
        this.target.appendChild(this.portal.elm);
    }
    /**
     * Override to remove from the DOM the element we have teleported
     *
     * @override
     */
    __destroy(parent) {
        if (this.portal && this.portal.elm) {
            const displacedElm = this.portal.elm;
            const parent = displacedElm.parentNode;
            if (parent) {
                parent.removeChild(displacedElm);
            }
        }
        super.__destroy(parent);
    }
    /**
     * Override to patch the element that has been teleported
     *
     * @override
     */
    __patch(target, vnode) {
        if (this.doTargetLookUp) {
            const target = document.querySelector(this.props.target);
            if (!target) {
                this.env.qweb.on("dom-appended", this, () => {
                    this.doTargetLookUp = false;
                    this.env.qweb.off("dom-appended", this);
                    this.target = document.querySelector(this.props.target);
                    this.__deployPortal();
                });
            }
            else {
                this.doTargetLookUp = false;
                this.target = target;
            }
        }
        this.__checkVNodeStructure(vnode);
        const shouldDeploy = (!this.portal || this.el.contains(this.portal.elm)) && !this.doTargetLookUp;
        if (!this.doTargetLookUp && !shouldDeploy) {
            // Only on pure patching, provided the
            // this.target's parent has not been unmounted
            this.__checkTargetPresence();
        }
        const portalPatch = this.portal ? this.portal : document.createElement(vnode.children[0].sel);
        this.portal = patch(portalPatch, vnode.children[0]);
        vnode.children = [];
        super.__patch(target, vnode);
        if (shouldDeploy) {
            this.__deployPortal();
        }
    }
    /**
     * Override to set the env
     */
    __trigger(component, eventType, payload) {
        const env = this.env;
        this.env = this.parentEnv;
        super.__trigger(component, eventType, payload);
        this.env = env;
    }
}
Portal.template = xml `<portal><t t-slot="default"/></portal>`;
Portal.props = {
    target: {
        type: String
    }
};

class Link extends Component {
    constructor() {
        super(...arguments);
        this.href = this.env.router.destToPath(this.props);
    }
    async willUpdateProps(nextProps) {
        this.href = this.env.router.destToPath(nextProps);
    }
    get isActive() {
        if (this.env.router.mode === "hash") {
            return document.location.hash === this.href;
        }
        return document.location.pathname === this.href;
    }
    navigate(ev) {
        // don't redirect with control keys
        if (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey) {
            return;
        }
        // don't redirect on right click
        if (ev.button !== undefined && ev.button !== 0) {
            return;
        }
        // don't redirect if `target="_blank"`
        if (ev.currentTarget && ev.currentTarget.getAttribute) {
            const target = ev.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(target)) {
                return;
            }
        }
        ev.preventDefault();
        this.env.router.navigate(this.props);
    }
}
Link.template = xml `
    <a  t-att-class="{'router-link-active': isActive }"
        t-att-href="href"
        t-on-click="navigate">
        <t t-slot="default"/>
    </a>
  `;

class RouteComponent extends Component {
    get routeComponent() {
        return this.env.router.currentRoute && this.env.router.currentRoute.component;
    }
}
RouteComponent.template = xml `
    <t>
        <t
            t-if="routeComponent"
            t-component="routeComponent"
            t-key="env.router.currentRouteName"
            t-props="env.router.currentParams" />
    </t>
  `;

const paramRegexp = /\{\{(.*?)\}\}/;
class Router {
    constructor(env, routes, options = { mode: "history" }) {
        this.currentRoute = null;
        this.currentParams = null;
        env.router = this;
        this.mode = options.mode;
        this.env = env;
        this.routes = {};
        this.routeIds = [];
        let nextId = 1;
        for (let partialRoute of routes) {
            if (!partialRoute.name) {
                partialRoute.name = "__route__" + nextId++;
            }
            if (partialRoute.component) {
                QWeb.registerComponent("__component__" + partialRoute.name, partialRoute.component);
            }
            if (partialRoute.redirect) {
                this.validateDestination(partialRoute.redirect);
            }
            partialRoute.params = partialRoute.path ? findParams(partialRoute.path) : [];
            this.routes[partialRoute.name] = partialRoute;
            this.routeIds.push(partialRoute.name);
        }
    }
    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------
    async start() {
        this._listener = ev => this._navigate(this.currentPath(), ev);
        window.addEventListener("popstate", this._listener);
        if (this.mode === "hash") {
            window.addEventListener("hashchange", this._listener);
        }
        const result = await this.matchAndApplyRules(this.currentPath());
        if (result.type === "match") {
            this.currentRoute = result.route;
            this.currentParams = result.params;
            const currentPath = this.routeToPath(result.route, result.params);
            if (currentPath !== this.currentPath()) {
                this.setUrlFromPath(currentPath);
            }
        }
    }
    async navigate(to) {
        const path = this.destToPath(to);
        return this._navigate(path);
    }
    async _navigate(path, ev) {
        const initialName = this.currentRouteName;
        const initialParams = this.currentParams;
        const result = await this.matchAndApplyRules(path);
        if (result.type === "match") {
            const finalPath = this.routeToPath(result.route, result.params);
            const isPopStateEvent = ev && ev instanceof PopStateEvent;
            if (!isPopStateEvent) {
                this.setUrlFromPath(finalPath);
            }
            this.currentRoute = result.route;
            this.currentParams = result.params;
        }
        else if (result.type === "nomatch") {
            this.currentRoute = null;
            this.currentParams = null;
        }
        const didChange = this.currentRouteName !== initialName || !shallowEqual(this.currentParams, initialParams);
        if (didChange) {
            this.env.qweb.forceUpdate();
            return true;
        }
        return false;
    }
    destToPath(dest) {
        this.validateDestination(dest);
        return dest.path || this.routeToPath(this.routes[dest.to], dest.params);
    }
    get currentRouteName() {
        return this.currentRoute && this.currentRoute.name;
    }
    //--------------------------------------------------------------------------
    // Private helpers
    //--------------------------------------------------------------------------
    setUrlFromPath(path) {
        const separator = this.mode === "hash" ? location.pathname : "";
        const url = location.origin + separator + path;
        if (url !== window.location.href) {
            window.history.pushState({}, path, url);
        }
    }
    validateDestination(dest) {
        if ((!dest.path && !dest.to) || (dest.path && dest.to)) {
            throw new Error(`Invalid destination: ${JSON.stringify(dest)}`);
        }
    }
    routeToPath(route, params) {
        const path = route.path;
        const parts = path.split("/");
        const l = parts.length;
        for (let i = 0; i < l; i++) {
            const part = parts[i];
            const match = part.match(paramRegexp);
            if (match) {
                const key = match[1].split(".")[0];
                parts[i] = params[key];
            }
        }
        const prefix = this.mode === "hash" ? "#" : "";
        return prefix + parts.join("/");
    }
    currentPath() {
        let result = this.mode === "history" ? window.location.pathname : window.location.hash.slice(1);
        return result || "/";
    }
    match(path) {
        for (let routeId of this.routeIds) {
            let route = this.routes[routeId];
            let params = this.getRouteParams(route, path);
            if (params) {
                return {
                    type: "match",
                    route: route,
                    params: params
                };
            }
        }
        return { type: "nomatch" };
    }
    async matchAndApplyRules(path) {
        const result = this.match(path);
        if (result.type === "match") {
            return this.applyRules(result);
        }
        return result;
    }
    async applyRules(matchResult) {
        const route = matchResult.route;
        if (route.redirect) {
            const path = this.destToPath(route.redirect);
            return this.matchAndApplyRules(path);
        }
        if (route.beforeRouteEnter) {
            const result = await route.beforeRouteEnter({
                env: this.env,
                from: this.currentRoute,
                to: route
            });
            if (result === false) {
                return { type: "cancelled" };
            }
            else if (result !== true) {
                // we want to navigate to another destination
                const path = this.destToPath(result);
                return this.matchAndApplyRules(path);
            }
        }
        return matchResult;
    }
    getRouteParams(route, path) {
        if (route.path === "*") {
            return {};
        }
        if (path.startsWith("#")) {
            path = path.slice(1);
        }
        const descrParts = route.path.split("/");
        const targetParts = path.split("/");
        const l = descrParts.length;
        if (l !== targetParts.length) {
            return false;
        }
        const result = {};
        for (let i = 0; i < l; i++) {
            const descr = descrParts[i];
            let target = targetParts[i];
            const match = descr.match(paramRegexp);
            if (match) {
                const [key, suffix] = match[1].split(".");
                if (suffix === "number") {
                    target = parseInt(target, 10);
                }
                result[key] = target;
            }
            else if (descr !== target) {
                return false;
            }
        }
        return result;
    }
}
function findParams(str) {
    const globalParamRegexp = /\{\{(.*?)\}\}/g;
    const result = [];
    let m;
    do {
        m = globalParamRegexp.exec(str);
        if (m) {
            result.push(m[1].split(".")[0]);
        }
    } while (m);
    return result;
}

/**
 * This file is the main file packaged by rollup (see rollup.config.js).  From
 * this file, we export all public owl elements.
 *
 * Note that dynamic values, such as a date or a commit hash are added by rollup
 */
const Context$1 = Context;
const useState$1 = useState;
const core = { EventBus, Observer };
const router = { Router, RouteComponent, Link };
const Store$1 = Store;
const utils = _utils;
const tags = _tags;
const misc = { AsyncRoot, Portal };
const hooks$1 = Object.assign({}, _hooks, {
    useContext: useContext,
    useDispatch: useDispatch,
    useGetters: useGetters,
    useStore: useStore
});
const __info__ = {};

exports.Component = Component;
exports.Context = Context$1;
exports.QWeb = QWeb;
exports.Store = Store$1;
exports.__info__ = __info__;
exports.config = config;
exports.core = core;
exports.hooks = hooks$1;
exports.misc = misc;
exports.router = router;
exports.tags = tags;
exports.useState = useState$1;
exports.utils = utils;

exports.__info__.version = '1.0.7';
exports.__info__.date = '2020-04-17T13:53:57.507Z';
exports.__info__.hash = '23ce19e';
exports.__info__.url = 'https://github.com/odoo/owl';


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = "<templates>\n    <div t-name=\"link\">\n        <h2>Insert a link</h2>\n        <table class=\"form-table\">\n            <tr>\n                <td><label for=\"linkUrl\">URL </label></td>\n                <td><input type=\"text\" id=\"linkUrl\" name=\"url\" t-model=\"state.url\"/></td>\n            </tr>\n            <tr>\n                <td><label for=\"linkLabel\">Label </label></td>\n                <td><input type=\"text\" id=\"linkLabel\" name=\"label\" t-model=\"state.label\"/></td>\n            </tr>\n        </table>\n        <br/>\n        <button name=\"save\" t-on-click=\"saveLink()\">Save</button> <button name=\"save\" t-on-click=\"cancel()\">Cancel</button>\n    </div>\n</templates>\n"

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = "<jw-dialog>\n    <jw-backdrop class=\"jw-close\"></jw-backdrop>\n    <jw-content>\n        <jw-button class=\"jw-close\">❌</jw-button>\n    </jw-content>\n</jw-dialog>\n"

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = "<jw-editor>\n    <jw-header><t t-zone=\"tools\"/></jw-header>\n    <jw-body><t t-zone=\"main\"/></jw-body>\n    <jw-footer>\n        <t t-zone=\"status\"/>\n        <t t-zone=\"resizer\"/>\n    </jw-footer>\n    <t-dialog>\n        <t t-zone=\"dialog\"/>\n        <t t-zone=\"default\"/>\n    </t-dialog>\n    <t t-zone=\"debug\"/>\n</jw-editor>\n"

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = "<templates>\n    <!-- INSPECTOR -->\n    <devtools-panel class=\"inspector\" t-name=\"InspectorComponent\" t-att-class=\"{active: props.isOpen}\"\n        t-on-node-selected=\"selectNode\"\n        t-on-keydown=\"onKeydown\">\n        <devtools-contents t-if=\"props.isOpen\">\n            <devtools-mainpane>\n                <mainpane-contents>\n                    <devtools-tree>\n                        <TreeComponent\n                            vNode=\"domEngine.root\"\n                            isRoot=\"true\"\n                            selectedPath=\"getPath(selectedNode)\"\n                            selectedID=\"state.selectedID\"/>\n                    </devtools-tree>\n                </mainpane-contents>\n                <PathComponent\n                    path=\"getPath(selectedNode)\"\n                    selectedID=\"state.selectedID\"/>\n            </devtools-mainpane>\n            <devtools-sidepane>\n                <InfoComponent vNode=\"selectedNode\"/>\n            </devtools-sidepane>\n        </devtools-contents>\n    </devtools-panel>\n\n    <!-- INSPECTOR.Tree -->\n    <devtools-node t-name=\"TreeComponent\"\n        t-att-class=\"{\n            block: props.vNode.length and !props.vNode.char,\n            folded: state.folded,\n            root: props.isRoot,\n            'self-closing': !props.vNode.hasChildren(),\n        }\"\n        tabindex=\"1\"\n        t-on-keydown=\"onKeydown\"\n        t-on-node-selected=\"selectNode\">\n        <t t-if=\"props.isRoot\">\n            <devtools-nodename class=\"selectable-line block\"\n                t-on-click=\"onClickNode\" t-on-dblclick=\"onDblClickNode\"\n                t-att-class=\"{\n                    selected: props.selectedID == props.vNode.id,\n                }\">root</devtools-nodename>\n            <t t-call=\"treeChildren\"/>\n        </t>\n        <t t-else=\"\">\n            <devtools-nodename t-if=\"!props.vNode.tangible\"\n                t-on-click=\"onClickNode\" t-on-dblclick=\"onDblClickNode\"\n                class=\"selectable-line inline marker-node\" t-att-class=\"{\n                    selected: props.selectedID == props.vNode.id,\n                }\">\n                <b><t t-esc=\"repr()\"/></b>\n            </devtools-nodename>\n            <devtools-nodename t-elif=\"props.vNode.char\" t-on-click=\"onClickNode\"\n                t-on-dblclick=\"onDblClickNode\"\n                class=\"selectable-line inline\" t-att-class=\"{\n                    bold: isFormat(props.vNode, 'b'),\n                    italic: isFormat(props.vNode, 'i'),\n                    underline: isFormat(props.vNode, 'u'),\n                    link: isFormat(props.vNode, 'link'),\n                    subscript: isFormat(props.vNode, 'subscript'),\n                    superscript: isFormat(props.vNode, 'superscript'),\n                    selected: props.selectedID == props.vNode.id,\n                }\">\n                <t t-esc=\"repr()\"/>\n            </devtools-nodename>\n            <t t-else=\"\">\n                <devtools-nodename class=\"selectable-line block\" t-on-click=\"onClickNode\"\n                    t-on-dblclick=\"onDblClickNode\"\n                    t-att-class=\"{\n                        bold: isFormat(props.vNode, 'b'),\n                        italic: isFormat(props.vNode, 'i'),\n                        underline: isFormat(props.vNode, 'u'),\n                        link: isFormat(props.vNode, 'link'),\n                        subscript: isFormat(props.vNode, 'subscript'),\n                        superscript: isFormat(props.vNode, 'superscript'),\n                        selected: props.selectedID == props.vNode.id,\n                        'line-break': props.vNode.htmlTag === 'BR',\n                    }\">\n                    <t t-esc=\"repr()\"/>\n                </devtools-nodename>\n                <t t-call=\"treeChildren\"/>\n            </t>\n        </t>\n    </devtools-node>\n\n    <t t-name=\"treeChildren\">\n        <devtools-children>\n            <TreeComponent t-if=\"!state.folded\"\n                t-foreach=\"props.vNode.childVNodes.slice()\" t-as=\"child\"\n                t-key=\"child.id\"\n                vNode=\"child\"\n                selectedPath=\"props.selectedPath\"\n                selectedID=\"props.selectedID\"/>\n        </devtools-children>\n    </t>\n\n    <!-- INSPECTOR.Path -->\n    <devtools-path t-name=\"PathComponent\">\n        <devtools-pathnode t-foreach=\"props.path\" t-as=\"vNode\"\n            t-key=\"vNode.id\"\n            t-att-class=\"{\n                selected: vNode.id == props.selectedID\n            }\"\n            t-on-click=\"selectNode(vNode)\">\n            <t t-esc=\"getNodeRepr(vNode)\"/>\n        </devtools-pathnode>\n    </devtools-path>\n\n    <!-- INSPECTOR.Info -->\n    <devtools-info t-name=\"InfoComponent\">\n        <devtools-navbar>\n            <devtools-button t-on-click=\"openTab('vNode')\" t-att-class=\"{\n                selected: state.currentTab == 'vNode',\n            }\">VNode</devtools-button>\n            <devtools-button t-on-click=\"openTab('selection')\" t-att-class=\"{\n                selected: state.currentTab == 'selection',\n            }\">Selection</devtools-button>\n        </devtools-navbar>\n        <t t-call=\"infoVNode\" t-if=\"state.currentTab == 'vNode'\"/>\n        <t t-call=\"infoSelection\" t-if=\"state.currentTab == 'selection'\"/>\n    </devtools-info>\n\n    <!-- INSPECTOR.Info.vNode -->\n    <t t-name=\"infoVNode\">\n        <devtools-about>\n            <devtools-type><t t-esc=\"className(props.vNode)\"/></devtools-type> <t t-esc=\"props.vNode.name\"/>\n            <t t-if=\"props.vNode.char\">:\n                \"<t t-esc=\"props.vNode.char\"/>\"\n            </t>\n            <devtools-button class=\"logger\" t-on-click=\"logVNode(props.vNode)\">&gt;_</devtools-button>\n            <devtools-id><t t-esc=\"props.vNode.id\"/></devtools-id>\n        </devtools-about>\n        <devtools-properties>\n            <devtools-infotitle>👤 About me</devtools-infotitle>\n            <devtools-table>\n                <devtools-tbody>\n                    <devtools-tr t-foreach=\"aboutMeProps\" t-as=\"propName\" t-key=\"propName_index\">\n                        <devtools-td><t t-esc=\"propName\"/></devtools-td>\n                        <devtools-td><t t-esc=\"propRepr(props.vNode, propName)\"/></devtools-td>\n                    </devtools-tr>\n                    <devtools-tr>\n                        <devtools-td>total length</devtools-td>\n                        <devtools-td><t t-esc=\"totalLength(props.vNode)\"/></devtools-td>\n                    </devtools-tr>\n                    <devtools-tr>\n                        <devtools-td>text content</devtools-td>\n                        <devtools-td><t t-esc=\"props.vNode.textContent\"/></devtools-td>\n                    </devtools-tr>\n                </devtools-tbody>\n            </devtools-table>\n            <devtools-infotitle>📖 My Properties</devtools-infotitle>\n            <devtools-table>\n                <devtools-tbody>\n                    <devtools-tr t-foreach=\"nodeProperties(props.vNode)\" t-as=\"prop\" t-key=\"prop_index\">\n                        <devtools-td><t t-esc=\"prop.key\"/></devtools-td>\n                        <devtools-td><t t-esc=\"prop.value\"/></devtools-td>\n                    </devtools-tr>\n                </devtools-tbody>\n            </devtools-table>\n            <devtools-infotitle>👪 My Family</devtools-infotitle>\n            <devtools-table>\n                <devtools-tbody>\n                    <devtools-tr t-foreach=\"familyProps\" t-as=\"propName\"\n                    t-key=\"propName_index\">\n                        <devtools-td><t t-esc=\"propName\"/></devtools-td>\n                        <devtools-td t-if=\"propName === 'parent'\" t-on-click=\"selectNode(props.vNode.parent)\">\n                            <t t-esc=\"propRepr(props.vNode, propName)\"/>\n                        </devtools-td>\n                        <devtools-td t-elif=\"propName === 'siblings'\">\n                            <devtools-list>\n                                <devtools-listitem t-if=\"props.vNode.previousSibling()\"\n                                    t-on-click=\"selectNode(props.vNode.previousSibling())\">\n                                    previous: <t t-esc=\"props.vNode.previousSibling().name\"/>\n                                </devtools-listitem>\n                                <devtools-listitem t-else=\"\">previous: none</devtools-listitem>\n                                <devtools-listitem t-if=\"props.vNode.nextSibling()\"\n                                    t-on-click=\"selectNode(props.vNode.nextSibling())\">\n                                    next: <t t-esc=\"props.vNode.nextSibling().name\"/>\n                                </devtools-listitem>\n                                <devtools-listitem t-else=\"\">next: none</devtools-listitem>\n                            </devtools-list>\n                        </devtools-td>\n                        <devtools-td t-elif=\"propName === 'children'\">\n                            <devtools-list t-if=\"props.vNode.childVNodes.length\">\n                                <devtools-listitem t-foreach=\"props.vNode.children()\"\n                                    t-as=\"child\" t-key=\"child.id\"\n                                    t-on-click=\"selectNode(child)\">\n                                    <t t-esc=\"child.name\"/>\n                                </devtools-listitem>\n                            </devtools-list>\n                            <t t-else=\"\">none</t>\n                        </devtools-td>\n                        <devtools-td t-else=\"\"><t t-esc=\"propRepr(props.vNode, propName)\"/></devtools-td>\n                    </devtools-tr>\n                </devtools-tbody>\n            </devtools-table>\n        </devtools-properties>\n    </t>\n\n    <!-- INSPECTOR.Info.selection -->\n    <t t-name=\"infoSelection\">\n        <devtools-about>\n            <devtools-type>VSelection</devtools-type> Selection\n        </devtools-about>\n        <devtools-properties>\n            <devtools-infotitle>👤 About me</devtools-infotitle>\n            <devtools-table>\n                <devtools-tbody>\n                    <devtools-tr>\n                        <devtools-td>direction</devtools-td>\n                        <devtools-td><t t-esc=\"env.editor.selection.direction\"/></devtools-td>\n                    </devtools-tr>\n                    <devtools-tr>\n                        <devtools-td><strong class=\"marker-node\">[</strong> anchor</devtools-td>\n                        <devtools-td><t t-esc=\"_repr(env.editor.selection.anchor)\"/></devtools-td>\n                    </devtools-tr>\n                    <devtools-tr>\n                        <devtools-td><strong class=\"marker-node\">]</strong> focus</devtools-td>\n                        <devtools-td><t t-esc=\"_repr(env.editor.selection.focus)\"/></devtools-td>\n                    </devtools-tr>\n                </devtools-tbody>\n            </devtools-table>\n        </devtools-properties>\n    </t>\n\n    <devtools-panel t-name=\"CommandsComponent\"\n        t-att-class=\"{active: props.isOpen}\" tabindex=\"1\"\n        t-on-keydown=\"onKeydown\">\n        <devtools-contents t-if=\"props.isOpen\">\n            <t t-set=\"selectedCommandImplementations\" t-value=\"state.registry[state.selectedCommandIdentifier]\"/>\n            <devtools-mainpane style=\"overflow: hidden\">\n                <devtools-navbar>\n                    <devtools-button t-on-click=\"openTab('queue')\" t-att-class=\"{\n                        selected: state.currentTab == 'queue',\n                    }\">Queue</devtools-button>\n                    <devtools-button t-on-click=\"openTab('registry')\" t-att-class=\"{\n                        selected: state.currentTab == 'registry',\n                    }\">Registry</devtools-button>\n                </devtools-navbar>\n                <mainpane-contents t-if=\"state.currentTab == 'queue'\" style=\"overflow: auto\">\n                    <devtools-table style=\"width: 100%;\">\n                        <devtools-tbody>\n                            <devtools-tr t-foreach=\"Array.from(props.commands.keys()).reverse()\" t-as=\"commandIndex\"\n                                t-key=\"commandIndex_index\" class=\"selectable-line\"\n                                t-att-class=\"{\n                                    selected: state.selectedCommandIndex == commandIndex,\n                                }\"\n                                t-on-click=\"selectCommandByIndex(commandIndex)\">\n                                <devtools-td class=\"numbering\"><t t-esc=\"commandIndex + 1\"/></devtools-td>\n                                <devtools-td><t t-esc=\"props.commands[commandIndex][0]\"/></devtools-td>\n                            </devtools-tr>\n                        </devtools-tbody>\n                    </devtools-table>\n                </mainpane-contents>\n                <mainpane-contents t-elif=\"state.currentTab == 'registry'\" style=\"overflow: auto\">\n                    <devtools-command t-foreach=\"Object.keys(state.registry).sort()\" t-as=\"commandIdentifier\"\n                        t-key=\"record_index\" class=\"selectable-line\"\n                        t-att-class=\"{\n                            selected: state.selectedCommandIdentifier == commandIdentifier,\n                        }\"\n                        t-on-click=\"selectCommand(commandIdentifier)\">\n                        <t t-esc=\"commandIdentifier\"/>\n                    </devtools-command>\n                </mainpane-contents>\n            </devtools-mainpane>\n            <devtools-sidepane>\n                <devtools-info t-if=\"state.currentTab == 'queue'\">\n                    <t t-set=\"selectedCommand\" t-value=\"props.commands[state.selectedCommandIndex]\"/>\n                    <devtools-about t-if=\"selectedCommand\">\n                        <devtools-type>Command</devtools-type> <t t-esc=\"selectedCommand[0]\"/>\n                    </devtools-about>\n                    <devtools-properties t-if=\"selectedCommand\">\n                        <devtools-infotitle>Arguments</devtools-infotitle>\n                        <devtools-properties>\n                            <t t-if=\"selectedCommand\">\n                                <t t-set=\"payload\" t-value=\"selectedCommand[1]\"/>\n                                <t t-call=\"commandArgs\"/>\n                            </t>\n                            <t t-call=\"selectedCommandTable\"/>\n                        </devtools-properties>\n                    </devtools-properties>\n                </devtools-info>\n                <devtools-info t-elif=\"state.currentTab == 'registry'\">\n                    <t t-if=\"state.registry\">\n                        <devtools-about t-if=\"state.selectedCommandIdentifier\">\n                            <devtools-type>Command</devtools-type> <t t-esc=\"state.selectedCommandIdentifier\"/>\n                        </devtools-about>\n                        <devtools-properties t-if=\"state.selectedCommandIdentifier\">\n                            <t t-call=\"selectedCommandTable\"/>\n                        </devtools-properties>\n                    </t>\n                </devtools-info>\n            </devtools-sidepane>\n        </devtools-contents>\n    </devtools-panel>\n\n    <t t-name=\"commandArgs\">\n        <devtools-table t-if=\"payload\">\n            <devtools-tbody>\n                <t t-foreach=\"Object.keys(payload)\" t-as=\"key\" t-key=\"key_index\">\n                    <devtools-tr t-if=\"key !== 'context'\">\n                        <t t-set=\"value\" t-value=\"payload[key]\"/>\n                        <devtools-td>\n                            <t t-esc=\"key\"/>\n                        </devtools-td>\n                        <devtools-td>\n                            <t t-if=\"value and key == 'vSelection'\" t-call=\"payloadVSelection\"/>\n                            <t t-else=\"\"><t t-esc=\"formatPayloadValue(value)\"/></t>\n                        </devtools-td>\n                    </devtools-tr>\n                </t>\n            </devtools-tbody>\n        </devtools-table>\n        <p t-else=\"\">None</p>\n    </t>\n\n    <t t-name=\"payloadVSelection\">\n        <devtools-table>\n            <devtools-tbody>\n                <devtools-tr>\n                    <devtools-td>\n                        direction\n                    </devtools-td>\n                    <devtools-td>\n                        <t t-esc=\"value.direction or 'unset'\"/>\n                    </devtools-td>\n                </devtools-tr>\n                <devtools-tr>\n                    <devtools-td>\n                        anchor\n                    </devtools-td>\n                    <devtools-td>\n                        <t t-esc=\"value.anchorPosition\"/> <t t-esc=\"value.anchorNode.id\"/> (<t t-esc=\"value.anchorNode.name\"/>)\n                    </devtools-td>\n                </devtools-tr>\n                <devtools-tr>\n                    <devtools-td>\n                        focus\n                    </devtools-td>\n                    <devtools-td>\n                        <t t-esc=\"value.focusPosition\"/> <t t-esc=\"value.focusNode.id\"/> (<t t-esc=\"value.focusNode.name\"/>)\n                    </devtools-td>\n                </devtools-tr>\n            </devtools-tbody>\n        </devtools-table>\n    </t>\n\n    <t t-name=\"selectedCommandTable\">\n        <devtools-infotitle>Command definitions</devtools-infotitle>\n        <devtools-table t-if=\"selectedCommandImplementations\">\n            <devtools-tbody>\n                <devtools-tr t-foreach=\"selectedCommandImplementations\"\n                    t-as=\"selectedCommandImplementation\" t-key=\"selectedCommandImplementation_index\"\n                    class=\"selectable-line\"\n                    t-att-class=\"{\n                        selected: state.selectedCommandImplementationIndex == handlerIndex,\n                    }\">\n                    <devtools-td><t t-esc=\"selectedCommandImplementation.handler.name\"/></devtools-td>\n                    <devtools-td><t t-esc=\"selectedCommandImplementation.handler\"/></devtools-td>\n                </devtools-tr>\n            </devtools-tbody>\n        </devtools-table>\n        <p t-else=\"\">None</p>\n        <t t-set=\"mappings\" t-value=\"matchingMappings(state.selectedCommandIdentifier)\"/>\n        <t t-if=\"mappings.length\">\n            <devtools-infotitle>Shortcuts</devtools-infotitle>\n            <devtools-table>\n                <devtools-tbody>\n                    <devtools-tr t-foreach=\"mappings\" t-as=\"mapping\" t-key=\"mapping_index\">\n                        <devtools-td style=\"width: 50%;\"><t t-esc=\"stringifyPattern(mapping.pattern)\"/></devtools-td>\n                        <devtools-td><t t-esc=\"argsRepr(mapping.configuredCommand.commandArgs)\"/></devtools-td>\n                    </devtools-tr>\n                </devtools-tbody>\n            </devtools-table>\n        </t>\n    </t>\n\n    <!-- SHORTCUTS -->\n    <devtools-panel t-name=\"ShortcutsComponent\"\n        t-att-class=\"{active: props.isOpen}\" tabindex=\"1\"\n        t-on-keydown=\"onKeydown\">\n        <devtools-contents t-if=\"props.isOpen\">\n            <devtools-mainpane style=\"overflow: hidden\">\n                <mainpane-contents style=\"overflow: auto\">\n                    <devtools-table>\n                        <devtools-tr t-foreach=\"mappings\" t-as=\"mapping\" t-key=\"mapping_index\" class=\"selectable-line\">\n                            <devtools-td><t t-esc=\"stringifyPattern(mapping.pattern)\"/></devtools-td>\n                            <devtools-td><t t-esc=\"mapping.configuredCommand.commandId\"/></devtools-td>\n                            <devtools-td><t t-esc=\"argsRepr(mapping.configuredCommand.commandArgs)\"/></devtools-td>\n                        </devtools-tr>\n                    </devtools-table>\n                </mainpane-contents>\n            </devtools-mainpane>\n        </devtools-contents>\n    </devtools-panel>\n\n    <!-- PLUGINS -->\n    <devtools-panel t-name=\"PluginsComponent\"\n        t-att-class=\"{active: props.isOpen}\" tabindex=\"1\">\n        <devtools-contents t-if=\"props.isOpen\">\n            <devtools-mainpane style=\"overflow: hidden\">\n                <mainpane-contents style=\"overflow: auto\">\n                    <devtools-table>\n                        <devtools-tr t-foreach=\"plugins\" t-as=\"plugin\" t-key=\"plugin_index\" class=\"selectable-line\">\n                            <devtools-td><t t-esc=\"plugin\"/></devtools-td>\n                        </devtools-tr>\n                    </devtools-table>\n                </mainpane-contents>\n            </devtools-mainpane>\n        </devtools-contents>\n    </devtools-panel>\n\n    <!-- MODES -->\n    <devtools-panel t-name=\"ModesComponent\"\n        t-att-class=\"{active: props.isOpen}\" tabindex=\"1\"\n        t-on-keydown=\"onKeydown\">\n        <devtools-contents t-if=\"props.isOpen\">\n            <devtools-mainpane style=\"overflow: hidden\">\n                <mainpane-contents style=\"overflow: auto\">\n                    <devtools-table>\n                        <devtools-tr t-foreach=\"Object.values(modes)\"\n                            t-as=\"mode\" t-key=\"mode.id\"\n                            class=\"selectable-line\"\n                            t-att-class=\"{\n                                selected: state.selectedMode and state.selectedMode.id == mode.id,\n                            }\"\n                            t-on-click=\"selectMode(mode.id)\"\n                            t-on-dblclick=\"setMode(mode.id)\">\n                            <devtools-td><t t-if=\"mode.id == state.currentMode.id\">✅</t> <t t-esc=\"mode.id\"/></devtools-td>\n                        </devtools-tr>\n                    </devtools-table>\n                </mainpane-contents>\n            </devtools-mainpane>\n            <devtools-sidepane>\n                <devtools-info>\n                    <devtools-about t-if=\"state.selectedMode\">\n                        <devtools-type>Mode</devtools-type> <t t-esc=\"state.selectedMode.id\"/>\n                    </devtools-about>\n                    <devtools-properties t-if=\"state.selectedMode\">\n                        <devtools-infotitle>📖 Rules</devtools-infotitle>\n                        <t t-if=\"state.selectedMode\">\n                            <devtools-table>\n                                <devtools-tbody>\n                                    <devtools-tr\n                                    t-foreach=\"state.selectedMode.rules\"\n                                    t-as=\"rule\" t-key=\"rule.id\"\n                                    class=\"selectable-line\">\n                                        <devtools-td>\n                                            <devtools-list>\n                                                <devtools-listitem>Selector: <devtools-button t-on-click=\"logSelector(rule.selector)\">&gt;_</devtools-button></devtools-listitem>\n                                                <devtools-listitem t-foreach=\"Object.keys(rule.properties)\"\n                                                t-as=\"property\"\n                                                t-key=\"property_id\">\n                                                    <t t-esc=\"property\"/>: <t t-esc=\"rule.properties[property].value\"/>\n                                                    <t t-if=\"rule.properties[property].cascading\"> (cascading)</t>\n                                                    <t t-else=\"\"> (targeted)</t>\n                                                </devtools-listitem>\n                                            </devtools-list>\n                                        </devtools-td>\n                                    </devtools-tr>\n                                </devtools-tbody>\n                            </devtools-table>\n                        </t>\n                    </devtools-properties>\n                </devtools-info>\n            </devtools-sidepane>\n        </devtools-contents>\n    </devtools-panel>\n\n    <!-- MAIN -->\n    <jw-devtools t-name=\"devtools\"\n        t-att-class=\"{\n            closed: state.closed,\n        }\"\n        t-attf-style=\"height: {{state.height}}px\"\n        tabindex=\"2\">\n        <devtools-navbar\n            t-on-click=\"toggleClosed\"\n            t-on-mousedown=\"startResize\"\n            t-on-touchstart=\"startResize\">\n            <devtools-button t-on-click=\"openTab('inspector')\" t-att-class=\"{\n                selected: state.currentTab == 'inspector',\n            }\">Inspector</devtools-button>\n            <devtools-button t-on-click=\"openTab('commands')\" t-att-class=\"{\n                selected: state.currentTab == 'commands',\n            }\">Commands</devtools-button>\n            <devtools-button t-on-click=\"openTab('shortcuts')\" t-att-class=\"{\n                selected: state.currentTab == 'shortcuts',\n            }\">Shortcuts</devtools-button>\n            <devtools-button t-on-click=\"openTab('plugins')\" t-att-class=\"{\n                selected: state.currentTab == 'plugins',\n            }\">Plugins</devtools-button>\n            <devtools-button t-on-click=\"openTab('modes')\" t-att-class=\"{\n                selected: state.currentTab == 'modes',\n            }\">Modes</devtools-button>\n            <devtools-button t-on-click=\"inspectDom()\">&#128269;</devtools-button>\n        </devtools-navbar>\n        <t t-if=\"!state.closed\">\n            <InspectorComponent isOpen=\"state.currentTab == 'inspector'\" t-ref=\"inspector\"/>\n            <CommandsComponent isOpen=\"state.currentTab == 'commands'\"\n                commands=\"state.commands\"/>\n            <ShortcutsComponent isOpen=\"state.currentTab == 'shortcuts'\"/>\n            <PluginsComponent isOpen=\"state.currentTab == 'plugins'\"/>\n            <ModesComponent isOpen=\"state.currentTab == 'modes'\"/>\n        </t>\n    </jw-devtools>\n\n</templates>\n"

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(8);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "ul.checklist > li {\n    list-style: none;\n    position: relative;\n}\nul.checklist > li.unchecked:before, ul.checklist > li.checked:before {\n    content: '';\n    position: absolute;\n    left: -20px;\n    display: block;\n    height: 13px;\n    width: 13px;\n    border: 1px solid;\n    cursor: pointer;\n}\nul.checklist > li:after {\n    content: '';\n    position: absolute;\n    left: -17px;\n    top: -1px;\n    font-size: 13px;\n    opacity: 0;\n    cursor: pointer;\n}\nul.checklist > li.checked:after {\n    content: \"✓\";\n    transition: opacity .5s;\n    opacity: 1;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(10);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "table.table-picker {\n    position: absolute;\n    background-color: white;\n    border: 1px solid black;\n    -webkit-box-shadow: 2px 2px 5px 0px rgba(0,0,0,.4);\n    -moz-box-shadow: 2px 2px 5px 0px rgba(0,0,0,.4);\n    box-shadow: 2px 2px 5px 0px rgba(0,0,0,.4);\n}\ntable.table-picker tr {\n    height: 1em;\n    padding: 0;\n}\ntable.table-picker td {\n    width: 1em;\n    border: 1px solid black;\n    padding: 0;\n}\ntable.table-picker td.highlight {\n    background-color: #875A7B;\n}\n\nspan.table-handler.fa-plus-square {\n    position: absolute;\n    cursor: pointer;\n    background-color: white;\n    width: 1em;\n    color: #00FF00;\n}\nspan.table-handler.fa-minus-square {\n    position: absolute;\n    cursor: pointer;\n    background-color: white;\n    width: 1em;\n    color: #FF0000;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(12);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "jw-dialog-container {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\njw-dialog-container jw-backdrop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    opacity: 0.5;\n    background-color: #000000;\n}\njw-dialog-container jw-dialog {\n    position: absolute;\n    display: flex;\n    max-width: 80%;\n}\njw-dialog-container jw-dialog > jw-content {\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    background-color: #F7F7F7;\n    padding: 10px;\n    border-radius: 10px;\n}\njw-dialog-container jw-dialog > jw-content > jw-button.close {\n    position: absolute;\n    right: 10px;\n    top: 4px;\n    cursor: pointer;\n}\njw-dialog-container jw-dialog table.form-table {\n    border: none;\n}\njw-dialog-container jw-dialog table.form-table td {\n    border: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(14);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "jw-follow-range {\n    position: absolute;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(16);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "jw-editor {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(18);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".jw-fullscreen .jw-fullscreen {\n    display: block;\n    position: fixed;\n    transform: none;\n    overflow: hidden;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    min-height: 100%;\n    background: #ffffff;\n}\n.jw-fullscreen jw-follow-range {\n    z-index: 1;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(20);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* GLOBAL */\n\njw-devtools {\n    position: sticky;\n    position: -webkit-sticky;\n    bottom: 0;\n    min-height: 30px;\n    max-height: 100%;\n    top: auto;\n    background-color: white;\n    border-top: 1px solid #d0d0d0;\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    user-select: none;\n    outline: none;\n}\n\ndevtools-table {\n    display: table;\n    width: 100%\n}\ndevtools-tbody {\n    display: table-row-group;\n}\ndevtools-tr {\n    display: table-row;\n}\ndevtools-td {\n    display: table-cell;\n    padding-right: 25px;\n}\ndevtools-button {\n    display: inline;\n    text-align: center;\n    align-items: flex-start;\n    box-sizing: border-box;\n    line-height: 2em;\n    font-family: initial;\n}\ndevtools-list {\n    display: block;\n    list-style: none;\n}\ndevtools-listitem {\n    display: list-item;\n}\n\njw-devtools.closed {\n    max-height: 31px;\n}\n\njw-devtools .bold {\n    font-weight: bold;\n}\n\njw-devtools .italic {\n    font-style: italic;\n}\n\njw-devtools .underline {\n    text-decoration: underline;\n}\n\njw-devtools .link {\n    text-decoration: underline;\n    color: blue;\n}\n\njw-devtools .subscript {\n    vertical-align: sub;\n    font-size: 0.7em;\n}\n\njw-devtools .superscript {\n    vertical-align: super;\n    font-size: 0.7em;\n}\n\njw-devtools .marker-node {\n    color: red;\n}\n\ndevtools-panel {\n    display: flex;\n    overflow: auto;\n}\n\ndevtools-panel:not(.active) {\n    display: none;\n}\n\ndevtools-panel .selectable-line:hover {\n    background-color: rgba(118, 82, 108, 0.2);\n}\n\ndevtools-panel .selectable-line.selected {\n    background-color: rgba(118, 82, 108, 0.3);\n}\n\ndevtools-panel devtools-button.logger {\n    float: right;\n    border: none;\n    background-color: transparent;\n    color: #666666;\n    padding: 0;\n    margin: 0;\n    display: none;\n    line-height: 0.7em;\n}\n\ndevtools-panel devtools-about > devtools-button.logger {\n    display: inline;\n    margin-left: 1em;\n}\n\ndevtools-panel .selectable-line:hover devtools-button.logger, devtools-panel .selected devtools-button.logger {\n    display: inline;\n}\n\n/* NAVBAR */\n\njw-devtools:not(.closed) > devtools-navbar {\n    cursor: row-resize;\n}\n\ndevtools-navbar {\n    background-color: #f3f3f3;\n    position: relative;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    height: 30px;\n    min-height: 30px;\n    width: 100%;\n    align-items: center;\n    border: 0;\n    border-bottom: 1px solid #d0d0d0;\n    box-sizing: border-box;\n    vertical-align: baseline;\n}\n\ndevtools-navbar > devtools-button {\n    padding: 0 10px 0 10px;\n    background: none;\n    border: 0;\n    vertical-align: middle;\n    outline: none;\n    cursor: auto;\n}\n\ndevtools-navbar > devtools-button:hover {\n    background-color: #d6d6d6;\n}\n\ndevtools-navbar > devtools-button.selected {\n    border-bottom: solid 2px #76526c;\n}\n\n/* CONTENTS */\n\ndevtools-contents {\n    display: flex;\n    flex-direction: row;\n    flex: 1;\n    overflow: auto;\n    position: relative;\n    font-family: 'Courier New', Courier, monospace;\n}\n\n/* mainpane */\n\ndevtools-mainpane {\n    display: flex;\n    overflow: auto;\n    flex-direction: column;\n    width: 100%;\n}\n\nmainpane-contents {\n    overflow: auto;\n    flex: 1;\n    padding: 1em;\n}\n\ndevtools-command {\n    display: block;\n}\n\ndevtools-td.numbering {\n    color: grey;\n}\n\n\n/* tree */\n\ndevtools-tree {\n    display: block;\n    flex-grow: 1;\n    width: 100%;\n}\n\ndevtools-tree devtools-children {\n    display: block;\n    position: relative;\n    box-sizing: border-box;\n    padding: 1px 0 1px 1.5em;\n    border-left: 1px solid #d0d0d0;\n}\n\ndevtools-tree div {\n    width: 100%;\n}\n\ndevtools-tree > devtools-node.root > devtools-nodename {\n    background-color: #76526c;\n    color: white;\n    padding-left: 5px;\n    box-sizing: border-box;\n}\n\njw-devtools devtools-nodename.inline {\n    display: inline;\n}\n\ndevtools-tree devtools-nodename.block {\n    color: #76526c;\n    width: 100%;\n    display: inline-block;\n}\n\ndevtools-tree devtools-nodename.line-break:after {\n    content: '\\A';\n    white-space: pre;\n}\n\ndevtools-node {\n    outline: none;\n}\n\ndevtools-node:not(.folded):not(.self-closing):not(.root) > devtools-nodename.block:before {\n    content: '⌄ ';\n}\n\ndevtools-node.folded:not(.self-closing) > devtools-nodename.block:before {\n    content: '› ';\n}\n\ndevtools-node.folded devtools-children {\n    display: none;\n}\n\ndevtools-path {\n    display: block;\n    border-top: 1px solid #d0d0d0;\n    background-color: #dddddd;\n    bottom: 0;\n    left: 0;\n    right: 0;\n}\n\ndevtools-pathnode {\n    display: inline-block;\n    padding: .2em 1em .2em 1em;\n    color: #696969;\n    font-size: 13px;\n}\n\ndevtools-pathnode:hover {\n    background-color: #d6d6d6;\n}\n\ndevtools-pathnode.selected {\n    background-color: #d0d0d0;\n}\n\n/* sidepane */\n\ndevtools-sidepane {\n    position: relative;\n    overflow: auto;\n    display: block;\n    font-size: 15px;\n    box-sizing: border-box;\n    width: 30%;\n    background-color: white;\n    border-left: 1px solid #d0d0d0;\n}\n\ndevtools-sidepane devtools-about {\n    border-bottom: 1px solid #d0d0d0;\n    padding: 10px;\n}\n\ndevtools-sidepane devtools-about devtools-type {\n    font-family: initial;\n    font-style: italic;\n    font-size: smaller;\n    color: #76526c;\n    padding-right: .5em;\n}\n\ndevtools-sidepane devtools-properties {\n    font-size: 12px;\n    padding: 10px;\n    overflow: auto;\n    margin-bottom: 30px;\n}\n\ndevtools-infotitle {\n    display: block;\n}\n\ndevtools-sidepane devtools-properties devtools-infotitle {\n    padding: 1em;\n    font-family: initial;\n    font-size: larger;\n    color: #382034;\n}\n\ndevtools-sidepane devtools-properties devtools-infotitle:first-child {\n    padding-top: 0em;\n}\n\ndevtools-sidepane devtools-properties devtools-table {\n    width: 100%;\n    font-size: inherit;\n}\n\ndevtools-sidepane devtools-properties devtools-table devtools-tbody{\n    vertical-align: top;\n}\n\ndevtools-sidepane devtools-properties devtools-table devtools-td {\n    padding: 0.3em;\n}\n\ndevtools-sidepane devtools-properties devtools-table devtools-td:nth-child(1) {\n    width: 100px;\n}\n\ndevtools-sidepane devtools-properties devtools-table devtools-list {\n    list-style-position: inside;\n    padding-left: 0;\n    margin: 0;\n}\n\ndevtools-sidepane devtools-properties > devtools-table > devtools-tbody > devtools-tr:nth-child(even) {\n    background-color: #f4f4f4;\n}\n\ndevtools-info {\n    display: flex;\n    flex-direction: column;\n}\n\ndevtools-info devtools-about devtools-id {\n    float: right;\n    color: #76526c;\n    font-size: smaller;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(1);
            var content = __webpack_require__(22);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "jw-editor {\n    display: flex;\n    flex-direction: column;\n}\n\n.jw-dropdown {\n    display: inline-block;\n}\n.jw-dropdown .dropdown-menu {\n    min-width: 250px;\n    border: 1px solid #000;\n    background-color: #141217;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "OdooWebsiteEditor", function() { return /* reexport */ OdooWebsiteEditor_OdooWebsiteEditor; });
__webpack_require__.d(__webpack_exports__, "BasicEditor", function() { return /* reexport */ BasicEditor_BasicEditor; });
__webpack_require__.d(__webpack_exports__, "DevTools", function() { return /* reexport */ DevTools_DevTools; });
__webpack_require__.d(__webpack_exports__, "Layout", function() { return /* reexport */ Layout_Layout; });
__webpack_require__.d(__webpack_exports__, "DomLayoutEngine", function() { return /* reexport */ DomLayoutEngine_DomLayoutEngine; });
__webpack_require__.d(__webpack_exports__, "Renderer", function() { return /* reexport */ Renderer_Renderer; });
__webpack_require__.d(__webpack_exports__, "ImageNode", function() { return /* reexport */ ImageNode_ImageNode; });
__webpack_require__.d(__webpack_exports__, "VRange", function() { return /* reexport */ VRange_VRange; });
__webpack_require__.d(__webpack_exports__, "InlineNode", function() { return /* reexport */ InlineNode_InlineNode; });
__webpack_require__.d(__webpack_exports__, "LinkFormat", function() { return /* reexport */ LinkFormat_LinkFormat; });
__webpack_require__.d(__webpack_exports__, "Attributes", function() { return /* reexport */ Attributes_Attributes; });
__webpack_require__.d(__webpack_exports__, "ContainerNode", function() { return /* reexport */ ContainerNode_ContainerNode; });
__webpack_require__.d(__webpack_exports__, "VElement", function() { return /* reexport */ VElement_VElement; });
__webpack_require__.d(__webpack_exports__, "DividerNode", function() { return /* reexport */ DividerNode_DividerNode; });
__webpack_require__.d(__webpack_exports__, "OdooStructureNode", function() { return /* reexport */ OdooStructureNode_OdooStructureNode; });
__webpack_require__.d(__webpack_exports__, "OdooField", function() { return /* reexport */ OdooField_OdooField; });
__webpack_require__.d(__webpack_exports__, "OdooFieldNode", function() { return /* reexport */ OdooFieldNode_OdooFieldNode; });
__webpack_require__.d(__webpack_exports__, "OdooTranslationFormat", function() { return /* reexport */ OdooTranslationFormat_OdooTranslationFormat; });
__webpack_require__.d(__webpack_exports__, "Inline", function() { return /* reexport */ Inline_Inline; });
__webpack_require__.d(__webpack_exports__, "DomHelpers", function() { return /* reexport */ DomHelpers_DomHelpers; });

// CONCATENATED MODULE: ./packages/core/src/Dispatcher.ts
class Dispatcher {
    constructor(editor) {
        this.__nextHandlerTokenID = 0;
        this.commands = {};
        this.commandHooks = {};
        this.editor = editor;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Call all hooks registred for the command `id`.
     *
     * @param commandId The identifier of the command.
     * @param params The parameters of the command.
     */
    async dispatch(commandId, params = {}) {
        const commands = this.commands[commandId];
        if (!commands) {
            console.warn(`Command '${commandId}' not found.`);
            return;
        }
        const [command, context] = this.editor.contextManager.match(commands, params.context);
        if (command) {
            // Update command arguments with the computed execution context.
            const args = Object.assign(Object.assign({}, params), { context });
            // Call command handler.
            const result = await command.handler(args);
            await this.dispatchHooks(commandId, args);
            return result;
        }
    }
    /**
     * Register all handlers declared in a plugin, and match them with their
     * corresponding command.
     *
     */
    registerCommand(id, impl) {
        if (!this.commands[id]) {
            this.commands[id] = [impl];
        }
        else {
            this.commands[id].push(impl);
        }
    }
    /**
     * Register a callback that will be executed for each `execCommand` call.
     *
     * @param id The identifier of the command to hook.
     * @param hook The callback that will be executed.
     */
    registerCommandHook(id, hook) {
        if (!this.commandHooks[id]) {
            this.commandHooks[id] = [];
        }
        this.commandHooks[id].push(hook);
    }
    /**
     * Remove a callback that will be executed for each `execCommand` call.
     *
     * @param id The identifier of the command to hook.
     * @param hook The callback that will be removed.
     */
    removeCommandHook(id, hook) {
        if (this.commandHooks[id]) {
            const index = this.commandHooks[id].indexOf(hook);
            if (index !== -1) {
                this.commandHooks[id].splice(index, 1);
            }
        }
    }
    /**
     * Dispatch to all registred `commandHooks`.
     */
    async dispatchHooks(signal, args) {
        const hooks = this.commandHooks[signal] || [];
        const globalHooks = this.commandHooks['*'] || [];
        for (const hookCallback of [...hooks, ...globalHooks]) {
            await hookCallback(args, signal);
        }
    }
}

// CONCATENATED MODULE: ./packages/core/src/JWPlugin.ts
class JWPlugin {
    constructor(editor, configuration = {}) {
        this.editor = editor;
        this.configuration = configuration;
        this.dependencies = new Map();
        this.loaders = {};
        this.loadables = {};
        this.commands = {};
        this.commandHooks = {};
        // Populate instantiated dependencies.
        for (const Dependency of this.constructor.dependencies) {
            this.dependencies.set(Dependency, editor.plugins.get(Dependency));
        }
    }
    /**
     * Start the plugin. Called when the editor starts.
     */
    async start() {
        // This is where plugins can do asynchronous work when the editor is
        // starting (e.g. retrieve data from a server, render stuff, etc).
    }
    /**
     * Stop the plugin. Called when the editor stops.
     */
    async stop() {
        // This is where plugins can do asynchronous work when the editor is
        // stopping (e.g. save on a server, close connections, etc).
        this.dependencies.clear();
        this.editor = null;
    }
}
JWPlugin.dependencies = [];

// CONCATENATED MODULE: ./packages/core/src/VNodes/VNode.ts
var RelativePosition;
(function (RelativePosition) {
    RelativePosition["BEFORE"] = "BEFORE";
    RelativePosition["AFTER"] = "AFTER";
    RelativePosition["INSIDE"] = "INSIDE";
})(RelativePosition || (RelativePosition = {}));
/**
 * Return true if the given node is a leaf in the VDocument, that is a node that
 * has no children.
 *
 * @param node node to check
 */
function isLeaf(node) {
    return !node.hasChildren();
}

// CONCATENATED MODULE: ./packages/core/src/ContextManager.ts
/**
 * Class that rank a hierarchy of vnode through a "specificity" algorithm.
 *
 * Specificity level is defined with:
 * - `lvl2`: if the last predicate of an item selector is deeper in the tree
 *   than the last predicate of another item selector; the first item have
 *   more specificity
 * - `lvl1`: if two or more items have the same `lvl2` specificity; the
 *   command with the longest selector will have more specificity
 * - `lvl0`: if the item has no selector (an empty list), there is no
 *   specificity
 * ```
 */
class ContextManager {
    constructor(editor, execCommand) {
        this.editor = editor;
        this.defaultContext = {
            range: this.editor.selection.range,
            execCommand: execCommand,
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Test all contextuals against a hierarchy of VNodes and return the result
     * ordered by specificity.
     */
    static getRankedMatches(hierarchy, contextuals) {
        const matches = [];
        for (let index = 0; index < contextuals.length; index++) {
            const contextual = contextuals[index];
            const match = ContextManager._matchNodes(hierarchy, contextual.selector);
            if (match) {
                matches.push({
                    lvl1Score: match[1].length,
                    lvl2Score: match[0],
                    matched: match[1],
                    index: index,
                    entry: contextual,
                });
            }
        }
        // Sort the matches:
        // - from highest to lowest score
        // - when the score is the same, from highest to lowest index
        const rankedMatch = matches.sort(function (a, b) {
            if (b.lvl2Score === a.lvl2Score && b.lvl1Score === a.lvl1Score) {
                return b.index - a.index;
            }
            else if (b.lvl2Score === a.lvl2Score) {
                return b.lvl1Score - a.lvl1Score;
            }
            else {
                return b.lvl2Score - a.lvl2Score;
            }
        });
        return rankedMatch;
    }
    /**
     * Match items selector depending on the editor current context range and
     * return the most specific item.
     *
     * @param items
     * @param paramsContext
     */
    match(items, paramsContext) {
        const context = Object.assign(Object.assign({}, this.defaultContext), paramsContext);
        const start = context.range.start;
        const hierarchy = start.ancestors();
        const node = start.previousSibling() || start.nextSibling();
        if (node) {
            hierarchy.unshift(node);
        }
        const entries = items.map(item => {
            const entry = {
                selector: item.selector || [],
                value: item,
            };
            return entry;
        });
        const matches = ContextManager.getRankedMatches(hierarchy, entries);
        const match = matches.find(match => {
            return (!match.entry.value.check ||
                match.entry.value.check(Object.assign(Object.assign({}, context), { selector: match.matched })));
        });
        return [match === null || match === void 0 ? void 0 : match.entry.value, context];
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Check whether a hierarchy of `VNode` match with `selector`.
     *
     * The `hierarchy` is an array from the deepest node in a tree to the
     * shallowest.
     *
     * Return a tuple with the first value being level of specificity lvl2 and
     * the second value being the VNnode that matched with a selector
     * (specificity lvl1).
     */
    static _matchNodes(hierarchy, selector) {
        const matches = [];
        const maximumDepth = hierarchy.length - 1;
        let firstMatchDepth = -1;
        let index = 0;
        for (const predicate of [...selector].reverse()) {
            let matchFound = false;
            while (!matchFound && index < hierarchy.length) {
                if (hierarchy[index].test(predicate)) {
                    matchFound = true;
                    matches.unshift(hierarchy[index]);
                    if (firstMatchDepth === -1) {
                        // Deeper match has higher specificity. So lower
                        // index in ancestors, means higher specificity.
                        firstMatchDepth = maximumDepth - index;
                    }
                }
                index++;
            }
            // Stop checking the predicates of this particular command
            // since at least one of them don't match the context.
            if (!matchFound)
                break;
        }
        return matches.length === selector.length && [firstMatchDepth, matches];
    }
}

// CONCATENATED MODULE: ./packages/core/src/Mode.ts

/**
 * Properties of a `VNode` that can be modified by a mode.
 */
var RuleProperty;
(function (RuleProperty) {
    RuleProperty["EDITABLE"] = "editable";
    RuleProperty["BREAKABLE"] = "breakable";
    RuleProperty["ALLOW_EMPTY"] = "allowEmpty";
})(RuleProperty || (RuleProperty = {}));
class Mode_Mode {
    constructor(mode) {
        this.id = mode.id;
        this.rules = mode.rules;
        // Convert the rules into an object describing them for each property.
        const ruleEntries = {};
        this._entries = this.rules.reduce((accumulator, rule) => {
            for (const property of Object.keys(rule.properties)) {
                const entry = {
                    selector: rule.selector,
                    value: rule.properties[property],
                };
                if (!ruleEntries[property])
                    ruleEntries[property] = [];
                ruleEntries[property].push(entry);
            }
            return accumulator;
        }, ruleEntries);
    }
    /**
     * Return true if this mode defines the given node's property as true. If
     * the mode does not define a value for the given node's property then
     * return true if the actual value of the property on the node itself is
     * true.
     *
     * @param node
     * @param property
     */
    is(node, property) {
        const hierarchy = [node, ...node.ancestors()];
        const entries = this._entries[property] || [];
        const result = ContextManager.getRankedMatches(hierarchy, entries);
        // For each result from a non-cascading rule property, keep only the
        // ones that match the given node, not one of its ancestors.
        const filteredResults = result.filter(r => r.entry.value.cascading || r.matched.some(match => match === node));
        if (filteredResults.length) {
            return filteredResults[0].entry.value.value;
        }
        else {
            return node[property];
        }
    }
}

// CONCATENATED MODULE: ./packages/utils/src/errors.ts
/**
 * Creates an instance representing a custom error adapting to the constructor
 * name of the custom error and taking advantage of `captureStackTrace` of V8.
 *
 * Source:
 * http://developer.mozilla.org/docs/JavaScript/Reference/Global_Objects/Error
 */
class CustomError extends Error {
    constructor(...params) {
        super(...params);
        this.name = this.constructor.name;
        // Maintains proper stack trace for where our error was thrown.
        if (Error.captureStackTrace) {
            // This is only available on V8.
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
/**
 * Creates an instance representing an error that occurs when a function only
 * allowed to be called in a specific mode is called in a different mode.
 */
class StageError extends CustomError {
    constructor(stage, ...params) {
        super(...params);
        this.message = `This operation is only allowed in ${stage} stage.`;
    }
}
/**
 * Creates an instance representing an error that occurs when a VNode given as
 * child function parameter is actually not a child of the current VNode.
 */
class ChildError extends CustomError {
    constructor(thisNode, node, ...params) {
        super(...params);
        this.message = `${node.name} is not a child of ${thisNode.name}`;
    }
}
/**
 * Creates an instance representing an error that occurs when an action would
 * violate the atomicity of a VNode.
 */
class AtomicityError extends CustomError {
    constructor(node, ...params) {
        super(...params);
        this.message = `${node.name} is atomic.`;
    }
}

// CONCATENATED MODULE: ./packages/core/src/Memory/const.ts

const memoryProxyNotVersionableKey = Symbol('jabberwockMemoryNotVersionable');
const memoryProxyPramsKey = Symbol('jabberwockMemoryParams');
const removedItem = Symbol('jabberwockMemoryRemovedItem');
const symbolVerify = Symbol('jabberwockMemoryVerify');
/**
 * Creates an instance representing an error that occurs when theyr are any
 * error in the memory feature or with the integration of the memory.
 */
class const_MemoryError extends CustomError {
    constructor(message, ...params) {
        super(message, ...params);
        this.message = message || 'Jabberwok error in memory feature';
    }
}
class NotVersionableError extends const_MemoryError {
    constructor() {
        super();
        this.message =
            'You can only link to the memory the instance of VersionableObject, VersionableArray or VersionableSet.' +
                "\nIf that's not possible, then you can also use makeVersionable method on your custom object." +
                '\nIf you do not want to make versionable this object, indicate it using MarkNotVersionable method' +
                '\nPlease read the Jabberwock documentation.';
    }
}
class VersionableAllreadyVersionableError extends const_MemoryError {
    constructor() {
        super();
        this.message =
            'This object was already update and a proxy was create to be versionable.' +
                '\nPlease use it instead of the source object.';
    }
}
class FroozenError extends const_MemoryError {
    constructor() {
        super();
        this.message =
            'This memory is froozen and immutable.' +
                '\nYou can not update a memory version who content memory dependencies';
    }
}

// CONCATENATED MODULE: ./packages/core/src/Memory/Memory.ts

// MemoryType
// MemoryType for Object
// Type that the memory handles in practice. This is how it is stored in memory.
class MemoryTypeObject {
    constructor() {
        this.props = {};
    }
}
// MemoryType for Array
// Type that the memory handles in practice. This is how it is stored in memory.
class MemoryTypeArray extends MemoryTypeObject {
    constructor() {
        super(...arguments);
        this.patch = {};
    }
}
// Output of memory given to proxy to operate
class MemoryArrayCompiledWithPatch {
    // the proxy has to differentiate between what was already there and what is
    // being done in the current slice because deleting a key does not yield the
    // same result if the key was already there before this slice or not (it
    // would be marked as "removed" or ignored if wasn't already there.)
    constructor(
    // array as it appears in the slice right before the current one "array as of t-1"
    compiledValues, 
    // very last patch at current time t
    newValues, 
    // new properties on the array at current time t
    props) {
        this.compiledValues = compiledValues;
        this.newValues = newValues;
        this.props = props;
    }
}
// MemoryType for Set
// Type that the memory handles in practice. This is how it is stored in memory.
class MemoryTypeSet {
    constructor() {
        this.add = new Set();
        this.delete = new Set();
    }
}
const parentedPathSeparator = '•';
function markAsDiffRoot(obj) {
    obj[memoryProxyPramsKey].isDiffRoot = true;
}
let memoryID = 0;
const memoryRootSliceName = '';
class MemorySlice {
    constructor(name, parent) {
        this.children = [];
        this.data = {}; // registry of values
        this.linkedParentOfProxy = {};
        this.invalidCache = {}; // paths that have been changed in given memory slice (when switching slice, this set is loaded in _invalidateCache)
        this.ids = new Set();
        this.name = name;
        this.parent = parent;
    }
    getPrevious() {
        return this.snapshotOrigin ? this.snapshotOrigin.parent : this.parent;
    }
}
class Memory_Memory {
    constructor() {
        this._slices = {}; // Record<children, parent>
        this._proxies = {};
        this._rootProxies = {};
        this._numberOfFlatSlices = 40;
        this._numberOfSlicePerSnapshot = 8;
        this._autoSnapshotCheck = 0;
        this._id = ++memoryID;
        this.create(memoryRootSliceName);
        this.switchTo(memoryRootSliceName);
        this._memoryWorker = {
            ID: this._id,
            getProxy: (ID) => this._proxies[ID],
            getSlice: () => this._currentSlice.data,
            getSliceValue: (ID) => this._getValue(this._sliceKey, ID),
            isFrozen: this.isFrozen.bind(this),
            // Mark as "modified" in this slice
            markDirty: (ID) => (this._currentSlice.invalidCache[ID] = true),
            // I am the proxy, I tell you I synchornized the value
            deleteSliceProxyParent: this._deleteSliceProxyParent.bind(this),
            addSliceProxyParent: this._addSliceProxyParent.bind(this),
            linkToMemory: this._linkToMemory.bind(this),
        };
        Object.freeze(this._memoryWorker);
    }
    get sliceKey() {
        return this._sliceKey;
    }
    /**
     * Create a memory slice.
     * Modifications and changes (of objects bound to memory) are all recorded
     * in these slices. The new slice created will be noted as being the
     * continuation (or the child) of the current one.
     *
     * A slice with "children" is immutable. The modifications are therefore
     * blocked and an error will be triggered if a code tries to modify one of
     * these objects. To be able to edit again, you must destroy the "child"
     * slices or change the memory slice.
     *
     * @param sliceKey
     */
    create(sliceKey) {
        this._create(sliceKey, this._sliceKey);
        return this;
    }
    /**
     * Change the working memory slice (this must be created beforehand).
     *
     * @param sliceKey
     */
    switchTo(sliceKey) {
        if (!(sliceKey in this._slices)) {
            throw new const_MemoryError('You must create the "' + sliceKey + '" slice before switch on it');
        }
        if (sliceKey === this._sliceKey) {
            return;
        }
        const invalidCache = this._aggregateInvalidCaches(this._sliceKey, sliceKey);
        this._currentSlice = this._slices[sliceKey];
        this._sliceKey = sliceKey;
        for (const key of invalidCache) {
            const proxy = this._proxies[key];
            const params = proxy[memoryProxyPramsKey];
            params.synchronize();
        }
        this._autoSnapshotCheck++;
        if (!(this._autoSnapshotCheck % this._numberOfSlicePerSnapshot)) {
            this._autoSnapshot();
        }
        return this;
    }
    /**
     * Attach a versionable to memory.
     * The versionable will then be versioned and its modifications will be
     * recorded in the corresponding memory slots.
     * All other versionables linked to given versionable attached to memory
     * are automatically linked to memory.
     *
     * (Items bound to memory by this function will be noted as part of the
     * root of changes @see getRoots )
     *
     * @param versionable
     */
    attach(versionable) {
        const params = versionable[memoryProxyPramsKey];
        if (!params) {
            throw new NotVersionableError();
        }
        if (params.object === versionable) {
            throw new VersionableAllreadyVersionableError();
        }
        if (!params.verify(versionable)) {
            throw new NotVersionableError();
        }
        if (this.isFrozen()) {
            throw new FroozenError();
        }
        if (!params.memory || params.memory !== this._memoryWorker) {
            params.isDiffRoot = true;
            this._linkToMemory(versionable);
        }
        this._rootProxies[params.ID] = true;
    }
    /**
     * Returns the parents of the object.
     *
     * Example: p = {}; v = {point: p} axis = {origin: p}
     * The parents of p are [[v, ['point']], [axis, ['origin']]]
     *
     * @param versionable
     */
    getParents(versionable) {
        const pathChanges = new Map();
        const nodeID = versionable[memoryProxyPramsKey].ID;
        const pathList = [[nodeID, []]];
        while (pathList.length) {
            const path = pathList.pop();
            const [nodeID, pathToNode] = path;
            const parentProxy = this._proxies[nodeID];
            let paths = pathChanges.get(parentProxy);
            if (!paths) {
                paths = [];
                pathChanges.set(parentProxy, paths);
            }
            paths.push(path[1]);
            if (this._rootProxies[nodeID]) {
                continue;
            }
            this._getProxyParentedPath(this._sliceKey, nodeID).forEach(path => {
                const parentNodeID = path.split(parentedPathSeparator, 1)[0];
                const partPath = path.slice(parentNodeID.length + 1);
                pathList.push([+parentNodeID, [partPath].concat(pathToNode)]);
            });
        }
        return pathChanges;
    }
    /**
     * Return the location of the changes.
     *
     * @param from
     * @param to
     */
    getChangesLocations(from, to) {
        const diff = {
            add: [],
            move: [],
            remove: [],
            update: [],
        };
        const ancestorKey = this._getCommonAncestor(from, to);
        const refs = this._getChangesPath(from, to, ancestorKey);
        if (from === ancestorKey && from !== to) {
            refs.shift();
        }
        const removeFromUpdate = new Set();
        let previous;
        let ref;
        while ((ref = refs.pop())) {
            const linkedParentOfProxy = ref.linkedParentOfProxy;
            for (const ID in linkedParentOfProxy) {
                const proxy = this._proxies[ID];
                if (linkedParentOfProxy[ID].length) {
                    if (ref.ids.has(+ID)) {
                        diff.add.push(proxy);
                        removeFromUpdate.add(proxy);
                    }
                    else {
                        diff.move.push(proxy);
                    }
                }
                else {
                    diff.remove.push(proxy);
                    removeFromUpdate.add(proxy);
                }
            }
            if (ref.parent === previous) {
                for (const ID of previous.ids) {
                    const proxy = this._proxies[ID];
                    diff.remove.push(proxy);
                    removeFromUpdate.add(proxy);
                }
            }
            const slice = ref.data;
            Object.keys(slice).forEach(ID => {
                const id = +ID;
                const memoryItem = slice[id];
                const proxy = this._proxies[ID];
                if (removeFromUpdate.has(proxy)) {
                    return;
                }
                else if (memoryItem instanceof MemoryTypeArray) {
                    const keys = Object.keys(memoryItem.props);
                    if (keys.length) {
                        diff.update.push([proxy, keys]);
                    }
                    const params = proxy[memoryProxyPramsKey];
                    const uniqIDs = params.uniqIDs;
                    const len = uniqIDs.length;
                    const half = len;
                    const indexes = [];
                    for (const i in memoryItem.patch) {
                        let index = half;
                        let step = index + 1;
                        while (step) {
                            const value = uniqIDs[index];
                            if (value === i) {
                                break;
                            }
                            else if (value > i) {
                                index -= step;
                                if (index < 0) {
                                    index = 0;
                                }
                            }
                            else {
                                index += step;
                                if (index >= len) {
                                    index = len - 1;
                                }
                            }
                            step = (step / 2) | 0;
                            if (step === 0 && value > i && uniqIDs[index] < i) {
                                index++;
                            }
                        }
                        if (!indexes.includes(index)) {
                            indexes.push(index);
                        }
                    }
                    if (indexes.length) {
                        diff.update.push([proxy, indexes]);
                    }
                }
                else if (memoryItem instanceof MemoryTypeSet) {
                    diff.update.push([proxy, null]);
                }
                else {
                    const keys = Object.keys(memoryItem.props);
                    if (keys.length) {
                        diff.update.push([proxy, keys]);
                    }
                }
            });
            previous = ref;
        }
        return diff;
    }
    /**
     * Get if the current memory slice are imutable or not.
     *
     */
    isFrozen() {
        return this._currentSlice.children.length > 0;
    }
    /**
     * Remove a memory slice.
     * The current slice cannot be the one being deleted or one of its children.
     *
     * @param sliceKey
     */
    remove(sliceKey) {
        if (!(sliceKey in this._slices)) {
            return this;
        }
        if (sliceKey === memoryRootSliceName) {
            throw new const_MemoryError('You should not remove the original memory slice');
        }
        let ref = this._slices[this._sliceKey];
        while (ref) {
            if (ref.name === sliceKey) {
                throw new const_MemoryError('Please switch to a non-children slice before remove it');
            }
            ref = ref.parent;
        }
        const IDs = this._remove(sliceKey);
        // check if the IDs are linked evrywere
        Object.values(this._slices).forEach(reference => {
            const linkedParentOfProxy = reference.linkedParentOfProxy;
            IDs.forEach(ID => {
                if (ID in linkedParentOfProxy) {
                    IDs.delete(ID);
                }
            });
        });
        // remove unlinked items
        IDs.forEach(ID => {
            delete this._proxies[ID];
            delete this._rootProxies[ID];
        });
        return this;
    }
    /**
     * Return ancestor versionables noted as roots.
     *
     * There are two ways for a versionable to be root, either via the
     * 'linkToMemory' method, or with the 'markAsDiffRoot' utility function.
     *
     * @param proxy
     */
    getRoots(proxy) {
        const roots = new Set();
        const nodeID = proxy[memoryProxyPramsKey].ID;
        const pathList = [[nodeID, []]];
        while (pathList.length) {
            const path = pathList.pop();
            const [nodeID, pathToNode] = path;
            if (this._rootProxies[nodeID]) {
                roots.add(this._proxies[nodeID]);
                continue;
            }
            this._getProxyParentedPath(this._sliceKey, nodeID).forEach(path => {
                const parentNodeID = path.split(parentedPathSeparator, 1)[0];
                const partPath = path.slice(parentNodeID.length + 1);
                pathList.push([+parentNodeID, [partPath].concat(pathToNode)]);
            });
        }
        return roots;
    }
    /**
     * Return the list of names of all previous memory slice of the given
     * memory slice.
     *
     * @param sliceKey
     * @param withoutSnapshot
     */
    getPath(sliceKey, withoutSnapshot) {
        const sliceKeys = [];
        let ref = this._slices[sliceKey];
        while (ref && ref.name) {
            sliceKeys.push(ref.name);
            ref = withoutSnapshot ? ref.getPrevious() : ref.parent;
        }
        return sliceKeys;
    }
    /**
     * Create the snapshot of different memory slices (use the path between the
     * memory slice to get all changes) and merge the changes into a new
     * destination slice.
     *
     * @param fromSliceKey
     * @param unitSliceKey
     * @param newSliceKey
     */
    snapshot(fromSliceKey, unitSliceKey, newSliceKey) {
        const refs = this._slices;
        const fromRref = refs[fromSliceKey];
        const untilRref = refs[unitSliceKey];
        const newRef = this._create(newSliceKey, fromRref.parent && fromRref.parent.name);
        this._squashInto(fromSliceKey, unitSliceKey, newRef.name);
        untilRref.children.forEach(child => {
            child.parent = newRef;
        });
        newRef.children = untilRref.children;
        untilRref.children = [];
        untilRref.snapshot = newRef;
        newRef.snapshotOrigin = untilRref;
    }
    /**
     * Compress all changes between two parented memory slices and remove all
     * children memory slice.
     *
     * @param fromSliceKey
     * @param unitSliceKey
     */
    compress(fromSliceKey, unitSliceKey) {
        const refs = this._slices;
        const fromRref = refs[fromSliceKey];
        const untilRref = refs[unitSliceKey];
        const toRemove = fromRref.children.slice().map(ref => ref.name);
        fromRref.children = untilRref.children.splice(0);
        this._squashInto(fromSliceKey, unitSliceKey, fromSliceKey);
        let key;
        while ((key = toRemove.pop())) {
            this._remove(key);
        }
        return true;
    }
    /////////////////////////////////////////////////////
    // private
    /////////////////////////////////////////////////////
    _addSliceProxyParent(ID, parentID, attributeName) {
        const sliceKey = this._sliceKey;
        const sliceLinkedParentOfProxy = this._slices[sliceKey].linkedParentOfProxy;
        const path = parentID +
            (attributeName === undefined
                ? memoryRootSliceName
                : parentedPathSeparator + attributeName);
        let parents = sliceLinkedParentOfProxy[ID];
        if (!parents) {
            const parented = this._getProxyParentedPath(sliceKey, ID);
            parents = sliceLinkedParentOfProxy[ID] = parented
                ? parented.slice()
                : [];
        }
        parents.push(path);
    }
    _deleteSliceProxyParent(ID, parentID, attributeName) {
        const sliceKey = this._sliceKey;
        const sliceLinkedParentOfProxy = this._slices[sliceKey].linkedParentOfProxy;
        const path = parentID +
            (attributeName === undefined
                ? memoryRootSliceName
                : parentedPathSeparator + attributeName);
        let parents = this._getProxyParentedPath(sliceKey, ID);
        const index = parents.indexOf(path);
        if (!sliceLinkedParentOfProxy[ID]) {
            parents = sliceLinkedParentOfProxy[ID] = parents.slice();
        }
        parents.splice(index, 1);
    }
    _compiledArrayPatches(patches) {
        const props = {};
        const valueBySeq = {};
        while (patches.length) {
            const patch = patches.pop();
            const step = patch.value;
            Object.assign(props, step.props);
            Object.assign(valueBySeq, step.patch);
        }
        return {
            patch: valueBySeq,
            props: props,
        };
    }
    _compiledSetPatches(patches) {
        const obj = new Set();
        while (patches.length) {
            const patch = patches.pop();
            const step = patch.value;
            step.add.forEach((item) => obj.add(item));
            step.delete.forEach((item) => obj.delete(item));
        }
        return obj;
    }
    _compiledObjectPatches(patches) {
        const obj = new MemoryTypeObject();
        const props = obj.props;
        while (patches.length) {
            const patch = patches.pop();
            const step = patch.value;
            Object.assign(props, step.props);
        }
        Object.keys(props).forEach(key => {
            if (props[key] === removedItem) {
                delete props[key];
            }
        });
        return obj;
    }
    _create(sliceKey, fromSliceKey) {
        const refs = this._slices;
        if (refs[sliceKey]) {
            throw new Error('The memory slice "' + sliceKey + '" already exists');
        }
        const parent = refs[fromSliceKey];
        const ref = (refs[sliceKey] = new MemorySlice(sliceKey, parent));
        if (parent) {
            parent.children.push(ref);
        }
        return ref;
    }
    _getChangesPath(fromSliceKey, toSliceKey, ancestorKey) {
        const fromPath = [];
        let ref = this._slices[fromSliceKey];
        while (ref) {
            fromPath.push(ref);
            if (ref.name === ancestorKey) {
                break;
            }
            ref = ref.getPrevious();
        }
        const toPath = [];
        ref = this._slices[toSliceKey];
        while (ref) {
            if (ref.name === ancestorKey) {
                break;
            }
            toPath.push(ref);
            ref = ref.getPrevious();
        }
        toPath.reverse();
        return fromPath.concat(toPath);
    }
    _getCommonAncestor(sliceKeyA, sliceKeyB) {
        const rootB = this._slices[sliceKeyB];
        let refA = this._slices[sliceKeyA];
        while (refA) {
            let refB = rootB;
            while (refB) {
                if (refA.name === refB.name) {
                    return refA.name;
                }
                refB = refB.getPrevious();
            }
            refA = refA.getPrevious();
        }
    }
    _getProxyParentedPath(sliceKey, ID) {
        // bubbling up magic for proxyParents
        let ref = this._slices[sliceKey];
        while (ref) {
            const slice = ref.linkedParentOfProxy;
            const path = slice && slice[ID];
            if (path) {
                return path;
            }
            ref = ref.parent;
        }
        return [];
    }
    _getValue(sliceKey, ID) {
        const patch = this._getPatches(undefined, sliceKey, ID);
        if (!patch) {
            return;
        }
        if (patch.type === 'set') {
            return this._compiledSetPatches(patch.patches);
        }
        else if (patch.type === 'array') {
            return this._getValueArray(sliceKey, ID, patch.patches);
        }
        else {
            return this._compiledObjectPatches(patch.patches);
        }
    }
    _getValueArray(sliceKey, ID, patches) {
        const ref = this._slices[sliceKey];
        let owner;
        if (ref.data[ID]) {
            owner = patches.shift().value;
        }
        const value = this._compiledArrayPatches(patches);
        return new MemoryArrayCompiledWithPatch(value.patch, owner || new MemoryTypeArray(), value.props);
    }
    _getPatches(fromSliceKey, toSliceKey, ID) {
        let ref = this._slices[toSliceKey];
        let type;
        const patches = [];
        while (ref && ref.name !== fromSliceKey) {
            const slice = ref.data;
            const value = slice && slice[ID];
            if (!value) {
                ref = ref.parent;
                continue;
            }
            if (!type) {
                if (value instanceof MemoryTypeArray) {
                    type = 'array';
                }
                else if (value instanceof MemoryTypeSet) {
                    type = 'set';
                }
                else {
                    type = 'object';
                }
            }
            patches.push({
                sliceKey: ref.name,
                value: value,
            });
            ref = ref.parent;
        }
        if (!type) {
            return;
        }
        return {
            patches: patches,
            type: type,
        };
    }
    _aggregateInvalidCaches(from, to) {
        const invalidCache = new Set();
        if (from === to) {
            return invalidCache;
        }
        const ancestorKey = this._getCommonAncestor(from, to);
        const refs = this._getChangesPath(from, to, ancestorKey);
        if (this._sliceKey === ancestorKey) {
            refs.shift();
        }
        while (refs.length) {
            const ref = refs.pop();
            Object.keys(ref.invalidCache).forEach(key => {
                // It was invalid before, it is still invalid now since it wasn't yet read
                invalidCache.add(+key);
            });
        }
        return invalidCache;
    }
    _linkToMemory(proxy) {
        const params = proxy[memoryProxyPramsKey];
        if (params.memory) {
            if (params.memory !== this._memoryWorker) {
                throw new const_MemoryError('This object is already linked to a other memory');
            }
            return;
        }
        const ID = params.ID;
        params.memory = this._memoryWorker;
        params.linkCallback(this._memoryWorker);
        this._proxies[ID] = proxy;
        if (params.isDiffRoot) {
            this._rootProxies[ID] = true;
        }
        this._currentSlice.ids.add(+ID);
    }
    _remove(sliceKey) {
        const IDs = [];
        let ref = this._slices[sliceKey];
        const index = ref.parent.children.indexOf(ref);
        ref.parent.children.splice(index, 1);
        const refs = [ref];
        while ((ref = refs.pop())) {
            const sliceKey = ref.name;
            ref.children.forEach(ref => refs.push(ref));
            Object.keys(ref.linkedParentOfProxy).forEach(ID => IDs.push(+ID));
            delete this._slices[sliceKey];
        }
        return new Set(IDs);
    }
    _squashInto(fromSliceKey, unitSliceKey, intoSliceKey) {
        const refs = this._slices;
        const fromRref = refs[fromSliceKey];
        const untilRref = refs[unitSliceKey];
        const intoRef = refs[intoSliceKey];
        const references = [];
        let ref = untilRref;
        while (ref) {
            references.push(ref);
            if (ref === fromRref) {
                break;
            }
            ref = ref.parent;
        }
        if (!ref) {
            throw new Error('Can not merge the slices');
        }
        const intoLinkedParentOfProxy = refs[intoSliceKey].linkedParentOfProxy;
        const intoInvalidCache = refs[intoSliceKey].invalidCache;
        const intoSlices = intoRef.data;
        while ((ref = references.pop())) {
            const LinkedParentOfProxy = ref.linkedParentOfProxy;
            Object.keys(LinkedParentOfProxy).forEach(ID => {
                intoLinkedParentOfProxy[ID] = LinkedParentOfProxy[ID].slice();
            });
            Object.keys(ref.invalidCache).forEach(link => {
                intoInvalidCache[link] = true;
            });
            const slice = ref.data;
            Object.keys(slice).forEach(ID => {
                const id = +ID;
                const memoryItem = slice[id];
                if (!intoSlices[id]) {
                    intoSlices[id] = memoryItem;
                    return;
                }
                if (memoryItem instanceof MemoryTypeArray) {
                    const intoItem = intoSlices[id];
                    Object.assign(intoItem.patch, memoryItem.patch);
                    Object.assign(intoItem.props, memoryItem.props);
                }
                else if (memoryItem instanceof MemoryTypeSet) {
                    const intoItem = intoSlices[id];
                    memoryItem.add.forEach(item => {
                        if (!intoItem.delete.has(item)) {
                            intoItem.add.add(item);
                        }
                        else {
                            intoItem.delete.delete(item);
                        }
                    });
                    memoryItem.delete.forEach(item => {
                        if (!intoItem.add.has(item)) {
                            intoItem.delete.add(item);
                        }
                        else {
                            intoItem.add.delete(item);
                        }
                    });
                }
                else {
                    const intoItem = intoSlices[id];
                    Object.assign(intoItem.props, memoryItem.props);
                }
            });
        }
    }
    _autoSnapshot() {
        const refs = [];
        let ref = this._currentSlice;
        while (ref && ref.name) {
            refs.push(ref);
            ref = ref.parent;
        }
        if (refs.length > this._numberOfFlatSlices + this._numberOfSlicePerSnapshot) {
            const fromSliceKey = refs[refs.length - 1].name;
            const unitSliceKey = refs[refs.length - 1 - this._numberOfSlicePerSnapshot].name;
            const newSliceKey = unitSliceKey + '[snapshot from ' + fromSliceKey + ']';
            this.snapshot(fromSliceKey, unitSliceKey, newSliceKey);
        }
    }
}

// CONCATENATED MODULE: ./packages/core/src/Memory/VersionableArray.ts




const Undefined = Symbol('jabberwockMemoryUndefined');
const proxyArrayHandler = {
    get(array, prop, proxy) {
        if (typeof prop === 'symbol' || !isNaN(prop)) {
            return array[prop];
        }
        const params = array[memoryProxyPramsKey];
        if (!params.memory) {
            return array[prop];
        }
        switch (prop) {
            case 'indexOf':
                return indexOf.bind(proxy, params);
            case 'includes':
                return includes.bind(proxy, params);
            case 'splice':
                return splice.bind(proxy, params);
            case 'push':
                return array[prop];
            case 'unshift':
                return unshift.bind(proxy, params);
            case 'shift':
                return shift.bind(proxy, params);
            case 'pop':
                return pop.bind(proxy, params);
            case 'forEach':
                return forEach.bind(proxy, params);
            case 'map':
                return VersionableArray_map.bind(proxy, params);
            case 'filter':
                return filter.bind(proxy, params);
            default:
                return array[prop];
        }
    },
    set(proxyObject, prop, value, proxy) {
        const params = proxyObject[memoryProxyPramsKey];
        const array = params.object;
        if (typeof prop === 'symbol' ||
            !params.memory ||
            (prop !== 'length' && isNaN(prop))) {
            return proxyObjectHandler.set(array, prop, value, proxy);
        }
        const index = +prop;
        const memory = params.memory;
        if (memory.isFrozen()) {
            throw new FroozenError();
        }
        const oldValue = array[prop];
        if (oldValue === value || (value === removedItem && !(prop in array))) {
            // no change
            return true;
        }
        const slice = memory.getSlice();
        let memoryArray = slice[params.ID];
        if (!memoryArray) {
            slice[params.ID] = memoryArray = new params.MemoryType();
        }
        if (slice !== params.syncSlice) {
            // allready sync, the current value (before update) is the previous value
            params.syncSlice = slice;
            params.previousSliceValues = {};
            array.forEach((value, index) => {
                params.previousSliceValues[params.uniqIDs[index]] = value;
            });
        }
        if (prop === 'length') {
            const length = +value;
            for (let index = length; index < array.length; index++) {
                const val = array[index];
                const oldParams = typeof val === 'object' && val[memoryProxyPramsKey];
                if (oldParams) {
                    memory.deleteSliceProxyParent(oldParams.ID, params.ID, '´' + params.uniqIDs[index]);
                }
                const uid = params.uniqIDs[index];
                if (params.previousSliceValues[uid] === removedItem ||
                    !(uid in params.previousSliceValues)) {
                    delete memoryArray.patch[uid];
                }
                else {
                    memoryArray.patch[uid] = removedItem;
                }
            }
            array.length = length;
            memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
            return true;
        }
        let newParams;
        if (value !== null && typeof value === 'object' && !value[memoryProxyNotVersionableKey]) {
            _checkVersionable(value);
            memory.linkToMemory(value);
            newParams = value[memoryProxyPramsKey];
        }
        array[prop] = value;
        if (oldValue === Undefined) {
            const uid = params.uniqIDs[index];
            if (newParams) {
                memoryArray.patch[uid] = newParams.ID;
                memory.addSliceProxyParent(newParams.ID, params.ID, '´' + uid);
            }
            else {
                memoryArray.patch[uid] = value;
            }
            params.map.set(value, uid);
        }
        else {
            const uniqIDs = params.uniqIDs;
            const uid = uniqIDs[index];
            // begin with remove previous
            if (uid) {
                const mapUID = params.map.get(oldValue);
                if (mapUID === uid) {
                    params.map.delete(oldValue);
                    const otherIndex = array.indexOf(oldValue);
                    if (otherIndex !== -1) {
                        params.map.set(oldValue, uniqIDs[otherIndex]);
                    }
                }
                if (params.previousSliceValues[uid] === removedItem ||
                    !(uid in params.previousSliceValues)) {
                    delete memoryArray.patch[uid];
                }
                else {
                    memoryArray.patch[uid] = removedItem;
                }
                const oldParams = oldValue && typeof oldValue === 'object' && oldValue[memoryProxyPramsKey];
                if (oldParams) {
                    memory.deleteSliceProxyParent(oldParams.ID, params.ID, '´' + uid);
                }
            }
            if (value === removedItem) {
                memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
                return true;
            }
            // and then we add item
            if (!uid && index > uniqIDs.length) {
                // add fake undefined values (don't add undefined in array)
                for (let k = uniqIDs.length; k < index; k++) {
                    const newUniqID = generateUid(params.sequences, uniqIDs[k - 1]);
                    uniqIDs.push(newUniqID);
                    memoryArray.patch[newUniqID] = Undefined;
                }
            }
            const isEnd = index >= uniqIDs.length;
            const nearest = isEnd ? undefined : uniqIDs[index];
            const newUniqID = generateUid(params.sequences, nearest, isEnd);
            uniqIDs[index] = newUniqID;
            if (newParams) {
                memory.addSliceProxyParent(newParams.ID, params.ID, '´' + newUniqID);
                memoryArray.patch[newUniqID] = newParams.ID;
            }
            else {
                memoryArray.patch[newUniqID] = value;
            }
            if (!params.map.has(oldValue)) {
                params.map.set(value, newUniqID);
            }
        }
        memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
        return true;
    },
    deleteProperty(obj, prop) {
        // `removedItem` is a marker to notify that there was something here but
        // it got removed
        this.set(obj, prop, removedItem);
        delete obj[prop];
        return true;
    },
};
function _proxifyArray(array) {
    const proxyObject = _proxifyObject(array);
    const proxy = new Proxy(proxyObject, proxyArrayHandler);
    const params = proxyObject[memoryProxyPramsKey];
    params.proxy = proxy;
    params.linkCallback = linkVersionable;
    params.MemoryType = MemoryTypeArray;
    params.map = new Map();
    params.uniqIDs = [];
    params.sequences = [];
    return proxy;
}
function unshift(params, ...items) {
    for (let k = 0, len = items.length; k < len; k++) {
        const item = items[k];
        params.object.unshift(Undefined);
        params.uniqIDs.unshift(generateUid(params.sequences, undefined));
        this[0] = item;
    }
    return params.object.length;
}
function shift(params) {
    const value = params.object[0];
    this['0'] = removedItem;
    params.object.shift();
    params.uniqIDs.shift();
    return value;
}
function pop(params) {
    const lastIndex = params.object.length - 1;
    const value = params.object[lastIndex];
    this.length = lastIndex;
    return value;
}
function splice(params, index, nb, ...items) {
    const array = params.object;
    const uniqIDs = params.uniqIDs;
    const len = array.length;
    if (nb === undefined) {
        nb = len - index;
    }
    const value = new array.constructor();
    if (nb > 0) {
        for (let i = 0; i < nb; i++) {
            value.push(array[i + index]);
        }
        for (let i = 0; i < nb; i++) {
            this[(i + index).toString()] = removedItem;
        }
        array.splice(index, nb);
        uniqIDs.splice(index, nb);
    }
    for (let key = 0, len = items.length; key < len; key++) {
        const item = items[key];
        const i = key + index;
        array.splice(i, 0, Undefined);
        const nearest = uniqIDs[i - 1];
        uniqIDs.splice(i, 0, generateUid(params.sequences, nearest));
        this[i] = item;
    }
    return value;
}
function forEach(params, callback) {
    const array = params.object;
    for (let index = 0, len = array.length; index < len; index++) {
        callback(array[index], index, this);
    }
}
function VersionableArray_map(params, callback) {
    const result = [];
    const array = params.object;
    for (let index = 0, len = array.length; index < len; index++) {
        result.push(callback(array[index], index, this));
    }
    return result;
}
function filter(params, callback) {
    const result = [];
    const array = params.object;
    for (let index = 0, len = array.length; index < len; index++) {
        const value = array[index];
        if (callback(value, index, this)) {
            result.push(value);
        }
    }
    return result;
}
function indexOf(params, item) {
    return params.object.indexOf(item);
}
function includes(params, item) {
    return params.object.includes(item);
}
function proxifySyncArray() {
    // Synchronization function
    // Most methods of the "proxy" will call this synchronization function, even
    // if it is not yet linked to a memory !
    const params = this;
    const memory = params.memory;
    // empties the array
    params.uniqIDs.length = 0;
    params.object.length = 0;
    // Clear props
    const keys = Object.keys(params.object);
    let key;
    while ((key = keys.pop())) {
        delete params.object[key];
    }
    const rawValues = memory.getSliceValue(params.ID);
    if (!rawValues) {
        return;
    }
    const values = Object.assign({}, rawValues.compiledValues, rawValues.newValues.patch);
    const sequences = Object.keys(values);
    sequences.sort();
    proxifySyncArrayItems(memory, sequences, values, params.object, params.uniqIDs);
    const props = Object.assign({}, rawValues.props, rawValues.newValues.props);
    proxifySyncArrayItems(memory, Object.keys(props), props, params.object);
    params.syncSlice = memory.getSlice();
    params.previousSliceValues = rawValues.compiledValues;
    params.sequences = sequences;
    params.map.clear();
    params.object.forEach((item, i) => {
        params.map.set(item, params.uniqIDs[i]);
    });
}
function proxifySyncArrayItems(memory, keys, values, array, uniqIDs) {
    let index = 0;
    for (let k = 0, len = keys.length; k < len; k++) {
        const key = keys[k];
        let value = values[key];
        if (value === removedItem) {
            continue;
        }
        if (value instanceof VersionableID) {
            value = memory.getProxy(value);
        }
        if (uniqIDs) {
            if (value !== Undefined) {
                array[index] = value;
            }
            uniqIDs.push(key);
            index++;
        }
        else {
            array[key] = value;
        }
    }
}
function linkVersionable(memory) {
    const params = this;
    params.memory = memory;
    params.synchronize = proxifySyncArray;
    const slice = memory.getSlice();
    const array = params.object;
    const keys = Object.keys(array);
    const len = keys.length;
    const ID = params.ID;
    if (len === 0) {
        memory.markDirty(ID);
        return;
    }
    const memoryArray = (slice[ID] = new params.MemoryType());
    const props = memoryArray.props;
    const patch = memoryArray.patch;
    const uniqIDs = params.uniqIDs;
    const sequences = params.sequences;
    let arrayIndex = -1;
    for (let k = 0; k < len; k++) {
        const key = keys[k];
        const index = +key;
        const value = array[key];
        const valueParams = value !== null && typeof value === 'object' && value[memoryProxyPramsKey];
        if (valueParams) {
            memory.linkToMemory(value);
        }
        if (isNaN(index)) {
            if (valueParams) {
                props[key] = valueParams.ID;
                memory.addSliceProxyParent(valueParams.ID, ID, key);
            }
            else {
                props[key] = value;
            }
        }
        else {
            arrayIndex++;
            while (arrayIndex < index) {
                const newUniqID = generateUid(sequences, undefined, true);
                uniqIDs[arrayIndex] = newUniqID;
                patch[newUniqID] = Undefined;
                arrayIndex++;
            }
            const newUniqID = generateUid(sequences, undefined, true);
            uniqIDs[index] = newUniqID;
            if (valueParams) {
                patch[newUniqID] = valueParams.ID;
                memory.addSliceProxyParent(valueParams.ID, ID, '´' + newUniqID);
            }
            else {
                patch[newUniqID] = value;
            }
        }
    }
    params.map.clear();
    array.forEach((item, i) => {
        if (!params.map.has(item)) {
            params.map.set(item, uniqIDs[i]);
        }
    });
    memory.markDirty(ID);
}
// IDs
function allocUid(min, max) {
    const step = 4;
    if (!min && !max) {
        return [128];
    }
    min = min || [];
    max = max || [];
    const res = [];
    let minSeq = 0;
    let maxSeq = max[0];
    for (let index = 0, len = Math.max(min.length, max.length); index < len; index++) {
        minSeq = min[index] | 0;
        maxSeq = index in max ? max[index] : 4096;
        if (minSeq === 4095 && maxSeq === 4096) {
            res.push(minSeq);
        }
        else if (minSeq === maxSeq) {
            res.push(minSeq);
        }
        else if (minSeq === maxSeq - 1 && len > index - 1) {
            res.push(minSeq);
        }
        else {
            break;
        }
    }
    const diff = (maxSeq - minSeq) >> 1;
    if (diff === 0) {
        res.push(min.length ? 128 : 2048);
    }
    else if (minSeq === 0) {
        res.push(maxSeq - Math.min(diff, step));
    }
    else {
        res.push(minSeq + Math.min(diff, step));
    }
    return res;
}
function hexaToSeq(str) {
    const seq = [];
    for (let k = 0, len = str.length; k < len; k += 3) {
        seq.push(parseInt(str.slice(k, k + 3), 16));
    }
    return seq;
}
function SeqToHexa(seq) {
    let str = '';
    const len = seq.length;
    for (let k = 0; k < len; k++) {
        const n = seq[k];
        if (n === 0) {
            str += '000';
        }
        else if (n < 16) {
            str += '00' + n.toString(16);
        }
        else if (n < 256) {
            str += '0' + n.toString(16);
        }
        else {
            str += n.toString(16);
        }
    }
    return str;
}
function generateUid(sortedUniqIDs, min, isEnd) {
    let max;
    if (isEnd) {
        min = sortedUniqIDs[sortedUniqIDs.length - 1];
    }
    else if (min) {
        max = sortedUniqIDs[sortedUniqIDs.indexOf(min) + 1];
    }
    else {
        max = sortedUniqIDs[0];
    }
    const minSeq = min && hexaToSeq(min);
    const maxSeq = max && hexaToSeq(max);
    const newUniqID = SeqToHexa(allocUid(minSeq, maxSeq));
    if (isEnd) {
        sortedUniqIDs.push(newUniqID);
    }
    else {
        const sortedIndex = min ? sortedUniqIDs.indexOf(min) : -1;
        if (sortedIndex === -1) {
            sortedUniqIDs.unshift(newUniqID);
        }
        else {
            sortedUniqIDs.splice(sortedIndex + 1, 0, newUniqID);
        }
    }
    return newUniqID;
}
class VersionableArray extends Array {
    constructor(...items) {
        super(...items);
        return _proxifyArray(this);
    }
}

// CONCATENATED MODULE: ./packages/core/src/Memory/VersionableSet.ts



// People can override the set methods. They will be called from the proxy, but
// sometimes we want to call the true original methods, not the override of the
// user. This is how we do it.
const genericSet = new Set();
const genericSetPrototype = Set.prototype;
function setPrototype(proxy, obj) {
    do {
        // This function loops on the prototypes of the object. This is what
        // stops it.
        // TODO refactor: while !== genericSetPrototype
        if (obj === genericSetPrototype) {
            break;
        }
        const op = Object.getOwnPropertyNames(obj);
        for (let i = 0; i < op.length; i++) {
            const prop = op[i]; // propName
            if (!proxy[prop]) {
                proxy[prop] = obj[prop];
            }
        }
    } while ((obj = Object.getPrototypeOf(obj)));
}
// eslint-disable-next-line @typescript-eslint/no-empty-function
function nothing() { }
class VersionableSet_VersionableSet extends Set {
    constructor(params) {
        super();
        let set; // original set (won't be synced, it's just for its method ex: overrides)
        let size = 0;
        if (!params) {
            set = genericSet;
        }
        else if (params instanceof Array) {
            set = genericSet;
            params.forEach(value => {
                size++;
                _stackedProxify(value, newValue => {
                    set.add.call(this, newValue);
                });
            });
        }
        else {
            if (params instanceof VersionableSet_VersionableSet) {
                set = params[memoryProxyPramsKey].object;
            }
            else {
                set = params;
            }
            params.forEach(value => {
                size++;
                _stackedProxify(value, newValue => {
                    set.add.call(this, newValue);
                });
            });
            setPrototype(this, set);
        }
        this[memoryProxyPramsKey] = {
            ID: generateVersionableID(),
            linkCallback: VersionableSet_linkVersionable,
            synchronize: nothing,
            MemoryType: MemoryTypeSet,
            verify: (proxy) => proxy === this,
            size: size,
            object: set,
            proxy: this,
        };
    }
    add(item) {
        // For Set specifically, this line will never actually *proxify* per se.
        // It will either work if the item is already proxified, or throw an
        // error if it is not.
        _checkVersionable(item);
        const params = this[memoryProxyPramsKey];
        const memory = params.memory;
        if (memory && memory.isFrozen()) {
            throw new FroozenError();
        }
        const check = this.has(item);
        if (!check) {
            params.object.add.call(this, item);
        }
        if (check || !memory) {
            // Nothing changed. Either the item was already there, or we don't
            // care because we are not linked to memory.
            return this;
        }
        let memoryItem = item;
        if (item !== null && typeof item === 'object' && !item[memoryProxyNotVersionableKey]) {
            // The item is versionable, great, but it is not versioned yet !
            // This call versions it into the memory.
            memory.linkToMemory(item);
            const itemParams = item[memoryProxyPramsKey];
            memoryItem = itemParams.ID;
            memory.addSliceProxyParent(itemParams.ID, params.ID, undefined);
        }
        // Get current slice.
        const slice = memory.getSlice();
        let memorySet = slice[params.ID]; // read the pure value stored in memory
        if (!memorySet) {
            slice[params.ID] = memorySet = new MemoryTypeSet();
            // Mark the set as being modified in this slice (not necesarilly "dirty")
            memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
        }
        // Update the stored changes for this slice
        memorySet.add.add(memoryItem);
        memorySet.delete.delete(memoryItem);
        return this;
    }
    delete(item) {
        const params = this[memoryProxyPramsKey];
        const memory = params.memory;
        if (memory && memory.isFrozen()) {
            throw new FroozenError();
        }
        const check = this.has(item);
        if (check) {
            params.object.delete.call(this, item);
        }
        if (!check || !memory) {
            return check;
        }
        let memoryItem = item;
        const itemParams = item && typeof item === 'object' && item[memoryProxyPramsKey];
        if (itemParams) {
            memoryItem = itemParams.ID;
            memory.deleteSliceProxyParent(itemParams.ID, params.ID, undefined);
        }
        const slice = memory.getSlice();
        let memorySet = slice[params.ID];
        if (!memorySet) {
            slice[params.ID] = memorySet = new MemoryTypeSet();
        }
        memorySet.delete.add(memoryItem);
        memorySet.add.delete(memoryItem);
        memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
        return check;
    }
    clear() {
        const params = this[memoryProxyPramsKey];
        const memory = params.memory;
        if (memory && memory.isFrozen()) {
            throw new FroozenError();
        }
        if (this.size === 0) {
            return this;
        }
        if (!memory) {
            params.object.clear.call(this);
            return this;
        }
        const slice = memory.getSlice();
        let memorySet = slice[params.ID];
        if (!memorySet) {
            slice[params.ID] = memorySet = new params.MemoryType();
        }
        params.object.forEach.call(this, (item) => {
            const itemParams = item && typeof item === 'object' && item[memoryProxyPramsKey];
            if (itemParams) {
                item = itemParams.ID;
                memory.deleteSliceProxyParent(itemParams.ID, params.ID, undefined);
            }
            memorySet.delete.add(item);
            memorySet.add.delete(item);
        });
        params.object.clear.call(this);
        memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
        return this;
    }
    has(item) {
        const params = this[memoryProxyPramsKey];
        return params.object.has.call(this, item);
    }
    values() {
        const params = this[memoryProxyPramsKey];
        return params.object.values.call(this);
    }
    keys() {
        const params = this[memoryProxyPramsKey];
        return params.object.keys.call(this);
    }
    forEach(callback) {
        const params = this[memoryProxyPramsKey];
        return params.object.forEach.call(this, callback);
    }
    entries() {
        const params = this[memoryProxyPramsKey];
        return params.object.entries.call(this);
    }
}
function proxifySyncSet() {
    // Synchronization function
    // Most methods of the "proxy" will call this synchronization function, even
    // if it is not yet linked to a memory !
    const params = this;
    const memory = params.memory;
    const object = params.object;
    const proxy = params.proxy;
    // get current object state in memory
    const memorySet = memory.getSliceValue(params.ID);
    // reset all keys (+ explanation of best/worst case scenario)
    object.clear.call(proxy);
    if (!memorySet) {
        return;
    }
    // Update values according to what is stored
    memorySet.forEach(item => {
        if (item instanceof VersionableID) {
            item = memory.getProxy(item);
        }
        object.add.call(proxy, item);
    });
}
// This will be set on the versionable params object and called with the params
// as the value of `this`. It is created here so that it is created only once !
function VersionableSet_linkVersionable(memory) {
    const params = this;
    params.memory = memory;
    params.synchronize = proxifySyncSet;
    memory.markDirty(params.ID);
    if (!params.proxy.size) {
        return;
    }
    const slice = memory.getSlice();
    const memorySet = new params.MemoryType();
    slice[params.ID] = memorySet; // store the "pure" value in memory
    params.object.forEach.call(params.proxy, (value) => {
        const valueParams = value !== null && typeof value === 'object' && value[memoryProxyPramsKey];
        if (valueParams) {
            // If object is versionable then link it to memory as well
            memory.linkToMemory(value);
            memory.addSliceProxyParent(valueParams.ID, params.ID, undefined);
            memorySet.add.add(valueParams.ID);
        }
        else {
            memorySet.add.add(value);
        }
    });
}
function _proxifySet(set) {
    const versionableSet = new VersionableSet_VersionableSet(set);
    set[memoryProxyPramsKey] = versionableSet[memoryProxyPramsKey];
    return versionableSet;
}

// CONCATENATED MODULE: ./packages/core/src/Memory/Versionable.ts




class VersionableID extends Number {
}
VersionableID.prototype[memoryProxyNotVersionableKey] = true;
let MemoryID = 0;
function generateVersionableID() {
    return new VersionableID(++MemoryID);
}
// queue of stuff to proxify
const toProxify = new Map();
/**
 * Take an object and return a versionable proxy to this object.
 *
 * @param object
 */
function makeVersionable(object) {
    const params = object[memoryProxyPramsKey];
    if (params) {
        if (params.object === object) {
            throw new VersionableAllreadyVersionableError();
        }
        if (params && params.verify(object)) {
            return object;
        }
    }
    const proxy = _proxify(object);
    toProxify.forEach((callbacks, torototo) => {
        toProxify.delete(torototo);
        const proxy = _proxify(torototo);
        callbacks.forEach(callback => callback(proxy));
    });
    return proxy;
}
/**
 * Create a proxy from a versionable with given handler.
 *
 * @param versionable
 * @param handler
 */
function proxifyVersionable(versionable, handler) {
    const newProxy = new Proxy(versionable, handler);
    versionable[memoryProxyPramsKey].proxy = newProxy;
    return newProxy;
}
/**
 * Mark the current object as not versionable in memory.
 * A non versionable object is not linked to the memory. The memory does not
 * take care of the change inside this object, and this object is nerver
 * immutable.
 *
 * @param object
 */
function markNotVersionable(object) {
    object[memoryProxyNotVersionableKey] = true;
}
/**
 * Throw an error if the given object is not a versionable.
 *
 * @param object
 */
function _checkVersionable(object) {
    if (typeof object !== 'object' ||
        object === null ||
        object[memoryProxyNotVersionableKey] // this is set by the user
    ) {
        return;
    }
    const params = object[memoryProxyPramsKey];
    if (params) {
        if (params.object === object) {
            throw new VersionableAllreadyVersionableError();
        }
        if (params.verify(object)) {
            // Already versioned ! (we could have inherited from the `params` of
            // another, already versioned object, but we might not)
            return;
        }
    }
    throw new NotVersionableError();
}
// Recursive proxification is very limited because of callback depth. To
// circumvent this issue, we queue the proxification of children.
function _stackedProxify(customClass, callback) {
    if (!customClass ||
        typeof customClass !== 'object' ||
        customClass[memoryProxyNotVersionableKey]) {
        callback(customClass);
        return;
    }
    const params = customClass[memoryProxyPramsKey];
    if (params) {
        callback(params.proxy);
    }
    const callbacks = toProxify.get(customClass) || [];
    toProxify.set(customClass, callbacks);
    callbacks.push(callback);
}
function _proxify(customClass) {
    const params = customClass[memoryProxyPramsKey];
    if (params && params.verify(customClass)) {
        return params.proxy;
    }
    let proxy;
    if (customClass instanceof Set) {
        proxy = _proxifySet(customClass);
    }
    else if (customClass instanceof Array) {
        proxy = _proxifyArray(customClass);
    }
    else {
        proxy = _proxifyObject(customClass);
    }
    return proxy;
}

// CONCATENATED MODULE: ./packages/core/src/Memory/VersionableObject.ts



const classGettersSetters = new WeakMap();
const rootPrototype = Object.getPrototypeOf({});
function getPrototypeGettersSetters(obj) {
    let gettersSetters = classGettersSetters.get(obj.constructor);
    if (gettersSetters) {
        return gettersSetters;
    }
    gettersSetters = {
        getters: {},
        setters: {},
    };
    classGettersSetters.set(obj.constructor, gettersSetters);
    obj = Object.getPrototypeOf(obj);
    do {
        const descs = Object.getOwnPropertyDescriptors(obj);
        Object.keys(descs).forEach(propName => {
            const desc = descs[propName];
            if (!gettersSetters.getters[propName] && desc.get) {
                gettersSetters.getters[propName] = desc.get;
            }
            if (!gettersSetters.setters[propName] && desc.set) {
                gettersSetters.setters[propName] = desc.set;
            }
        });
    } while ((obj = Object.getPrototypeOf(obj)) && obj !== rootPrototype);
    return gettersSetters;
}
const proxyObjectHandler = {
    set(obj, prop, value, proxy) {
        // Object.assign might try to set the value of the paramsKey. We
        // obviously don't want that. Let it think it succeeded (returning false
        // will throw an error, which is not what we want here.)
        if (prop === memoryProxyPramsKey) {
            return true;
        }
        if (prop === symbolVerify) {
            obj[symbolVerify] = value;
            return true;
        }
        const params = obj[memoryProxyPramsKey];
        const memory = params.memory;
        if (!memory && value === removedItem) {
            // "synchronize" the delete
            delete obj[prop];
            return true;
        }
        // if the property is a method of the class or prototype.
        const protoMethod = params.proto.setters[prop];
        if (protoMethod) {
            protoMethod.call(proxy, value);
            return true;
        }
        // if the property is a getter
        const desc = Object.getOwnPropertyDescriptor(obj, prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            desc.set.call(proxy, value);
            return true;
        }
        _checkVersionable(value);
        // if not linked to memory
        if (!memory) {
            obj[prop] = value;
            return true;
        }
        if (memory.isFrozen()) {
            throw new FroozenError();
        }
        const oldValue = obj[prop];
        // The value is the same, or we are deleting a value that was not
        // already there in the first place.
        if (oldValue === value || (value === removedItem && !(prop in obj))) {
            return true;
        }
        const slice = memory.getSlice();
        let memoryObject = slice[params.ID];
        if (!memoryObject) {
            slice[params.ID] = memoryObject = new params.MemoryType();
        }
        const memoryObjectProps = memoryObject.props;
        let memoryItem = value;
        if (value !== null && typeof value === 'object' && !value[memoryProxyNotVersionableKey]) {
            // if object, the stored value needs to be "converted" (see Set)
            memory.linkToMemory(value);
            const newParams = value && value[memoryProxyPramsKey];
            memoryItem = newParams.ID;
            memory.addSliceProxyParent(newParams.ID, params.ID, prop);
        }
        // if the old value was a versionable as well, sever its link to its parent
        const oldParams = oldValue && typeof oldValue === 'object' && oldValue[memoryProxyPramsKey];
        if (oldParams) {
            memory.deleteSliceProxyParent(oldParams.ID, params.ID, prop);
        }
        if (value === removedItem) {
            memoryObjectProps[prop] = removedItem; // notify that the deletion happened in this slice
            delete obj[prop];
        }
        else {
            memoryObjectProps[prop] = memoryItem;
            obj[prop] = value;
        }
        memory.markDirty(params.ID); // mark the cache as invalid when change the slide memory
        return true;
    },
    deleteProperty(obj, prop) {
        // `removedItem` is a marker to notify that there was something here but
        // it got removed
        this.set(obj, prop, removedItem);
        delete obj[prop];
        return true;
    },
};
function _proxifyObject(obj) {
    const proxy = new Proxy(obj, proxyObjectHandler);
    obj[memoryProxyPramsKey] = {
        ID: generateVersionableID(),
        linkCallback: VersionableObject_linkVersionable,
        synchronize: proxifySyncObject,
        MemoryType: MemoryTypeObject,
        verify: verify,
        proxy: proxy,
        object: obj,
        proto: getPrototypeGettersSetters(obj),
    };
    const keys = Object.keys(obj);
    for (let k = 0, len = keys.length; k < len; k++) {
        const key = keys[k];
        const value = obj[key];
        _stackedProxify(value, newValue => {
            if (newValue !== value) {
                obj[key] = newValue;
            }
        });
    }
    return proxy;
}
function verify(proxy) {
    const params = this;
    const obj = params.object;
    proxy[symbolVerify] = true;
    const value = obj[symbolVerify];
    obj[symbolVerify] = false;
    return value;
}
function proxifySyncObject() {
    // Synchronization function
    // Most methods of the "proxy" will call this synchronization function, even
    // if it is not yet linked to a memory !
    const params = this;
    const memory = params.memory;
    const memoryObject = memory.getSliceValue(params.ID);
    const memoryObjectProps = (memoryObject && memoryObject.props) || {};
    // Clear keys that do not exist anymore
    let keys = Object.keys(params.object);
    let key;
    while ((key = keys.pop())) {
        // if the object is not present in this slice or it does not have this key
        if (!(key in memoryObjectProps)) {
            delete params.object[key];
        }
    }
    if (!memoryObject) {
        return;
    }
    // Update values according to what is stored
    keys = Object.keys(memoryObjectProps);
    while ((key = keys.pop())) {
        let value = memoryObjectProps[key];
        if (value instanceof VersionableID) {
            // Convert proxy references to actual proxy
            value = memory.getProxy(value);
        }
        params.object[key] = value;
    }
}
function VersionableObject_linkVersionable(memory) {
    const params = this;
    params.memory = memory;
    const slice = params.memory.getSlice();
    const obj = params.object;
    const ID = params.ID;
    const keys = Object.keys(obj);
    if (keys.length) {
        const memoryObjectProps = Object.assign({}, obj);
        let key;
        while ((key = keys.pop())) {
            const value = obj[key];
            // Some of the values in the original object may be versionable and
            // need to be converted
            const valueParams = value !== null && typeof value === 'object' && value[memoryProxyPramsKey];
            if (valueParams) {
                memory.linkToMemory(value);
                memory.addSliceProxyParent(valueParams.ID, ID, key);
                memoryObjectProps[key] = valueParams.ID;
            }
        }
        const memoryObject = new params.MemoryType();
        memoryObject.props = memoryObjectProps;
        slice[ID] = memoryObject; // store the "pure" value in memory
    }
    memory.markDirty(ID);
}
class VersionableObject {
    constructor(obj) {
        if (obj) {
            const keys = Object.keys(obj);
            let key;
            while ((key = keys.pop())) {
                this[key] = obj[key];
            }
        }
        return _proxifyObject(this);
    }
}

// CONCATENATED MODULE: ./packages/core/src/Modifier.ts

class Modifier_Modifier extends VersionableObject {
    constructor() {
        super(...arguments);
        this.preserve = true;
    }
    get name() {
        return '';
    }
    toString() {
        return this.name;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    applyTo(node) {
        node.modifiers.prepend(this);
    }
    isSameAs(otherModifier) {
        return this === otherModifier;
    }
    clone() {
        return new this.constructor();
    }
}

// CONCATENATED MODULE: ./packages/plugin-xml/src/CssStyle.ts


class CssStyle_CssStyle extends VersionableObject {
    constructor(style) {
        super();
        if (style) {
            this.reset(style);
        }
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    /**
     * Return the number of styles in the set.
     */
    get length() {
        return this._style ? Object.keys(this._style).length : 0;
    }
    /**
     * Return a textual representation of the CSS declaration block.
     */
    get cssText() {
        if (!this._style) {
            return;
        }
        const keys = Object.keys(this._style);
        if (!Object.keys(this._style).length)
            return;
        const valueRepr = [];
        for (const key of keys) {
            valueRepr.push(`${key}: ${this._style[key]}`);
        }
        let result = valueRepr.join('; ');
        if (valueRepr.length) {
            result += ';';
        }
        return result;
    }
    /**
     * Reinitialize the record with a new record of styles, from a string to
     * parse.
     */
    set cssText(cssText) {
        this.reset(cssText);
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new record of styles, parsed from a cssText string.
     *
     * @param className
     */
    parseCssText(cssText) {
        const style = {};
        return cssText
            .split(';')
            .map(style => style.trim())
            .filter(style => style.length)
            .reduce((accumulator, value) => {
            const [key, v] = value.split(':');
            style[key.trim()] = v.trim();
            return accumulator;
        }, style);
    }
    /**
     * Return a clone of this record.
     */
    clone() {
        const clone = new CssStyle_CssStyle();
        if (this._style) {
            clone._style = makeVersionable(Object.assign({}, this._style));
        }
        return clone;
    }
    /**
     * Return the style value as record.
     */
    toJSON() {
        return Object.assign({}, this._style);
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return true if the record has the given style, false otherwise.
     *
     * @param key
     */
    has(key) {
        var _a;
        return !!((_a = this._style) === null || _a === void 0 ? void 0 : _a[key]);
    }
    /**
     * Return an array containing all the keys in the record.
     */
    keys() {
        return this._style ? Object.keys(this._style) : [];
    }
    /**
     * Return an array containing all the values in the record.
     */
    values() {
        return this._style ? Object.values(this._style) : [];
    }
    /**
     * Return the record matching the given name.
     *
     * @param name
     */
    get(name) {
        var _a;
        return (_a = this._style) === null || _a === void 0 ? void 0 : _a[name];
    }
    set(pairsOrName, value) {
        if (!this._style) {
            this._style = makeVersionable({});
        }
        if (typeof pairsOrName === 'string') {
            this._style[pairsOrName] = value;
        }
        else {
            for (const name of Object.keys(pairsOrName)) {
                this._style[name] = pairsOrName[name];
            }
        }
    }
    /**
     * Remove the record(s) with the given name(s).
     *
     * @param name
     */
    remove(...names) {
        if (this._style) {
            for (const name of names) {
                delete this._style[name];
            }
        }
    }
    /**
     * Clear the record of all its styles.
     */
    clear() {
        delete this._style;
    }
    /**
     * Reinitialize the record with a new record of styles (empty if no argument
     * is passed). The argument can be a record of styles or a string to parse.
     *
     * @param style
     */
    reset(style = '') {
        if (typeof style === 'object') {
            if (Object.keys(style).length) {
                this._style = makeVersionable(style);
            }
            else {
                delete this._style;
            }
        }
        else if (style.length) {
            this._style = makeVersionable(this.parseCssText(style));
        }
        else {
            delete this._style;
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-xml/src/ClassList.ts


class ClassList_ClassList extends VersionableObject {
    constructor(...classList) {
        super();
        for (const className of classList) {
            this.add(className);
        }
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    /**
     * Return the number of classes in the set.
     */
    get length() {
        var _a;
        return ((_a = this._classList) === null || _a === void 0 ? void 0 : _a.size) || 0;
    }
    /**
     * Return a textual representation of the set.
     */
    get className() {
        var _a;
        if (!((_a = this._classList) === null || _a === void 0 ? void 0 : _a.size))
            return;
        return Array.from(this._classList).join(' ');
    }
    /**
     * Reinitialize the set with a new set of classes, from a string to parse.
     */
    set className(className) {
        this.reset(className);
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new set of classes, parsed from a className string.
     *
     * @param className
     */
    parseClassName(className) {
        return new Set(className
            .trim()
            .split(/\s+/)
            .filter(c => c.length));
    }
    /**
     * Return a clone of this list.
     */
    clone() {
        var _a;
        const clone = new ClassList_ClassList();
        if ((_a = this._classList) === null || _a === void 0 ? void 0 : _a.size) {
            clone._classList = new VersionableSet_VersionableSet(this._classList);
        }
        return clone;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return true if the set has the given class, false otherwise.
     *
     * @param name
     */
    has(name) {
        var _a;
        return ((_a = this._classList) === null || _a === void 0 ? void 0 : _a.has(name)) || false;
    }
    /**
     * Return an array containing all the items in the list.
     */
    items() {
        return this._classList ? Array.from(this._classList) : [];
    }
    /**
     * Add the given class(es) to the set.
     *
     * @param classNames
     */
    add(...classNames) {
        if (!this._classList) {
            this._classList = new VersionableSet_VersionableSet();
        }
        for (const className of classNames) {
            if (className) {
                const classes = this.parseClassName(className);
                for (const name of classes) {
                    this._classList.add(name);
                }
            }
        }
    }
    /**
     * Remove the given class(es) from the set.
     *
     * @param classNames
     */
    remove(...classNames) {
        var _a;
        if (!((_a = this._classList) === null || _a === void 0 ? void 0 : _a.size))
            return;
        for (const className of classNames) {
            if (className) {
                const classes = this.parseClassName(className);
                for (const name of classes) {
                    this._classList.delete(name);
                }
            }
        }
    }
    /**
     * Clear the set of all its classes.
     */
    clear() {
        delete this._classList;
    }
    /**
     * Reinitialize the set with a new set of classes (empty if no argument is
     * passed). The argument can be a set of classes or a string to parse.
     *
     * @param classList
     */
    reset(...classList) {
        delete this._classList;
        for (const className of classList) {
            this.add(className);
        }
    }
    /**
     * For each given class, add it to the set if it doesn't have it yet,
     * otherwise remove it.
     *
     * @param classes
     */
    toggle(...classes) {
        if (!this._classList) {
            this._classList = new VersionableSet_VersionableSet();
        }
        for (const className of classes) {
            if (className) {
                const parsed = this.parseClassName(className);
                for (const name of parsed) {
                    if (this._classList.has(name)) {
                        this._classList.delete(name);
                    }
                    else {
                        this._classList.add(name);
                    }
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-xml/src/Attributes.ts




class Attributes_Attributes extends Modifier_Modifier {
    constructor(attributes) {
        super();
        this.style = new CssStyle_CssStyle();
        // Avoid copiying FontAwesome classes on paragraph break.
        // TODO : need to be improved to better take care of color classes, etc.
        this.preserve = false;
        this.classList = new ClassList_ClassList();
        if (attributes instanceof Attributes_Attributes) {
            for (const key of attributes.keys()) {
                this.set(key, attributes.get(key));
            }
        }
        else if (attributes instanceof NamedNodeMap) {
            for (const attribute of Array.from(attributes)) {
                this.set(attribute.name, attribute.value);
            }
        }
        else if (attributes) {
            for (const key of Object.keys(attributes)) {
                this.set(key, attributes[key]);
            }
        }
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    get length() {
        return this.keys().length;
    }
    get name() {
        const name = [];
        for (const attributeName of this.keys()) {
            name.push(`${attributeName}: "${this.get(attributeName)}"`);
        }
        return `{${name.join(', ')}}`;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a clone of this record.
     */
    clone() {
        const clone = new this.constructor();
        if (this._record) {
            clone._record = makeVersionable(Object.assign({}, this._record));
        }
        if (this.style.length) {
            clone.style = this.style.clone();
        }
        if (this.classList.length) {
            clone.classList = this.classList.clone();
        }
        return clone;
    }
    /**
     * Return a string representing the attributes.
     */
    toString() {
        if (!this.length)
            return `${this.constructor.name}: {}`;
        const valueRepr = [];
        for (const key of this.keys()) {
            valueRepr.push(`${key}: "${this.get(key)}"`);
        }
        return `${this.constructor.name}: { ${valueRepr.join(', ')} }`;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return true if the record has the given key, false otherwise.
     *
     * @param key
     */
    has(key) {
        return this.keys().includes(key.toLowerCase());
    }
    /**
     * Return an array containing all the keys in the record.
     */
    keys() {
        const keys = this._record
            ? Object.keys(this._record).filter(key => {
                return ((key !== 'style' || !!this.style.length) &&
                    (key !== 'class' || !!this.classList.length));
            })
            : [];
        if (this.classList.length && !keys.includes('class')) {
            // The node was not parsed with a class attribute, add it in place.
            // Use `get` for its value but record its position in the record.
            keys.push('class');
        }
        if (this.style.length && !keys.includes('style')) {
            // The node was not parsed with a style attribute, keep it always at
            // the end of the attributes list.
            keys.push('style');
        }
        return keys;
    }
    /**
     * Return an array containing all the values in the record.
     */
    values() {
        return this.keys().map(key => this.get(key));
    }
    /**
     * Return the record matching the given name.
     *
     * @param name
     */
    get(name) {
        var _a, _b, _c;
        name = name.toLowerCase();
        if (name === 'style') {
            return (_a = this.style) === null || _a === void 0 ? void 0 : _a.cssText;
        }
        else if (name === 'class') {
            return (_b = this.classList) === null || _b === void 0 ? void 0 : _b.className;
        }
        else {
            return (_c = this._record) === null || _c === void 0 ? void 0 : _c[name];
        }
    }
    /**
     * Set the record with the given name to the given value.
     *
     * @param name
     * @param value
     */
    set(name, value) {
        name = name.toLowerCase();
        if (!this._record) {
            this._record = makeVersionable({});
        }
        if (name === 'style') {
            if (this.style) {
                this.style.reset(value);
            }
            else {
                this.style = new CssStyle_CssStyle();
            }
            // Use `get` for its value but record its position in the record.
            this._record.style = null;
        }
        else if (name === 'class') {
            this.classList.reset(value);
            // Use `get` for its value but record its position in the record.
            this._record.class = null;
        }
        else {
            this._record[name] = value;
        }
    }
    /**
     * Remove the records with the given names.
     *
     * @param names
     */
    remove(...names) {
        for (let name of names) {
            name = name.toLowerCase();
            if (name === 'style') {
                this.style.clear();
            }
            else if (name === 'class') {
                this.classList.clear();
            }
            else if (this._record) {
                delete this._record[name];
            }
        }
    }
    clear() {
        delete this._record;
        this.style.clear();
        this.classList.clear();
    }
    /**
     * Return true if the given attributes are the same as the ones in this
     * record.
     *
     * @param otherAttributes
     */
    isSameAs(otherAttributes) {
        if (otherAttributes) {
            return (this.length === otherAttributes.length &&
                this.keys().every(key => {
                    return this.get(key) === otherAttributes.get(key);
                }));
        }
        else {
            return !this.length;
        }
    }
}

// CONCATENATED MODULE: ./packages/utils/src/utils.ts

/**
 * Return whether the given constructor is a constructor of given superClass.
 *
 * @param constructor
 * @param superClass
 */
function isConstructor(constructor, superClass) {
    return constructor.prototype instanceof superClass || constructor === superClass;
}
/**
 * Return true if the node has the `contentEditable` attribute.
 *
 * @param node
 */
function hasContentEditable(node) {
    var _a;
    return ((_a = node.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.has('contentEditable')) || false;
}
/**
 * Return true if the node has the `contentEditable` attribute set to true. This
 * implies that its children are editable but it is not necessarily itself
 * editable.
 *
 * TODO: unbind from `Attributes`.
 */
function isContentEditable(node) {
    var _a;
    const editable = (_a = node.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.get('contentEditable');
    return editable === '' || (editable === null || editable === void 0 ? void 0 : editable.toLowerCase()) === 'true' || false;
}
/**
 * Return true if object a is deep equal to object b, false otherwise.
 *
 * @param a
 * @param b
 */
function deepEqualObjects(a, b) {
    const aKeys = Object.keys(a);
    if (aKeys.length !== Object.keys(b).length)
        return false;
    for (const key of aKeys) {
        const aValue = a[key];
        const bValue = b[key];
        if (typeof aValue === 'object') {
            if (!deepEqualObjects(aValue, bValue)) {
                return false;
            }
        }
        else {
            if (aValue !== bValue) {
                return false;
            }
        }
    }
    return true;
}
/**
 * Creates a new array with all sub-array elements concatenated into it.
 */
function flat(arr) {
    return [].concat(...arr);
}
/**
 * Convert certain special characters to unicode.
 */
function toUnicode(string) {
    if (string === ' ') {
        return '\u00A0';
    }
    if (string === '\n') {
        return '\u000d';
    }
    if (string === '\t') {
        return '\u0009';
    }
    return string;
}
/**
 * Return the length of a DOM Node.
 *
 * @param node
 */
function nodeLength(node) {
    const isTextNode = node.nodeType === Node.TEXT_NODE;
    const content = isTextNode ? node.nodeValue : node.childNodes;
    return content.length;
}
/**
 * Return a duplicate-free version of an array.
 *
 * @param array
 */
function distinct(array) {
    return Array.from(new Set(array));
}
/**
 * Return the uppercase name of the given DOM node.
 *
 * @param node
 */
function nodeName(node) {
    return node.nodeName.toUpperCase();
}
function getDocument(node) {
    let root;
    while (node && !root) {
        if (node instanceof Document || node instanceof ShadowRoot) {
            root = node;
        }
        else {
            node = node.parentNode;
        }
    }
    return root || document;
}

// CONCATENATED MODULE: ./packages/core/src/Modifiers.ts




class Modifiers_Modifiers extends VersionableObject {
    constructor(...modifiers) {
        super();
        const clonedModifiers = modifiers.map(mod => {
            return mod instanceof Modifier_Modifier ? mod.clone() : mod;
        });
        this.append(...clonedModifiers);
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    /**
     * Return the length of the array.
     */
    get length() {
        var _a;
        return ((_a = this._contents) === null || _a === void 0 ? void 0 : _a.length) || 0;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new instance of the Modifiers class containing the same
     * modifiers.
     */
    clone() {
        if (this._contents) {
            return new Modifiers_Modifiers(...this._contents.map(mod => mod.clone()));
        }
        else {
            return new Modifiers_Modifiers();
        }
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Append one or more modifiers to the array. If one of the given modifiers
     * is a modifier class constructor, instantiate it.
     *
     * @param modifiers
     */
    append(...modifiers) {
        if (modifiers.length && !this._contents) {
            this._contents = new VersionableArray();
        }
        for (const modifier of modifiers) {
            if (modifier instanceof Modifier_Modifier) {
                this._contents.push(modifier);
            }
            else {
                this._contents.push(new modifier());
            }
        }
    }
    /**
     * Prepend one or more modifiers to the array. If one of the given modifiers
     * is a modifier class constructor, instantiate it.
     *
     * @param modifiers
     */
    prepend(...modifiers) {
        if (modifiers.length && !this._contents) {
            this._contents = new VersionableArray();
        }
        for (const modifier of [...modifiers].reverse()) {
            if (modifier instanceof Modifier_Modifier) {
                this._contents.unshift(modifier);
            }
            else {
                this._contents.unshift(new modifier());
            }
        }
    }
    find(modifier) {
        if (!this._contents) {
            return;
        }
        else if (modifier instanceof Modifier_Modifier) {
            // `modifier` is an instance of `Modifier` -> find it in the array.
            return this._contents.find(instance => instance === modifier);
        }
        else if (isConstructor(modifier, Modifier_Modifier)) {
            // `modifier` is a `Modifier` class -> find its first instance in
            // the array.
            return this._contents.find(mod => mod.constructor.name === modifier.name);
        }
        else if (modifier instanceof Function) {
            // `modifier` is a callback -> call `find` natively on the array.
            return this._contents.find(modifier);
        }
    }
    /**
     * Return the first modifier in the array that is an instance of the given
     * modifier class or create one, append it and return it.
     * If the modifier passed is a modifier instance, return it if it was
     * present in the array.
     *
     * @param modifier
     */
    get(modifier) {
        let found = this.find(modifier);
        if (!found && isConstructor(modifier, Modifier_Modifier)) {
            found = new modifier();
            this.append(found);
        }
        return found;
    }
    filter(modifier, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    thisArg) {
        if (!this._contents) {
            return [];
        }
        else if (isConstructor(modifier, Modifier_Modifier)) {
            // `modifier` is a `Modifier` class -> return all instances of it in
            // the array.
            return this._contents.filter(m => m instanceof modifier);
        }
        else {
            // `modifier` is a callback -> call `filter` natively on the array.
            return this._contents.filter(modifier, thisArg);
        }
    }
    /**
     * Remove the first modifier in the array that is an instance of the given
     * modifier class. If a modifier instance is given, remove that particuar
     * instance from the array. Return true if a modifier was removed, false
     * otherwise.
     *
     * @param modifier
     */
    remove(modifier) {
        if (!this._contents) {
            return false;
        }
        const modifierIndex = this._contents.findIndex(modifierInstance => {
            if (modifier instanceof Modifier_Modifier) {
                return modifierInstance === modifier;
            }
            else {
                return modifierInstance instanceof modifier;
            }
        });
        if (modifierIndex === -1) {
            return false;
        }
        else {
            this._contents.splice(modifierIndex, 1);
            return true;
        }
    }
    /**
     * Replace the first modifier in the array that is an instance of the given
     * modifier class or that matches the particular instance passed with the
     * given modifier instance. If the new modifier passed is a class,
     * instantiate it. If no modifier was found, simply push the new modifier on
     * the array.
     *
     * Return true if a modifier was replaced, false if the modifier was simply
     * added.
     *
     * @param oldModifier
     * @param newModifier
     */
    replace(oldModifier, newModifier) {
        var _a;
        const oldModifierIndex = (_a = this._contents) === null || _a === void 0 ? void 0 : _a.findIndex(modifierInstance => {
            if (oldModifier instanceof Modifier_Modifier) {
                return modifierInstance === oldModifier;
            }
            else {
                return modifierInstance instanceof oldModifier;
            }
        });
        if (!this._contents || oldModifierIndex === -1) {
            this.append(newModifier);
            return false;
        }
        else {
            const modifier = newModifier instanceof Modifier_Modifier ? newModifier : new newModifier();
            this._contents[oldModifierIndex] = modifier;
            return true;
        }
    }
    /**
     * Set the given modifiers on this Modifiers instance. Replace the modifiers
     * with same constructor if they exist, otherwise append the modifiers.
     *
     * @param modfiers
     */
    set(...modifiers) {
        for (const modifier of modifiers) {
            if (modifier instanceof Modifier_Modifier) {
                this.replace(modifier.constructor, modifier);
            }
            else {
                this.replace(modifier, modifier);
            }
        }
    }
    /**
     * Remove the first modifier in the array that is an instance of the given
     * modifier class or that matches the particular instance passed.
     * If no modifier was found, add the given modifier instead.
     * If the given new modifier is a class, instantiate it.
     *
     * @param modifier
     */
    toggle(modifier) {
        this.remove(modifier) || this.append(modifier);
    }
    /**
     * Return true if the modifiers in this array are the same as the modifiers
     * in the given array (as defined by the `isSameAs` methods of the
     * modifiers).
     *
     * @param otherModifiers
     */
    areSameAs(otherModifiers) {
        var _a;
        const modifiersMap = new Map(((_a = this._contents) === null || _a === void 0 ? void 0 : _a.map(a => [a, otherModifiers.find(b => a.isSameAs(b))])) || []);
        const aModifiers = Array.from(modifiersMap.keys());
        const bModifiers = Array.from(modifiersMap.values());
        const allAinB = aModifiers.every(a => a.isSameAs(modifiersMap.get(a)));
        const allBinA = otherModifiers.every(b => bModifiers.includes(b) || b.isSameAs(this.find(b)));
        return allAinB && allBinA;
    }
    /**
     * Remove all modifiers.
     */
    empty() {
        if (this._contents) {
            this._contents.length = 0;
        }
    }
    /**
     * Proxy for the native `some` method of `Array`, called on `this._contents`.
     *
     * @see Array.some
     * @param callbackfn
     */
    some(callbackfn) {
        var _a;
        return ((_a = this._contents) === null || _a === void 0 ? void 0 : _a.some(callbackfn)) || false;
    }
    /**
     * Proxy for the native `every` method of `Array`, called on `this._contents`.
     *
     * @see Array.every
     * @param callbackfn
     */
    every(callbackfn) {
        return this._contents ? this._contents.every(callbackfn) : true;
    }
    /**
     * Proxy for the native `map` method of `Array`, called on `this._contents`.
     *
     * @see Array.map
     * @param callbackfn
     */
    map(callbackfn) {
        var _a;
        return ((_a = this._contents) === null || _a === void 0 ? void 0 : _a.map(callbackfn)) || [];
    }
}

// CONCATENATED MODULE: ./packages/utils/src/EventMixin.ts




/**
 * Abstract class to add event mechanism.
 */
class EventMixin_EventMixin extends VersionableObject {
    /**
     * Subscribe to an event with a callback.
     *
     * @param eventName
     * @param callback
     */
    on(eventName, callback) {
        if (!this._eventCallbacks) {
            this._eventCallbacks = makeVersionable({});
        }
        if (!this._eventCallbacks[eventName]) {
            this._eventCallbacks[eventName] = new VersionableArray();
        }
        this._eventCallbacks[eventName].push(callback);
    }
    /**
     * Fire an event for of this object and all ancestors.
     *
     * @param eventName
     * @param args
     */
    trigger(eventName, args) {
        var _a;
        if ((_a = this._eventCallbacks) === null || _a === void 0 ? void 0 : _a[eventName]) {
            if (!this._callbackWorking) {
                this._callbackWorking = new VersionableSet_VersionableSet();
            }
            for (const callback of this._eventCallbacks[eventName]) {
                if (!this._callbackWorking.has(callback)) {
                    this._callbackWorking.add(callback);
                    callback(args);
                    this._callbackWorking.delete(callback);
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/core/src/VNodes/AbstractNode.ts





let AbstractNode_id = 0;
class AbstractNode_AbstractNode extends EventMixin_EventMixin {
    constructor(params) {
        super();
        this.id = AbstractNode_id;
        /**
         * True If the node will have a representation in the dom. Eg: markers are
         * not tangible.
         */
        this.tangible = true;
        /**
         * True if the node can be split.
         * Can be overridden with a `Mode`.
         */
        this.breakable = true;
        this.modifiers = new Modifiers_Modifiers();
        AbstractNode_id++;
        if (params === null || params === void 0 ? void 0 : params.modifiers) {
            if (params.modifiers instanceof Modifiers_Modifiers) {
                this.modifiers = params.modifiers;
            }
            else {
                this.modifiers.append(...params.modifiers);
            }
        }
        markAsDiffRoot(this);
    }
    /**
     * True if the node is editable. Propagates to the children.
     * A node that is editable can have its modifiers edited, be moved, removed,
     * and a selection can be made within it.
     * Can be overridden with a `Mode`.
     */
    get editable() {
        if (this._editable === false)
            return false;
        return (!this.parent ||
            (hasContentEditable(this.parent)
                ? isContentEditable(this.parent)
                : this.parent.editable));
    }
    set editable(state) {
        this._editable = state;
    }
    /**
     * Return whether the given predicate is a constructor of a VNode class.
     *
     * @param predicate The predicate to check.
     */
    static isConstructor(predicate) {
        return predicate.prototype instanceof AbstractNode_AbstractNode;
    }
    get name() {
        return this.constructor.name;
    }
    /**
     * Return the text content of this node.
     */
    get textContent() {
        return this.children()
            .map(child => child.textContent)
            .join('');
    }
    /**
     * @override
     */
    toString() {
        return this.name;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Transform the given DOM location into its VDocument counterpart.
     *
     * @param domNode DOM node corresponding to this VNode
     * @param offset The offset of the location in the given domNode
     */
    locate(domNode, offset) {
        // Position `BEFORE` is preferred over `AFTER`, unless the offset
        // overflows the children list, in which case `AFTER` is needed.
        let position = RelativePosition.BEFORE;
        const domNodeLength = nodeLength(domNode);
        if (domNodeLength && offset >= domNodeLength) {
            position = RelativePosition.AFTER;
        }
        return [this, position];
    }
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     */
    clone(params) {
        const clone = new this.constructor(params);
        clone.modifiers = this.modifiers.clone();
        return clone;
    }
    /**
     * Replace this VNode with the given VNode.
     *
     * @param node
     */
    replaceWith(node) {
        this.before(node);
        this.mergeWith(node);
    }
    //--------------------------------------------------------------------------
    // Properties
    //--------------------------------------------------------------------------
    /**
     * Return the length of this VNode.
     */
    get length() {
        return this.children().length;
    }
    /**
     * Test this node against the given predicate.
     *
     * If the predicate is falsy, return true. If the predicate is a constructor
     * of a VNode class, return whether this node is an instance of that class.
     * If the predicate is a standard function, return the result of this
     * function when called with the node as parameter.
     *
     *
     * @param predicate The predicate to test this node against.
     */
    test(predicate) {
        if (!predicate) {
            return true;
        }
        else if (AbstractNode_AbstractNode.isConstructor(predicate)) {
            return this instanceof predicate;
        }
        else {
            return predicate(this);
        }
    }
    /**
     * Return true if this VNode comes before the given VNode in the pre-order
     * traversal.
     *
     * @param vNode
     */
    isBefore(vNode) {
        const thisPath = [this, ...this.ancestors()];
        const nodePath = [vNode, ...vNode.ancestors()];
        // Find the last distinct ancestors in the path to the root.
        let thisAncestor;
        let nodeAncestor;
        do {
            thisAncestor = thisPath.pop();
            nodeAncestor = nodePath.pop();
        } while (thisAncestor && nodeAncestor && thisAncestor === nodeAncestor);
        if (thisAncestor && nodeAncestor) {
            const thisParent = thisAncestor.parent;
            const nodeParent = nodeAncestor.parent;
            if (thisParent && thisParent === nodeParent) {
                // Compare the indices of both ancestors in their shared parent.
                const thisIndex = thisParent.childVNodes.indexOf(thisAncestor);
                const nodeIndex = nodeParent.childVNodes.indexOf(nodeAncestor);
                return thisIndex < nodeIndex;
            }
            else {
                // The very first ancestor of both nodes are different so
                // they actually come from two different trees altogether.
                return false;
            }
        }
        else {
            // One of the nodes was in the ancestors path of the other.
            return !thisAncestor && !!nodeAncestor;
        }
    }
    /**
     * Return true if this VNode comes after the given VNode in the pre-order
     * traversal.
     *
     * @param vNode
     */
    isAfter(vNode) {
        return vNode.isBefore(this);
    }
    closest(predicate) {
        if (this.test(predicate)) {
            return this;
        }
        else {
            return this.ancestor(predicate);
        }
    }
    ancestor(predicate) {
        let ancestor = this.parent;
        while (ancestor && !ancestor.test(predicate)) {
            ancestor = ancestor.parent;
        }
        return ancestor;
    }
    ancestors(predicate) {
        const ancestors = [];
        let parent = this.parent;
        while (parent) {
            if (parent.test(predicate)) {
                ancestors.push(parent);
            }
            parent = parent.parent;
        }
        return ancestors;
    }
    commonAncestor(node, predicate) {
        if (!this.parent) {
            return;
        }
        else if (this.parent === node.parent && this.parent.test(predicate)) {
            return this.parent;
        }
        const thisPath = [this, ...this.ancestors(predicate)];
        const nodePath = [node, ...node.ancestors(predicate)];
        let commonAncestor;
        while (thisPath[thisPath.length - 1] === nodePath.pop()) {
            commonAncestor = thisPath.pop();
        }
        return commonAncestor;
    }
    siblings(predicate) {
        const siblings = [];
        let sibling = this.previousSibling();
        while (sibling) {
            if (sibling.test(predicate)) {
                siblings.unshift(sibling);
            }
            sibling = sibling.previousSibling();
        }
        sibling = this.nextSibling();
        while (sibling) {
            if (sibling.test(predicate)) {
                siblings.push(sibling);
            }
            sibling = sibling.nextSibling();
        }
        return siblings;
    }
    adjacents(predicate) {
        const adjacents = [];
        let sibling = this.previousSibling();
        while (sibling && sibling.test(predicate)) {
            adjacents.unshift(sibling);
            sibling = sibling.previousSibling();
        }
        sibling = this.nextSibling();
        while (sibling && sibling.test(predicate)) {
            adjacents.push(sibling);
            sibling = sibling.nextSibling();
        }
        return adjacents;
    }
    previousSibling(predicate) {
        if (!this.parent)
            return;
        const index = this.parent.childVNodes.indexOf(this);
        let sibling = this.parent.childVNodes[index - 1];
        // Skip ignored siblings and those failing the predicate test.
        while (sibling && !(sibling.tangible && sibling.test(predicate))) {
            sibling = sibling.previousSibling();
        }
        return sibling;
    }
    nextSibling(predicate) {
        if (!this.parent)
            return;
        const index = this.parent.childVNodes.indexOf(this);
        let sibling = this.parent.childVNodes[index + 1];
        // Skip ignored siblings and those failing the predicate test.
        while (sibling && !(sibling.tangible && sibling.test(predicate))) {
            sibling = sibling.nextSibling();
        }
        return sibling;
    }
    previous(predicate) {
        let previous = this.previousSibling();
        if (previous) {
            // The previous node is the last leaf of the previous sibling.
            previous = previous.lastLeaf();
        }
        else {
            // If it has no previous sibling then climb up to the parent.
            previous = this.parent;
        }
        while (previous && !previous.test(predicate)) {
            previous = previous.previous();
        }
        return previous;
    }
    next(predicate) {
        // The node after node is its first child.
        let next = this.firstChild();
        if (!next) {
            // If it has no children then it is its next sibling.
            next = this.nextSibling();
        }
        if (!next) {
            // If it has no siblings either then climb up to the closest parent
            // which has a next sibiling.
            let ancestor = this.parent;
            while (ancestor && !ancestor.nextSibling()) {
                ancestor = ancestor.parent;
            }
            next = ancestor && ancestor.nextSibling();
        }
        while (next && !next.test(predicate)) {
            next = next.next();
        }
        return next;
    }
    previousLeaf(predicate) {
        return this.previous((node) => {
            return isLeaf(node) && node.test(predicate);
        });
    }
    nextLeaf(predicate) {
        return this.next((node) => {
            return isLeaf(node) && node.test(predicate);
        });
    }
    previousSiblings(predicate) {
        const previousSiblings = [];
        let sibling = this.previousSibling();
        while (sibling) {
            if (sibling.test(predicate)) {
                previousSiblings.push(sibling);
            }
            sibling = sibling.previousSibling();
        }
        return previousSiblings;
    }
    nextSiblings(predicate) {
        const nextSiblings = [];
        let sibling = this.nextSibling();
        while (sibling) {
            if (sibling.test(predicate)) {
                nextSiblings.push(sibling);
            }
            sibling = sibling.nextSibling();
        }
        return nextSiblings;
    }
    //--------------------------------------------------------------------------
    // Updating
    //--------------------------------------------------------------------------
    /**
     * Insert the given VNode before this VNode.
     *
     * @param node
     */
    before(node) {
        if (!this.parent) {
            throw new Error('Cannot insert a VNode before a VNode with no parent.');
        }
        this.parent.insertBefore(node, this);
    }
    /**
     * Insert the given VNode after this VNode.
     *
     * @param node
     */
    after(node) {
        if (!this.parent) {
            throw new Error('Cannot insert a VNode after a VNode with no parent.');
        }
        this.parent.insertAfter(node, this);
    }
    /**
     * Wrap this node in the given node by inserting the given node at this
     * node's position in its parent and appending this node to the given node.
     *
     * @param node
     */
    wrap(node) {
        this.before(node);
        node.append(this);
    }
    /**
     * Remove this node.
     */
    remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
    }
    /**
     * Remove this node in forward direction. (e.g. `Delete` key)
     */
    removeForward() {
        this.remove();
    }
    /**
     * Remove this node in backward direction. (e.g. `Backspace` key)
     */
    removeBackward() {
        this.remove();
    }
    //--------------------------------------------------------------------------
    // Events.
    //--------------------------------------------------------------------------
    /**
     * @override
     */
    async trigger(eventName, args) {
        super.trigger(eventName, args);
        if (this.parent) {
            await this.parent.trigger(eventName, args);
        }
    }
    //--------------------------------------------------------------------------
    // Private.
    //--------------------------------------------------------------------------
    /**
     * Return a convenient string representation of this node and its
     * descendants.
     *
     * @param __repr
     * @param level
     */
    _repr(__repr = '', level = 0) {
        __repr += Array(level * 4 + 1).join(' ') + this.name + ' (' + this.id + ')' + '\n';
        this.childVNodes.forEach(child => {
            __repr = child._repr(__repr, level + 1);
        });
        return __repr;
    }
}

// CONCATENATED MODULE: ./packages/core/src/VNodes/AtomicNode.ts


/**
 * This class provides typing overrides for multiple VNode methods which are
 * supposed to take parameters but that are unused in the case of atomic nodes.
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
class AtomicNode_AtomicNode extends AbstractNode_AbstractNode {
    get childVNodes() {
        return [];
    }
    children(predicate) {
        return [];
    }
    /**
     * See {@link AbstractNode.hasChildren}.
     *
     * @return Returns `false` since an atomic node cannot have children.
     */
    hasChildren() {
        return false;
    }
    /**
     * See {@link AbstractNode.nthChild}.
     *
     * @return Returns `undefined` since an atomic node cannot have children.
     */
    nthChild(n) {
        return undefined;
    }
    firstChild(predicate) {
        return undefined;
    }
    lastChild(predicate) {
        return undefined;
    }
    firstLeaf(predicate) {
        return this;
    }
    lastLeaf(predicate) {
        return this;
    }
    firstDescendant(predicate) {
        return undefined;
    }
    lastDescendant(predicate) {
        return undefined;
    }
    descendants(predicate) {
        return [];
    }
    //--------------------------------------------------------------------------
    // Updating children.
    //--------------------------------------------------------------------------
    /**
     * See {@link AbstractNode.prepend}.
     *
     * @throws AtomicityError An atomic node cannot have children.
     */
    prepend(...children) {
        throw new AtomicityError(this);
    }
    /**
     * See {@link AbstractNode.prepend}.
     *
     * @throws AtomicityError An atomic node cannot have children.
     */
    append(...children) {
        throw new AtomicityError(this);
    }
    /**
   /**
     * See {@link AbstractNode.insertBefore}.
     *
     * @throws AtomicityError An atomic node cannot have children.
     */
    insertBefore(node, reference) {
        throw new AtomicityError(this);
    }
    /**
     * See {@link AbstractNode.insertAfter}.
     *
     * @throws AtomicityError An atomic node cannot have children.
     */
    insertAfter(node, reference) {
        throw new AtomicityError(this);
    }
    /**
     * See {@link AbstractNode.empty}.
     */
    empty() {
        return;
    }
    /**
     * See {@link AbstractNode.removeChild}.
     *
     * @throws AtomicityError An atomic node cannot have children.
     */
    removeChild(child) {
        throw new AtomicityError(this);
    }
    /**
     * See {@link AbstractNode.splitAt}.
     *
     * @throws AtomicityError An atomic node cannot be split.
     */
    splitAt(child) {
        throw new AtomicityError(this);
    }
    /**
     * See {@link AbstractNode.mergeWith}.
     */
    mergeWith(newContainer) {
        return;
    }
    /**
     * See {@link AbstractNode.unwrap}.
     */
    unwrap() {
        return;
    }
}

// CONCATENATED MODULE: ./packages/core/src/Core.ts




class Core_Core extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            insert: {
                handler: this.insert,
            },
            insertParagraphBreak: {
                handler: this.insertParagraphBreak,
            },
            setSelection: {
                handler: this.setSelection,
            },
            deleteBackward: {
                handler: this.deleteBackward,
            },
            deleteForward: {
                handler: this.deleteForward,
            },
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Insert a paragraph break.
     */
    insertParagraphBreak(params) {
        const range = params.context.range;
        // Remove the contents of the range if needed.
        if (!range.isCollapsed()) {
            range.empty();
        }
        if (range.mode.is(range.startContainer, RuleProperty.BREAKABLE)) {
            range.startContainer.splitAt(range.start);
        }
        else {
            // Use a separator to break paragraphs in an unbreakable.
            const Separator = this.editor.configuration.defaults.Separator;
            range.start.before(new Separator());
        }
    }
    /**
     * Insert a VNode at the current position of the selection.
     *
     * @param params
     */
    insert(params) {
        // Remove the contents of the range if needed.
        if (!params.context.range.isCollapsed()) {
            params.context.range.empty();
        }
        params.context.range.start.before(params.node);
    }
    /**
     * Delete in the backward direction (backspace key expected behavior).
     */
    deleteBackward(params) {
        const range = params.context.range;
        if (range.isCollapsed()) {
            // Basic case: remove the node directly preceding the range.
            const previousSibling = range.start.previousSibling();
            if (previousSibling && range.mode.is(previousSibling, RuleProperty.EDITABLE)) {
                previousSibling.removeBackward();
            }
            else if (range.mode.is(range.startContainer, RuleProperty.BREAKABLE) &&
                range.mode.is(range.startContainer, RuleProperty.EDITABLE)) {
                // Otherwise set range start at previous valid leaf.
                let ancestor = range.start.parent;
                while (ancestor &&
                    range.mode.is(ancestor, RuleProperty.BREAKABLE) &&
                    range.mode.is(ancestor, RuleProperty.EDITABLE) &&
                    !ancestor.previousSibling()) {
                    ancestor = ancestor.parent;
                }
                if (ancestor &&
                    range.mode.is(ancestor, RuleProperty.BREAKABLE) &&
                    range.mode.is(ancestor, RuleProperty.EDITABLE)) {
                    const previousSibling = ancestor.previousSibling();
                    if (previousSibling instanceof AtomicNode_AtomicNode) {
                        ancestor.mergeWith(previousSibling.parent);
                    }
                    else {
                        const previousLeaf = previousSibling.lastLeaf();
                        if (previousSibling && !previousSibling.hasChildren()) {
                            // If the previous sibling is empty, remove it.
                            previousSibling.removeBackward();
                        }
                        else if (previousLeaf) {
                            range.setStart(previousLeaf, RelativePosition.AFTER);
                            range.empty();
                        }
                    }
                }
            }
        }
        else {
            range.empty();
        }
    }
    /**
     * Delete in the forward direction (delete key expected behavior).
     */
    deleteForward(params) {
        const range = params.context.range;
        if (range.isCollapsed()) {
            // Basic case: remove the node directly following the range.
            const nextSibling = range.end.nextSibling();
            if (nextSibling && range.mode.is(nextSibling, RuleProperty.EDITABLE)) {
                nextSibling.removeForward();
            }
            else if (range.mode.is(range.endContainer, RuleProperty.BREAKABLE) &&
                range.mode.is(range.endContainer, RuleProperty.EDITABLE)) {
                // Otherwise set range end at next valid leaf.
                let ancestor = range.end.parent;
                while (ancestor &&
                    range.mode.is(ancestor, RuleProperty.BREAKABLE) &&
                    range.mode.is(ancestor, RuleProperty.EDITABLE) &&
                    !ancestor.nextSibling()) {
                    ancestor = ancestor.parent;
                }
                if (ancestor &&
                    range.mode.is(ancestor, RuleProperty.BREAKABLE) &&
                    range.mode.is(ancestor, RuleProperty.EDITABLE)) {
                    const nextSibling = ancestor.nextSibling();
                    if (nextSibling instanceof AtomicNode_AtomicNode) {
                        let next = nextSibling;
                        while (next && next instanceof AtomicNode_AtomicNode) {
                            ancestor.append(next);
                            next = ancestor.nextSibling();
                        }
                    }
                    else {
                        const next = nextSibling.firstLeaf();
                        if (next && !range.endContainer.hasChildren()) {
                            // If the current container is empty, remove it.
                            range.endContainer.removeForward();
                            range.setStart(next, RelativePosition.BEFORE);
                            range.setEnd(next, RelativePosition.BEFORE);
                        }
                        else if (next) {
                            range.setEnd(next, RelativePosition.BEFORE);
                            range.empty();
                        }
                    }
                }
            }
        }
        else {
            range.empty();
        }
    }
    /**
     * Navigate to a given range.
     *
     * @param params
     */
    setSelection(params) {
        this.editor.selection.set(params.vSelection);
    }
}

// CONCATENATED MODULE: ./packages/core/src/VNodes/MarkerNode.ts

class MarkerNode_MarkerNode extends AtomicNode_AtomicNode {
    constructor() {
        super(...arguments);
        this.editable = false;
        this.tangible = false;
    }
}
MarkerNode_MarkerNode.atomic = true;

// CONCATENATED MODULE: ./packages/core/src/VNodes/ContainerNode.ts




class ContainerNode_ContainerNode extends AbstractNode_AbstractNode {
    constructor() {
        super(...arguments);
        this.childVNodes = new VersionableArray();
    }
    children(predicate) {
        const children = [];
        this.childVNodes.forEach(child => {
            if (child.tangible && (!predicate || child.test(predicate))) {
                children.push(child);
            }
        });
        return children;
    }
    /**
     * See {@link AbstractNode.hasChildren}.
     */
    hasChildren() {
        return !!this.childVNodes.find(child => child.tangible);
    }
    /**
     * See {@link AbstractNode.nthChild}.
     */
    nthChild(n) {
        return this.children()[n - 1];
    }
    firstChild(predicate) {
        let child = this.childVNodes[0];
        while (child && !(child.tangible && (!predicate || child.test(predicate)))) {
            child = child.nextSibling();
        }
        return child;
    }
    lastChild(predicate) {
        let child = this.childVNodes[this.childVNodes.length - 1];
        while (child && !(child.tangible && (!predicate || child.test(predicate)))) {
            child = child.previousSibling();
        }
        return child;
    }
    firstLeaf(predicate) {
        const isValidLeaf = (node) => {
            return isLeaf(node) && (!predicate || node.test(predicate));
        };
        if (isValidLeaf(this)) {
            return this;
        }
        else {
            return this.firstDescendant((node) => isValidLeaf(node));
        }
    }
    lastLeaf(predicate) {
        const isValidLeaf = (node) => {
            return isLeaf(node) && (!predicate || node.test(predicate));
        };
        if (isValidLeaf(this)) {
            return this;
        }
        else {
            return this.lastDescendant((node) => isValidLeaf(node));
        }
    }
    firstDescendant(predicate) {
        let firstDescendant = this.firstChild();
        while (firstDescendant && predicate && !firstDescendant.test(predicate)) {
            firstDescendant = this._descendantAfter(firstDescendant);
        }
        return firstDescendant;
    }
    lastDescendant(predicate) {
        let lastDescendant = this.lastChild();
        while (lastDescendant && lastDescendant.hasChildren()) {
            lastDescendant = lastDescendant.lastChild();
        }
        while (lastDescendant && predicate && !lastDescendant.test(predicate)) {
            lastDescendant = this._descendantBefore(lastDescendant);
        }
        return lastDescendant;
    }
    descendants(predicate) {
        const descendants = [];
        const stack = [...this.childVNodes];
        while (stack.length) {
            const node = stack.shift();
            if (node.tangible && (!predicate || node.test(predicate))) {
                descendants.push(node);
            }
            if (node instanceof ContainerNode_ContainerNode) {
                stack.unshift(...node.childVNodes);
            }
        }
        return descendants;
    }
    //--------------------------------------------------------------------------
    // Updating
    //--------------------------------------------------------------------------
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     */
    clone(deepClone, params) {
        const clone = super.clone(params);
        if (deepClone) {
            for (const child of this.childVNodes) {
                clone.append(child.clone(true));
            }
        }
        return clone;
    }
    /**
     * See {@link AbstractNode.prepend}.
     */
    prepend(...children) {
        for (const child of children) {
            this._insertAtIndex(child, 0);
        }
        if (children.find(child => child.tangible)) {
            this.trigger('childList');
        }
    }
    /**
     * See {@link AbstractNode.append}.
     */
    append(...children) {
        for (const child of children) {
            this._insertAtIndex(child, this.childVNodes.length);
        }
        if (children.find(child => child.tangible)) {
            this.trigger('childList');
        }
    }
    /**
     * See {@link AbstractNode.insertBefore}.
     */
    insertBefore(node, reference) {
        const index = this.childVNodes.indexOf(reference);
        if (index < 0) {
            throw new ChildError(this, node);
        }
        this._insertAtIndex(node, index);
        if (node.tangible) {
            this.trigger('childList');
        }
    }
    /**
     * See {@link AbstractNode.insertAfter}.
     */
    insertAfter(node, reference) {
        const index = this.childVNodes.indexOf(reference);
        if (index < 0) {
            throw new ChildError(this, node);
        }
        this._insertAtIndex(node, index + 1);
        if (node.tangible) {
            this.trigger('childList');
        }
    }
    /**
     * See {@link AbstractNode.empty}.
     */
    empty() {
        for (const child of [...this.childVNodes]) {
            child.remove();
        }
    }
    /**
     * See {@link AbstractNode.removeChild}.
     */
    removeChild(child) {
        const index = this.childVNodes.indexOf(child);
        if (index < 0) {
            throw new ChildError(this, child);
        }
        this._removeAtIndex(index);
    }
    /**
     * See {@link AbstractNode.splitAt}.
     */
    splitAt(child) {
        if (child.parent !== this) {
            throw new ChildError(this, child);
        }
        else if (!this.breakable) {
            // Unbreakable nodes do not split.
            return this;
        }
        const duplicate = this.clone();
        const index = this.childVNodes.indexOf(child);
        const children = this.childVNodes.splice(index);
        duplicate.childVNodes.push(...children);
        for (const child of children) {
            child.parent = duplicate;
        }
        this.after(duplicate);
        return duplicate;
    }
    /**
     * See {@link AbstractNode.mergeWith}.
     */
    mergeWith(newContainer) {
        if (newContainer !== this) {
            if (newContainer.childVNodes.includes(this)) {
                for (const child of this.childVNodes.slice()) {
                    newContainer.insertBefore(child, this);
                }
            }
            else {
                newContainer.append(...this.childVNodes);
            }
            this.remove();
        }
    }
    /**
     * See {@link AbstractNode.unwrap}.
     */
    unwrap() {
        for (const child of this.childVNodes.slice()) {
            this.before(child);
        }
        this.remove();
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return the descendant of this node that directly precedes the given node
     * in depth-first pre-order traversal.
     *
     * @param node
     */
    _descendantBefore(node) {
        let previous = node.previousSibling();
        if (previous) {
            // The node before node is the last leaf of its previous sibling.
            previous = previous.lastLeaf();
        }
        else if (node.parent !== this) {
            // If it has no previous sibling then climb up to the parent.
            // This is similar to `previous` but can't go further than `this`.
            previous = node.parent;
        }
        return previous;
    }
    /**
     * Return the descendant of this node that directly follows the given node
     * in depth-first pre-order traversal.
     *
     * @param node
     */
    _descendantAfter(node) {
        // The node after node is its first child.
        let next = node.firstChild();
        if (!next) {
            // If it has no children then it is its next sibling.
            next = node.nextSibling();
        }
        if (!next) {
            // If it has no siblings either then climb up to the closest parent
            // which has a next sibiling.
            // This is similar to `next` but can't go further than `this`.
            let ancestor = node.parent;
            while (ancestor !== this && !ancestor.nextSibling()) {
                ancestor = ancestor.parent;
            }
            if (ancestor !== this) {
                next = ancestor.nextSibling();
            }
        }
        return next;
    }
    /**
     * Insert a VNode at the given index within this VNode's children.
     *
     * @param child
     * @param index The index at which the insertion must take place within this
     * VNode's parent, holding marker nodes into account.
     */
    _insertAtIndex(child, index) {
        if (child.parent) {
            const currentIndex = child.parent.childVNodes.indexOf(child);
            if (index && child.parent === this && currentIndex < index) {
                index--;
            }
            child.parent.removeChild(child);
        }
        this.childVNodes.splice(index, 0, child);
        child.parent = this;
    }
    /**
     * Remove the nth child from this node.
     *
     * @param index The index of the child to remove including marker nodes.
     */
    _removeAtIndex(index) {
        const child = this.childVNodes.splice(index, 1)[0];
        if (child.tangible) {
            this.trigger('childList');
        }
        child.parent = undefined;
    }
}

// CONCATENATED MODULE: ./packages/core/src/VNodes/FragmentNode.ts

class FragmentNode_FragmentNode extends ContainerNode_ContainerNode {
    constructor() {
        super(...arguments);
        this.editable = false;
        this.breakable = false;
    }
    set parent(parent) {
        this.mergeWith(parent);
        parent.removeChild(this);
    }
}

// CONCATENATED MODULE: ./packages/core/src/VNodes/VElement.ts

class VElement_VElement extends ContainerNode_ContainerNode {
    constructor(params) {
        super();
        this.htmlTag = params.htmlTag;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     */
    clone(deepClone, params) {
        const defaults = {
            htmlTag: this.htmlTag,
        };
        return super.clone(deepClone, Object.assign(Object.assign({}, defaults), params));
    }
}

// CONCATENATED MODULE: ./packages/plugin-table/src/TableRowNode.ts


class TableRowNode_TableRowNode extends VElement_VElement {
    constructor(params) {
        super({ htmlTag: 'TR' });
        this.breakable = false;
        this.header = (params === null || params === void 0 ? void 0 : params.header) || false;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     *
     *  @override
     */
    clone(deepClone, params) {
        const defaults = {
            header: this.header,
        };
        return super.clone(deepClone, Object.assign(Object.assign({}, defaults), params));
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    /**
     * @override
     */
    get name() {
        return super.name + (this.header ? ': header' : '');
    }
    /**
     * Return the index of this row in the table.
     */
    get rowIndex() {
        return this.ancestor(TableNode_TableNode)
            .children(TableRowNode_TableRowNode)
            .indexOf(this);
    }
}

// CONCATENATED MODULE: ./packages/plugin-table/src/TableNode.ts



class TableNode_TableNode extends VElement_VElement {
    constructor(params) {
        super({ htmlTag: 'TABLE' });
        this.breakable = false;
        if (params && params.rowCount && params.columnCount) {
            this.reset(params.rowCount, params.columnCount);
        }
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    /**
     * @override
     */
    get name() {
        return super.name + ': ' + this.rowCount + 'x' + this.columnCount;
    }
    /**
     * Return an array of rows in this table, as arrays of cells.
     */
    get rows() {
        return this.children(TableRowNode_TableRowNode).map(row => row.children(TableCellNode_TableCellNode));
    }
    /**
     * Return an array of columns in this table, as arrays of cells.
     */
    get columns() {
        const columns = new Array(this.columnCount).fill(undefined);
        return columns.map((_, columnIndex) => this.children(TableRowNode_TableRowNode).map(row => row.children(TableCellNode_TableCellNode)[columnIndex]));
    }
    /**
     * Return the number of rows in this table.
     */
    get rowCount() {
        return this.children(TableRowNode_TableRowNode).length;
    }
    /**
     * Return the number of columns in this table.
     */
    get columnCount() {
        return this.firstChild(TableRowNode_TableRowNode).children(TableCellNode_TableCellNode).length;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return the cell of this table that can be found at the given coordinates,
     * if any.
     *
     * @param rowIndex
     * @param columnIndex
     */
    getCellAt(rowIndex, columnIndex) {
        return this.children(TableRowNode_TableRowNode)[rowIndex].children(TableCellNode_TableCellNode)[columnIndex];
    }
    /**
     * Add a new row above the reference row (the row of the given reference
     * cell). Copy the styles and colspans of the cells of the reference row. If
     * the reference row traverses a rowspan, extend that rowspan.
     * If no `referenceCell` was passed, add a row on top of the table.
     *
     * @param [referenceCell]
     */
    addRowAbove(referenceCell) {
        if (!referenceCell) {
            referenceCell = this.firstDescendant(TableCellNode_TableCellNode);
        }
        const referenceRow = referenceCell.ancestor(TableRowNode_TableRowNode);
        const newRow = referenceRow.clone();
        referenceRow.before(newRow);
        for (const cell of referenceRow.children(TableCellNode_TableCellNode)) {
            const clone = cell.clone();
            newRow.append(clone);
            // Handle managers.
            const manager = cell.managerCell;
            if (manager) {
                if (manager.rowIndex === referenceRow.rowIndex) {
                    // If the current cell's manager is in the reference row,
                    // the clone's manager should be that manager's clone.
                    const managerClone = this.getCellAt(newRow.rowIndex, manager.columnIndex);
                    clone.mergeWith(managerClone);
                }
                else {
                    clone.mergeWith(manager);
                }
            }
        }
    }
    /**
     * Add a new row below the reference row (the row of the given reference
     * cell). Copy the styles and colspans of the cells of the reference row. If
     * the reference row traverses a rowspan, extend that rowspan.
     * If no `referenceCell` was passed, add a row at the bottom of the table.
     * Note: a rowspan ending at the reference cell is not extended.
     *
     * @param [referenceCell]
     */
    addRowBelow(referenceCell) {
        if (!referenceCell) {
            referenceCell = this.lastDescendant(TableCellNode_TableCellNode);
        }
        const rowIndex = referenceCell.rowIndex + referenceCell.rowspan - 1;
        const referenceRow = this.children(TableRowNode_TableRowNode)[rowIndex];
        const newRow = referenceRow.clone();
        referenceRow.after(newRow);
        for (const cell of referenceRow.children(TableCellNode_TableCellNode)) {
            const clone = cell.clone();
            newRow.append(clone);
            // Handle managers.
            if (cell.managerCell) {
                const manager = cell.managerCell;
                const managerEndRow = manager.rowIndex + manager.rowspan - 1;
                if (managerEndRow === rowIndex && manager.columnIndex !== cell.columnIndex) {
                    // Take the new row equivalent of the above cell's manager
                    // (copy colspan).
                    clone.mergeWith(this.getCellAt(newRow.rowIndex, manager.columnIndex));
                }
                else if (managerEndRow !== rowIndex) {
                    // Take the manager cell of the above cell (extend rowspan),
                    // only if said manager's rowspan is not ending with the
                    // above cell.
                    clone.mergeWith(manager);
                }
            }
            else if (cell.rowspan > 1) {
                // If the cell has a rowspan, extend it.
                clone.mergeWith(cell);
            }
        }
    }
    /**
     * Add a new column before the reference column (the column of the given
     * reference cell). Copy the styles and rowspans of the cells of the
     * reference column. If the reference column traverses a colspan, extend
     * that colspan.
     * If no `referenceCell` was passed, add a column to the left of the table.
     *
     * @param [referenceCell]
     */
    addColumnBefore(referenceCell) {
        if (!referenceCell) {
            referenceCell = this.firstDescendant(TableCellNode_TableCellNode);
        }
        const referenceColumn = referenceCell.column;
        for (const cell of referenceColumn) {
            const clone = cell.clone();
            cell.before(clone);
            // Handle managers.
            const manager = cell.managerCell;
            if (manager) {
                if (manager.columnIndex === referenceCell.columnIndex) {
                    // If the current cell's manager is in the reference column,
                    // the clone's manager should be that manager's clone.
                    const managerClone = this.getCellAt(manager.rowIndex, clone.columnIndex);
                    clone.mergeWith(managerClone);
                }
                else {
                    clone.mergeWith(manager);
                }
            }
        }
    }
    /**
     * Add a new column after the reference column (the column of the given
     * reference cell). Copy the styles and rowspans of the cells of the
     * reference column. If the reference column traverses a colpan, extend that
     * colspan.
     * If no `referenceCell` was passed, add a column to the right of the table.
     * Note: a colspan ending at the reference cell is not extended.
     *
     * @param [referenceCell]
     */
    addColumnAfter(referenceCell) {
        if (!referenceCell) {
            referenceCell = this.lastDescendant(TableCellNode_TableCellNode);
        }
        const columnIndex = referenceCell.columnIndex + referenceCell.colspan - 1;
        const referenceColumn = this.columns[columnIndex];
        for (const cell of referenceColumn) {
            const clone = cell.clone();
            cell.after(clone);
            // Handle managers.
            if (cell.managerCell) {
                const manager = cell.managerCell;
                const managerEndColumn = manager.columnIndex + manager.colspan - 1;
                if (managerEndColumn === columnIndex && manager.rowIndex !== cell.rowIndex) {
                    // Take the new column equivalent of the previous cell's
                    // manager (copy rowspan).
                    clone.mergeWith(this.getCellAt(manager.rowIndex, clone.columnIndex));
                }
                else if (managerEndColumn !== columnIndex) {
                    // Take the manager cell of the previous cell (extend
                    // colspan), only if said manager's colspan is not ending
                    // with the previous cell.
                    clone.mergeWith(manager);
                }
            }
            else if (cell.colspan > 1) {
                // If the cell has a colspan, extend it.
                clone.mergeWith(cell);
            }
        }
    }
    /**
     * Empty this table and refill it with the given number of rows and columns.
     *
     * @param rowCount
     * @param columnCount
     */
    reset(rowCount, columnCount) {
        this.empty();
        const rows = [];
        for (let rowNumber = 0; rowNumber < rowCount; rowNumber += 1) {
            rows.push(new TableRowNode_TableRowNode());
        }
        for (const row of rows) {
            const cells = [];
            for (let colNumber = 0; colNumber < columnCount; colNumber += 1) {
                cells.push(new TableCellNode_TableCellNode());
            }
            row.append(...cells);
        }
        this.append(...rows);
    }
}

// CONCATENATED MODULE: ./packages/plugin-table/src/TableCellNode.ts




class TableCellNode_TableCellNode extends ContainerNode_ContainerNode {
    constructor(params) {
        super(params);
        this.breakable = false;
        this.__managedCells = new VersionableSet_VersionableSet();
        this.header = (params === null || params === void 0 ? void 0 : params.header) || false;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     *
     *  @override
     */
    clone(deepClone, params) {
        const defaults = {
            header: this.header,
        };
        return super.clone(deepClone, Object.assign(Object.assign({}, defaults), params));
    }
    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------
    /**
     * @override
     */
    get name() {
        let coordinatesRepr = ' <(' + this.rowIndex + ', ' + this.columnIndex + ')';
        if (this.colspan > 1 || this.rowspan > 1) {
            const endRow = this.rowIndex + this.rowspan - 1;
            const endColumn = this.columnIndex + this.colspan - 1;
            coordinatesRepr += ':(' + endRow + ', ' + endColumn + ')';
        }
        coordinatesRepr += '>';
        return (super.name +
            coordinatesRepr +
            (this.header ? ': header' : '') +
            (this.isActive() ? '' : ' (inactive)'));
    }
    /**
     * Return the cell that manages this cell, if any.
     */
    get managerCell() {
        return this.__managerCell;
    }
    /**
     * Return the set of cells that this cell manages.
     */
    get managedCells() {
        return new Set(this.__managedCells);
    }
    /**
     * Return the computed column span of this cell, in function of its managed
     * cells.
     */
    get colspan() {
        const cellsArray = Array.from(this.managedCells);
        const sameRowCells = cellsArray.filter(cell => cell.rowIndex === this.rowIndex);
        return 1 + sameRowCells.length;
    }
    /**
     * Return the computed row span of this cell, in function of its managed
     * cells.
     */
    get rowspan() {
        const cellsArray = Array.from(this.managedCells);
        const sameColumnCells = cellsArray.filter(cell => cell.columnIndex === this.columnIndex);
        return 1 + sameColumnCells.length;
    }
    /**
     * Return the row to which this cell belongs.
     */
    get row() {
        return this.ancestor(TableRowNode_TableRowNode).children(TableCellNode_TableCellNode);
    }
    /**
     * Return the column to which this cell belongs, as an array of cells.
     */
    get column() {
        return this.ancestor(TableNode_TableNode).columns[this.columnIndex];
    }
    /**
     * Return the index of the row to which this cell belongs.
     */
    get rowIndex() {
        return this.ancestor(TableRowNode_TableRowNode).rowIndex;
    }
    /**
     * Return the index of the column to which this cell belongs.
     */
    get columnIndex() {
        return this.parent.children(TableCellNode_TableCellNode).indexOf(this);
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return true if this cell is active (ie not managed by another cell).
     */
    isActive() {
        return !this.managerCell;
    }
    /**
     * Set the given cell as manager of this cell.
     * Note: A cell managed by another cell also copies its manager's attributes
     * and properties and hands over its children to its manager.
     *
     * @override
     */
    mergeWith(newManager) {
        const thisTable = this.ancestor(TableNode_TableNode);
        const otherTable = newManager.ancestor(TableNode_TableNode);
        if (!(newManager instanceof TableCellNode_TableCellNode) || thisTable !== otherTable)
            return;
        this.__managerCell = newManager;
        newManager.manage(this);
    }
    /**
     * Unmerge this cell from its manager.
     */
    unmerge() {
        const manager = this.__managerCell;
        if (manager) {
            this.__managerCell = null;
            // If we just removed this cell's manager, also remove this cell
            // from the old manager's managed cells.
            manager.unmanage(this);
        }
    }
    /**
     * Set the given cell as managed by this cell.
     * Note: A cell managed by another cell also copies its manager's modifiers
     * and properties and hands over its children to its manager.
     *
     * @param cell
     */
    manage(cell) {
        this.__managedCells.add(cell);
        // Copy the manager's modifiers and properties.
        cell.modifiers = this.modifiers.clone();
        cell.header = this.header;
        // Move the children to the manager.
        this.append(...cell.childVNodes);
        // Hand the managed cells over to the manager.
        for (const managedCell of cell.managedCells) {
            managedCell.mergeWith(this);
            cell.unmanage(managedCell);
        }
        // Copy the manager's row if an entire row was merged
        const row = cell.ancestor(TableRowNode_TableRowNode);
        if (row) {
            const cells = row.children(TableCellNode_TableCellNode);
            const rowIsMerged = cells.every(rowCell => rowCell.managerCell === this);
            if (rowIsMerged) {
                const managerRow = cell.managerCell.ancestor(TableRowNode_TableRowNode);
                row.header = managerRow.header;
                row.modifiers = managerRow.modifiers.clone();
            }
        }
        // Ensure reciprocity.
        if (cell.managerCell !== this) {
            cell.mergeWith(this);
        }
    }
    /**
     * Restore the independence of the given cell.
     *
     * @param cell
     */
    unmanage(cell) {
        this.__managedCells.delete(cell);
        // Ensure reciprocity.
        if (cell.managerCell === this) {
            cell.unmerge();
        }
    }
}

// CONCATENATED MODULE: ./packages/core/src/VRange.ts







class VRange_VRange {
    constructor(editor, boundaryPoints, _mode) {
        this.editor = editor;
        this._mode = _mode;
        this.start = new MarkerNode_MarkerNode();
        this.end = new MarkerNode_MarkerNode();
        // If a range context is given, adapt this range to match it.
        if (boundaryPoints) {
            const [start, end] = boundaryPoints;
            const [startNode, startPosition] = start;
            const [endNode, endPosition] = end;
            if (endPosition === RelativePosition.AFTER) {
                this.setEnd(endNode, endPosition);
                this.setStart(startNode, startPosition);
            }
            else {
                this.setStart(startNode, startPosition);
                this.setEnd(endNode, endPosition);
            }
        }
    }
    /**
     * Return the context of a collapsed range at the given location, targetting
     * a reference VNode and specifying the position relative to that VNode.
     *
     * @param reference
     * @param position
     */
    static at(reference, position = RelativePosition.BEFORE) {
        return VRange_VRange.selecting(reference, position, reference, position);
    }
    /**
     * Return the context of a range at the location of the given range.
     *
     * @param range
     */
    static clone(range) {
        return [
            [range.start, RelativePosition.BEFORE],
            [range.end, RelativePosition.AFTER],
        ];
    }
    static selecting(startNode, startPosition = RelativePosition.BEFORE, endNode = startNode, endPosition = RelativePosition.AFTER) {
        if (startPosition instanceof AbstractNode_AbstractNode) {
            endNode = startPosition;
            startPosition = RelativePosition.BEFORE;
        }
        return [
            [startNode, startPosition],
            [endNode, endPosition],
        ];
    }
    get mode() {
        return this._mode || this.editor.mode;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    get startContainer() {
        return this.start.parent;
    }
    get endContainer() {
        return this.end.parent;
    }
    /**
     * Return true if the range is collapsed.
     */
    isCollapsed() {
        if (!this.startContainer || !this.endContainer)
            return;
        const startIndex = this.start.parent.childVNodes.indexOf(this.start);
        return this.startContainer.childVNodes[startIndex + 1] === this.end;
    }
    /**
     * Return true if the start or end of the range is contained within the
     * given container.
     *
     * @param container
     */
    isIn(container) {
        let startAncestor = this.start;
        let endAncestor = this.end;
        while (startAncestor || endAncestor) {
            if (startAncestor === container || endAncestor === container) {
                return true;
            }
            startAncestor = startAncestor === null || startAncestor === void 0 ? void 0 : startAncestor.parent;
            endAncestor = endAncestor === null || endAncestor === void 0 ? void 0 : endAncestor.parent;
        }
        return false;
    }
    selectedNodes(predicate) {
        const selectedNodes = [];
        let node = this.start;
        const bound = this.end.next();
        const endContainers = this.end.ancestors();
        while ((node = node.next()) && node !== bound) {
            if (!endContainers.includes(node) &&
                !(node instanceof FragmentNode_FragmentNode) &&
                this.mode.is(node, RuleProperty.EDITABLE) && (node === null || node === void 0 ? void 0 : node.test(predicate))) {
                selectedNodes.push(node);
            }
        }
        const alreadyTested = new Set();
        for (const selectedNode of selectedNodes) {
            // Find the next ancestor whose children are all selected
            // and add it to the list.
            // TODO: Ideally, selected nodes should be returned in DFS order.
            const ancestor = selectedNode.parent;
            if (ancestor && !alreadyTested.has(ancestor)) {
                alreadyTested.add(ancestor);
                const allChildrenSelected = ancestor
                    .children()
                    .every(child => selectedNodes.includes(child));
                if (allChildrenSelected &&
                    !selectedNodes.includes(ancestor) &&
                    !(ancestor instanceof FragmentNode_FragmentNode) &&
                    this.mode.is(ancestor, RuleProperty.EDITABLE) &&
                    ancestor.test(predicate)) {
                    selectedNodes.push(ancestor);
                }
            }
        }
        return selectedNodes;
    }
    targetedNodes(predicate) {
        const targetedNodes = this.traversedNodes(predicate);
        if (!this.end.previousSibling()) {
            // When selecting a container and the space between it and the next
            // one (eg. triple click), don't return the next container as well.
            targetedNodes.pop();
        }
        const closestStartAncestor = this.start.ancestor(predicate);
        if (closestStartAncestor && this.mode.is(closestStartAncestor, RuleProperty.EDITABLE)) {
            targetedNodes.unshift(closestStartAncestor);
        }
        else if (closestStartAncestor) {
            const children = [...closestStartAncestor.childVNodes].reverse();
            for (const child of children) {
                if (!targetedNodes.includes(child) &&
                    this.mode.is(child, RuleProperty.EDITABLE) &&
                    child.test(predicate)) {
                    targetedNodes.unshift(child);
                }
            }
        }
        return targetedNodes;
    }
    traversedNodes(predicate) {
        const traversedNodes = [];
        let node = this.start;
        const bound = this.end.next();
        while ((node = node.next()) && node !== bound) {
            if (this.mode.is(node, RuleProperty.EDITABLE) && node.test(predicate)) {
                traversedNodes.push(node);
            }
        }
        return traversedNodes;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Collapse the range.
     *
     * @param [edge] range edge on which to collapse
     */
    collapse(edge = this.start) {
        if (edge === this.start) {
            this.setEnd(edge);
        }
        else if (edge === this.end) {
            this.setStart(edge);
        }
    }
    /**
     * Set the range's start point (in traversal order) at the given location,
     * targetting a `reference` VNode and specifying the `position` in reference
     * to that VNode ('BEFORE', 'AFTER'), like in an `xpath.
     *
     * @param reference
     * @param [position]
     */
    setStart(reference, position = RelativePosition.BEFORE) {
        if (position === RelativePosition.BEFORE) {
            reference = reference.firstLeaf();
        }
        else if (position === RelativePosition.AFTER) {
            reference = reference.lastLeaf();
        }
        if (reference instanceof ContainerNode_ContainerNode && !reference.hasChildren()) {
            reference.prepend(this.start);
        }
        else if (position === RelativePosition.AFTER && reference !== this.end) {
            // We check that `reference` isn't `this.end` to avoid a backward
            // collapsed range.
            reference.after(this.start);
        }
        else if (position === RelativePosition.INSIDE) {
            reference.append(this.start);
        }
        else {
            reference.before(this.start);
        }
    }
    /**
     * Set the range's end point (in traversal order) at the given location,
     * targetting a `reference` VNode and specifying the `position` in reference
     * to that VNode ('BEFORE', 'AFTER'), like in an `xpath.
     *
     * @param reference
     * @param [position]
     */
    setEnd(reference, position = RelativePosition.AFTER) {
        if (position === RelativePosition.BEFORE) {
            reference = reference.firstLeaf();
        }
        else if (position === RelativePosition.AFTER) {
            reference = reference.lastLeaf();
        }
        if (reference instanceof ContainerNode_ContainerNode && !reference.hasChildren()) {
            reference.append(this.end);
        }
        else if (position === RelativePosition.BEFORE && reference !== this.start) {
            // We check that `reference` isn't `this.start` to avoid a backward
            // collapsed range.
            reference.before(this.end);
        }
        else if (position === RelativePosition.INSIDE) {
            reference.append(this.end);
        }
        else {
            reference.after(this.end);
        }
    }
    /**
     * Extend this range in such a way that it includes the given node.
     *
     * This method moves the boundary marker that is closest to the given node
     * up or down the tree in order to include the given node into the range.
     * Because of that, calling this method will always result in a range that
     * is at least the size that it was prior to calling it, and usually bigger.
     *
     * @param targetNode The node to extend the range to.
     */
    extendTo(targetNode) {
        let position;
        if (targetNode.isBefore(this.start)) {
            targetNode = targetNode.previous();
            if (targetNode.hasChildren()) {
                targetNode = targetNode.firstLeaf();
                position = RelativePosition.BEFORE;
            }
            else {
                position = RelativePosition.AFTER;
            }
            if (targetNode && this.end.nextSibling() !== targetNode) {
                this.setStart(targetNode, position);
            }
        }
        else if (targetNode.isAfter(this.end)) {
            if (targetNode.hasChildren()) {
                targetNode = targetNode.next();
                position = RelativePosition.BEFORE;
            }
            else {
                position = RelativePosition.AFTER;
            }
            if (targetNode) {
                this.setEnd(targetNode, position);
            }
        }
    }
    /**
     * Split the range containers up to their common ancestor. Return all
     * children of the common ancestor that are targeted by the range after the
     * split. If a predicate is given, splitting continues up to and including
     * the node closest to the common ancestor that matches the predicate.
     *
     * @param predicate
     */
    split(predicate) {
        const ancestor = this.startContainer.commonAncestor(this.endContainer);
        const closest = ancestor.closest(predicate);
        const container = closest ? closest.parent : ancestor;
        // Split the start ancestors.
        let start = this.start;
        do {
            let startAncestor = start.parent;
            // Do not split at the start edge of a node.
            if (start.previousSibling()) {
                startAncestor = startAncestor.splitAt(start);
            }
            start = startAncestor;
        } while (start.parent !== container);
        // Split the end ancestors.
        let end = this.end;
        do {
            const endAncestor = end.parent;
            // Do not split at the end edge of a node.
            if (end.nextSibling()) {
                endAncestor.splitAt(end);
                endAncestor.append(end);
            }
            end = endAncestor;
        } while (end.parent !== container);
        // Return all top-most split nodes between and including start and end.
        const nodes = [];
        let node = start;
        while (node !== end) {
            nodes.push(node);
            node = node.nextSibling();
        }
        nodes.push(end);
        return nodes;
    }
    /**
     * Empty the range by removing selected nodes and collapsing it by merging
     * nodes between start and end.
     */
    empty() {
        const removableNodes = this.selectedNodes(node => {
            // TODO: Replace Table check with complex table selection support.
            return this.mode.is(node, RuleProperty.EDITABLE) && !(node instanceof TableCellNode_TableCellNode);
        });
        // Remove selected nodes without touching the start range's ancestors.
        const startAncestors = this.start.ancestors();
        for (const node of removableNodes.filter(node => !startAncestors.includes(node))) {
            node.remove();
        }
        // Collapse the range by merging nodes between start and end.
        if (this.startContainer !== this.endContainer) {
            const commonAncestor = this.start.commonAncestor(this.end);
            let ancestor = this.endContainer.parent;
            while (ancestor !== commonAncestor) {
                if (ancestor.children().length > 1) {
                    ancestor.splitAt(this.endContainer);
                }
                if (this.mode.is(this.endContainer, RuleProperty.BREAKABLE) &&
                    this.mode.is(this.startContainer, RuleProperty.EDITABLE) &&
                    this.mode.is(this.endContainer, RuleProperty.EDITABLE)) {
                    this.endContainer.mergeWith(ancestor);
                }
                ancestor = ancestor.parent;
            }
            if (this.mode.is(this.endContainer, RuleProperty.BREAKABLE) &&
                this.mode.is(this.startContainer, RuleProperty.EDITABLE) &&
                this.mode.is(this.endContainer, RuleProperty.EDITABLE)) {
                this.endContainer.mergeWith(this.startContainer);
            }
        }
    }
    /**
     * Remove this range from its VDocument.
     */
    remove() {
        this.start.remove();
        this.end.remove();
    }
}

// CONCATENATED MODULE: ./packages/core/src/VSelection.ts



const ANCHOR_CHAR = '[';
const FOCUS_CHAR = ']';
var Direction;
(function (Direction) {
    Direction["BACKWARD"] = "BACKWARD";
    Direction["FORWARD"] = "FORWARD";
})(Direction || (Direction = {}));
class VSelection_VSelection {
    constructor(editor) {
        this.editor = editor;
        this.range = new VRange_VRange(this.editor);
        this._direction = Direction.FORWARD;
    }
    get anchor() {
        return this.direction === Direction.FORWARD ? this.range.start : this.range.end;
    }
    get focus() {
        return this.direction === Direction.FORWARD ? this.range.end : this.range.start;
    }
    get direction() {
        return this._direction;
    }
    isCollapsed() {
        return this.range.isCollapsed();
    }
    /**
     * Update the selection according to the given description.
     *
     * @param selection
     */
    set(selection) {
        this._direction = selection.direction;
        this.select(selection.anchorNode, selection.anchorPosition, selection.focusNode, selection.focusPosition);
    }
    /**
     * Set a collapsed selection at the given location, targetting a `reference`
     * VNode and specifying the `position` in reference to that VNode ('BEFORE',
     * 'AFTER'), like in an `xpath`.
     *
     * @param position
     * @param reference
     */
    setAt(reference, position = RelativePosition.BEFORE) {
        this.setAnchor(reference, position);
        this.collapse();
    }
    select(anchorNode, anchorPosition = RelativePosition.BEFORE, focusNode = anchorNode, focusPosition = RelativePosition.AFTER) {
        if (anchorPosition instanceof AbstractNode_AbstractNode) {
            focusNode = anchorPosition;
            anchorPosition = RelativePosition.BEFORE;
        }
        if (focusPosition === RelativePosition.AFTER) {
            this.setFocus(focusNode, focusPosition);
            this.setAnchor(anchorNode, anchorPosition);
        }
        else {
            this.setAnchor(anchorNode, anchorPosition);
            this.setFocus(focusNode, focusPosition);
        }
    }
    /**
     * Set the anchor of the selection by targetting a `reference` VNode and
     * specifying the `position` in reference to that VNode ('BEFORE', 'AFTER'),
     * like in an `xpath`. If no relative position if given, include the
     * reference node in the selection.
     *
     * @param reference
     * @param [position]
     */
    setAnchor(reference, position = RelativePosition.BEFORE) {
        if (this.direction === Direction.FORWARD) {
            this.range.setStart(reference, position);
        }
        else {
            this.range.setEnd(reference, position);
        }
    }
    /**
     * Set the focus of the selection by targetting a `reference` VNode and
     * specifying the `position` in reference to that VNode ('BEFORE', 'AFTER'),
     * like in an `xpath`. If no relative position if given, include the
     * reference node in the selection.
     *
     * @param reference
     * @param [position]
     */
    setFocus(reference, position = RelativePosition.AFTER) {
        if (this.direction === Direction.FORWARD) {
            this.range.setEnd(reference, position);
        }
        else {
            this.range.setStart(reference, position);
        }
    }
    /**
     * Extend the selection from its anchor to the given location, targetting a
     * `reference` VNode and specifying the `direction` of the extension.
     *
     * @param reference
     * @param [direction] default: Direction.FORWARD
     */
    extendTo(reference, direction = Direction.FORWARD) {
        let position;
        if (direction === Direction.FORWARD) {
            if (reference.hasChildren()) {
                reference = reference.next();
                reference = reference.firstLeaf();
                position = RelativePosition.BEFORE;
            }
            else {
                position = RelativePosition.AFTER;
            }
        }
        else {
            reference = reference.previous();
            if (reference.hasChildren()) {
                reference = reference.firstLeaf();
                position = RelativePosition.BEFORE;
            }
            else {
                position = RelativePosition.AFTER;
            }
        }
        if (reference) {
            this.setFocus(reference, position);
        }
    }
    /**
     * Collapse the selection on its anchor.
     *
     */
    collapse() {
        this.range.collapse(this.anchor);
    }
}

// CONCATENATED MODULE: ./packages/plugin-keymap/src/Keymap.ts

var Platform;
(function (Platform) {
    Platform["MAC"] = "mac";
    Platform["PC"] = "pc";
})(Platform || (Platform = {}));
var LEVEL;
(function (LEVEL) {
    LEVEL[LEVEL["DEFAULT"] = 0] = "DEFAULT";
    LEVEL[LEVEL["USER"] = 1] = "USER";
})(LEVEL || (LEVEL = {}));
/**
 * Keymap allow to add and remove shortucts and provide a function to match a
 * keyboard event with the registered shortcuts patterns.
 *
 * ## Adding shortcuts
 * The expression to describe a shortuct is zero or more `modifiers` and one
 * `hotkey` joined with the symbol `+`.
 *
 * ### Modifiers
 * - SHIFT
 * - ALT
 * - CTRL
 * - META
 * - CMD (alias of META)
 *
 * Example:
 * ```typescript
 * // using a modifier and one key
 * keymap.bind('CTRL+A', 'commandIdentifier')
 * // using multiples modifiers and one key
 * keymap.bind('CTRL+ALT+A', 'commandIdentifier')
 * ```
 *
 * ### Hotkeys
 * A hotkey can be wether a `key` or `code`.
 *
 * #### Key
 * The syntax to describe a `key` is to write the `key` as it is. The convention
 * is to write it in uppercase.
 *
 * Example:
 * ```typescript
 * keymap.bind('CTRL+A', 'commandIdentifier')
 * ```
 * The list of possible `key` values are defined in the following link:
 * https://www.w3.org/TR/uievents/#dom-keyboardevent-key
 *
 * #### Code
 * The syntax to describe a `code` is to write `<code>` (surrounded by "<" and
 * ">").
 *
 * Example:
 * ```typescript
 * keymap.bind('CTRL+<KeyA>', 'commandIdentifier')
 * ```
 *
 * The list of possible `code` values are defined in the following link:
 * https://www.w3.org/TR/uievents/#dom-keyboardevent-key
 *
 * ## Removing shortucts
 * To remove a shortuct, call `bind` without specifying a commandIdentifier.
 *
 * Example:
 * ```typescript
 * keymap.bind('CTRL+<KeyA>')
 * ```
 */
class Keymap_Keymap extends JWPlugin {
    constructor(editor, config) {
        super(editor, config);
        this.editor = editor;
        this.config = config;
        this.loaders = {
            shortcuts: this._loadShortcuts,
        };
        this.mappings = [...new Array(LEVEL.USER + 1)].map(() => []);
        this.defaultMappings = [];
        this.userMappings = [];
        if (!config.platform) {
            const isMac = navigator.platform.match(/Mac/);
            config.platform = isMac ? Platform.MAC : Platform.PC;
        }
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Bind a shortuct.
     *
     * If there is no `command.commandId`, it means that we want nothing to
     * execute, thus replacing the command originally bound on this shortcut.
     *
     * @param pattern
     * @param command
     */
    bind(pattern, command, level = LEVEL.DEFAULT) {
        this.mappings[level].push({
            pattern: this.parsePattern(pattern),
            configuredCommand: command,
        });
    }
    /**
     * Return all configured commands which shortcut match the given `keyEvent`.
     *
     * @param keyEvent
     */
    match(keyEvent) {
        var _a;
        const matchingCommands = [];
        for (let level = LEVEL.USER; level >= 0; level--) {
            for (const shortcut of this.mappings[level]) {
                const modifiers = shortcut.pattern.modifiers;
                let match;
                if ('code' in shortcut.pattern) {
                    match = shortcut.pattern.code === keyEvent.code;
                }
                else {
                    // In rare case the KeyboardEvent `key` is undefined.
                    match = shortcut.pattern.key === ((_a = keyEvent.key) === null || _a === void 0 ? void 0 : _a.toUpperCase());
                }
                match =
                    match &&
                        modifiers.has('CTRL') === keyEvent.ctrlKey &&
                        modifiers.has('SHIFT') === keyEvent.shiftKey &&
                        modifiers.has('META') === keyEvent.metaKey &&
                        modifiers.has('ALT') === keyEvent.altKey;
                if (match) {
                    if (!shortcut.configuredCommand.commandId) {
                        // An `undefined` command unbounds the other commands
                        // previously registered on this shortcut.
                        matchingCommands.length = 0;
                    }
                    matchingCommands.push(shortcut.configuredCommand);
                }
            }
            if (matchingCommands.length) {
                // Matches were found at this level so do not look lower.
                break;
            }
        }
        return matchingCommands;
    }
    /**
     * Parse a string that represents a pattern and return a `ShortuctPattern`.
     * Supported pattern is: [modifier+]*[<code>|key]
     *
     * @param pattern
     */
    parsePattern(pattern) {
        const tokens = pattern
            .replace(/cmd/gi, 'META')
            .split(/[+]/)
            .map(token => token.trim());
        const keyCode = tokens.pop();
        const modifiers = new Set(tokens.map(token => token.toUpperCase()));
        if (!keyCode) {
            throw new Error('You must have at least one key or code.');
        }
        // There are two ways to specify a shortcut hotkey : key or code
        // - "CTRL+1" is the modifier CTRL with the event.key "1".
        // - "CTRL+<Key1>" is the modifier CTRL with the event.code "Key1"
        const codeMatch = keyCode.match(/^<(\w+)>$/);
        if (codeMatch && codeMatch.length > 1) {
            return { code: codeMatch[1], modifiers };
        }
        else {
            return { key: keyCode.toUpperCase(), modifiers };
        }
    }
    /**
     * Take a `ShortuctPattern` and return a string that represents a pattern,
     * in the form [modifier+]*[<code>|key].
     *
     * @param pattern
     */
    stringifyPattern(pattern) {
        const parts = Array.from(pattern.modifiers);
        if ('code' in pattern) {
            parts.push(pattern.code);
        }
        else if ('key' in pattern) {
            parts.push(pattern.key);
        }
        return parts.join('+');
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Load a shortcut in the keymap depending on the platform.
     *
     * - If the shortuct has no platform property; load the shortuct in both
     *   platform ('mac' and 'pc').
     * - If the shortuct has no platform property and the current platform is
     *   mac, modify the ctrl key to meta key.
     * - If the shortuct has a platform property, only load the shortcut for
     *   that platform.
     * - If no `mapping.commandId` is declared, it means removing the shortcut.
     *
     * @param shortcuts The shortuct definitions.
     * @param source The source of the shortcuts.
     */
    _loadShortcuts(shortcuts, source) {
        for (const shortcut of [...shortcuts]) {
            // A shortcut is a configured command on which the properties
            // `pattern`, and optionally `platform`, were set.
            const platform = shortcut.platform;
            if (!platform || platform === this.config.platform) {
                let pattern = shortcut.pattern;
                const command = shortcut;
                // Patterns using the CTRL modifier target CMD instead for Mac.
                if (!platform && this.config.platform === Platform.MAC) {
                    pattern = shortcut.pattern.replace(/ctrl/gi, 'CMD');
                }
                if (source instanceof JWPlugin) {
                    this.bind(pattern, command, LEVEL.DEFAULT);
                }
                else {
                    this.bind(pattern, command, LEVEL.USER);
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/core/src/VNodes/SeparatorNode.ts

/**
 * This class represents an atomic node that is used as a content separator.
 */
class SeparatorNode_SeparatorNode extends AtomicNode_AtomicNode {
}

// CONCATENATED MODULE: ./packages/core/src/JWEditor.ts
















var EditorStage;
(function (EditorStage) {
    EditorStage["CONFIGURATION"] = "configuration";
    EditorStage["STARTING"] = "starting";
    EditorStage["EDITION"] = "edition";
})(EditorStage || (EditorStage = {}));
class JWEditor_JWEditor {
    constructor() {
        this._stage = EditorStage.CONFIGURATION;
        this.plugins = new Map();
        this.configuration = {
            defaults: {
                Container: ContainerNode_ContainerNode,
                Atomic: AtomicNode_AtomicNode,
                Separator: SeparatorNode_SeparatorNode,
            },
            plugins: [],
            loadables: {},
        };
        this._memoryID = 0;
        this.loaders = {};
        this._mutex = Promise.resolve();
        // Use a set so that when asynchronous functions are called we ensure that
        // each command batch is waited for.
        this.preventRenders = new Set();
        this.enableRender = true;
        this.modes = {
            default: new Mode_Mode({
                id: 'default',
                rules: [],
            }),
        };
        this.mode = this.modes.default;
        this.dispatcher = new Dispatcher(this);
        this.plugins = new Map();
        this.selection = new VSelection_VSelection(this);
        this.contextManager = new ContextManager(this, this._execSubCommand.bind(this));
        // Core is a special mandatory plugin that handles the matching between
        // the commands supported in the core of the editor and the VDocument.
        this.load(Core_Core);
        this.load(Keymap_Keymap);
    }
    /**
     * Set the current mode of the editor.
     */
    setMode(modeIdentifier) {
        this.mode = this.modes[modeIdentifier];
    }
    /**
     * Start the editor on the editable DOM node set on this editor instance.
     */
    async start() {
        this._stage = EditorStage.STARTING;
        this._loadPlugins();
        // Load editor-level loadables.
        if (this.configuration.loadables) {
            for (const loadableId of Object.keys(this.loaders)) {
                const loadable = this.configuration.loadables[loadableId];
                if (loadable) {
                    this.loaders[loadableId](loadable, this.configuration);
                }
            }
        }
        for (const mode of this.configuration.modes || []) {
            this.modes[mode.id] = new Mode_Mode(mode);
        }
        if (this.configuration.mode) {
            this.setMode(this.configuration.mode);
        }
        // create memory
        this.memoryInfo = makeVersionable({ commandNames: [], uiCommand: false });
        this.memory = new Memory_Memory();
        this.memory.attach(this.memoryInfo);
        this.memory.create(this._memoryID.toString());
        // Start all plugins in the first memory slice.
        await this.execCommand(async () => {
            for (const plugin of this.plugins.values()) {
                await plugin.start();
            }
        });
        this._stage = EditorStage.EDITION;
    }
    load(PluginOrLoadables, config) {
        // Actual loading is deferred to `start`.
        if (this._stage !== EditorStage.CONFIGURATION) {
            throw new StageError(EditorStage.CONFIGURATION);
        }
        else if (isConstructor(PluginOrLoadables, JWPlugin)) {
            // Add the plugin to the configuration.
            const Plugin = PluginOrLoadables;
            const plugins = this.configuration.plugins;
            const index = plugins.findIndex(([p]) => p === Plugin);
            if (index !== -1) {
                // Remove this module from the config to avoid loading it twice.
                plugins.splice(index, 1);
            }
            plugins.push([Plugin, config || {}]);
        }
        else {
            // Add the loadables to the configuration.
            const configuredLoadables = this.configuration.loadables;
            for (const loadableIdentifier of Object.keys(PluginOrLoadables)) {
                const loadables = PluginOrLoadables[loadableIdentifier];
                if (configuredLoadables[loadableIdentifier]) {
                    configuredLoadables[loadableIdentifier].push(...loadables);
                }
                else {
                    configuredLoadables[loadableIdentifier] = [...loadables];
                }
            }
        }
    }
    /**
     * Load the plugins specified in the editor configuration.
     *
     */
    _loadPlugins() {
        // Resolve dependencies.
        const Plugins = [...this.configuration.plugins];
        for (let offset = 1; offset <= Plugins.length; offset++) {
            const index = Plugins.length - offset;
            const [Plugin] = Plugins[index];
            for (const Dependency of [...Plugin.dependencies].reverse()) {
                const depIndex = Plugins.findIndex(([P]) => P === Dependency);
                if (depIndex === -1) {
                    // Load the missing dependency with no config parameters.
                    Plugins.splice(index, 0, [Dependency, {}]);
                }
                else if (depIndex > index) {
                    // Load the dependency before the plugin depending on it.
                    const [[Dep, config]] = Plugins.splice(depIndex, 1);
                    Plugins.splice(index, 0, [Dep, config]);
                    offset--;
                }
            }
        }
        // Load plugins.
        for (const [PluginClass, configuration] of Plugins) {
            const plugin = new PluginClass(this, configuration);
            this.plugins.set(PluginClass, plugin);
            // Register the commands of this plugin.
            Object.keys(plugin.commands).forEach(key => {
                const implementation = Object.assign({}, plugin.commands[key]);
                // Bind handlers to the plugin itself. This preserves the
                // typing of the handler parameters which would be lost if
                // the binding was done in the plugin definition.
                implementation.handler = implementation.handler.bind(plugin);
                this.dispatcher.registerCommand(key, implementation);
            });
            // Register the hooks of this plugin.
            for (const [id, hook] of Object.entries(plugin.commandHooks)) {
                this.dispatcher.registerCommandHook(id, hook.bind(plugin));
            }
            // Load loaders.
            for (const loadableId of Object.keys(plugin.loaders)) {
                if (this.loaders[loadableId]) {
                    throw new Error(`Multiple loaders for '${loadableId}'.`);
                }
                else {
                    // Bind loaders to the plugin itself. This preserves the
                    // typing of the loader parameters which would be lost if
                    // the binding was done in the plugin definition.
                    const loader = plugin.loaders[loadableId];
                    this.loaders[loadableId] = loader.bind(plugin);
                }
            }
        }
        // Load loadables.
        for (const loadableIdentifier of Object.keys(this.loaders)) {
            for (const plugin of this.plugins.values()) {
                const loadableArray = plugin.loadables[loadableIdentifier];
                if (loadableArray) {
                    this.loaders[loadableIdentifier](loadableArray, plugin);
                }
            }
        }
    }
    configure(PluginOrEditorConfig, pluginConfig) {
        if (this._stage !== EditorStage.CONFIGURATION) {
            throw new StageError(EditorStage.CONFIGURATION);
        }
        else if (isConstructor(PluginOrEditorConfig, JWPlugin)) {
            // Configure the plugin.
            const Plugin = PluginOrEditorConfig;
            const conf = this.configuration.plugins.find(([P]) => P === Plugin);
            if (conf) {
                // Update the previous config if the plugin was already added.
                conf[1] = Object.assign(Object.assign({}, conf[1]), pluginConfig);
            }
            else {
                // Add the new plugin constructor and his configuration.
                this.configuration.plugins.push([Plugin, pluginConfig]);
            }
        }
        else {
            // Configure the editor.
            const preconf = this.configuration;
            const conf = PluginOrEditorConfig;
            this.configuration = Object.assign(Object.assign({}, preconf), conf);
            // Merge special `defaults` configuration key.
            if (conf.defaults) {
                this.configuration.defaults = Object.assign(Object.assign({}, preconf.defaults), conf.defaults);
            }
            // Handle special `plugins` configuration key through `load`.
            if (conf.plugins) {
                this.configuration.plugins = [...preconf.plugins];
                for (const [Plugin, pluginConfiguration] of conf.plugins) {
                    this.load(Plugin, pluginConfiguration || {});
                }
            }
            // Handle special `loadables` configuration key through `load`.
            if (conf.loadables) {
                this.configuration.loadables = Object.assign({}, preconf.loadables);
                this.load(conf.loadables);
            }
        }
    }
    /**
     * Execute the command or arbitrary code in `callback` in memory.
     * The call to execCommand are executed into a mutex. Every plugin can
     * launch subcommands with the 'JWPlugin.execCommand' method instead.
     *
     * TODO: create memory for each plugin who use the command then use
     * squashInto(winnerSliceKey, winnerSliceKey, newMasterSliceKey)
     *
     * @param commandName name identifier of the command to execute or callback
     * @param params arguments object of the command to execute
     */
    async execCommand(commandName, params) {
        this._mutex = this._mutex.then(async () => {
            if (!this.memory.isFrozen()) {
                console.error('You are trying to call the external editor' +
                    ' execCommand method from within an execCommand. ' +
                    'Use the `execCommand` method of your plugin instead.');
                return;
            }
            const timeout = setTimeout(() => {
                console.warn('An execCommand call is taking more than 10 seconds to finish. It might be caused by a deadlock.\n' +
                    'Verify that you do not call editor.execCommand inside another editor.execCommand.');
            }, 10000);
            // Switch to the next memory slice (unfreeze the memory).
            const origin = this.memory.sliceKey;
            const memorySlice = this._memoryID.toString();
            this.memory.switchTo(memorySlice);
            this.memoryInfo.commandNames = new VersionableArray();
            this.memoryInfo.uiCommand = false;
            let commandNames = this.memoryInfo.commandNames;
            try {
                // Execute command.
                if (typeof commandName === 'function') {
                    this.memoryInfo.commandNames.push('@custom');
                    await commandName(this.contextManager.defaultContext);
                    if (this.memory.sliceKey !== memorySlice) {
                        // Override by the current commandName if the slice changed.
                        commandNames = ['@custom'];
                    }
                }
                else {
                    this.memoryInfo.commandNames.push(commandName);
                    await this.dispatcher.dispatch(commandName, params);
                    if (this.memory.sliceKey !== memorySlice) {
                        // Override by the current commandName if the slice changed.
                        commandNames = [commandName];
                    }
                }
                // Prepare nex slice and freeze the memory.
                this._memoryID++;
                const nextMemorySlice = this._memoryID.toString();
                this.memory.create(nextMemorySlice);
                // Send the commit message with a froozen memory.
                const changesLocations = this.memory.getChangesLocations(memorySlice, this.memory.sliceKey);
                await this.dispatcher.dispatchHooks('@commit', {
                    changesLocations: changesLocations,
                    commandNames: commandNames,
                });
                clearTimeout(timeout);
            }
            catch (error) {
                clearTimeout(timeout);
                if (this._stage !== EditorStage.EDITION) {
                    throw error;
                }
                console.error(error);
                const failedSlice = this.memory.sliceKey;
                // When an error occurs, we go back to part of the functional memory.
                this.memory.switchTo(origin);
                // Send the commit message with a froozen memory.
                const changesLocations = this.memory.getChangesLocations(failedSlice, origin);
                await this.dispatcher
                    .dispatchHooks('@commit', {
                    changesLocations: changesLocations,
                    commandNames: commandNames,
                })
                    .catch(error => {
                    if (this._stage !== EditorStage.EDITION) {
                        throw error;
                    }
                    console.error(error);
                });
            }
        });
        return this._mutex;
    }
    async execWithRange(bounds, commandName, params, mode) {
        const callback = async () => {
            this.memoryInfo.commandNames.push('@withRange');
            let range;
            if (typeof commandName === 'function') {
                range = new VRange_VRange(this, bounds, params);
                this.memoryInfo.commandNames.push('@custom');
                await commandName(Object.assign(Object.assign({}, this.contextManager.defaultContext), { range }));
            }
            else {
                range = new VRange_VRange(this, bounds, mode);
                this.memoryInfo.commandNames.push(commandName);
                const newParam = Object.assign({ context: {} }, params);
                newParam.context.range = range;
                await this.dispatcher.dispatch(commandName, newParam);
            }
            range.remove();
        };
        if (this.memory.isFrozen()) {
            await this.execCommand(callback);
        }
        else {
            await callback();
        }
    }
    /**
     * Stop this editor instance.
     */
    async stop() {
        if (this.memory) {
            this.memory.create('stop');
            this.memory.switchTo('stop'); // Unfreeze the memory.
        }
        for (const plugin of this.plugins.values()) {
            await plugin.stop();
        }
        if (this.memory) {
            this.memory.create('stopped'); // Freeze the memory.
            this.memory = null;
        }
        this.plugins.clear();
        this.dispatcher = new Dispatcher(this);
        this.selection = new VSelection_VSelection(this);
        this.contextManager = new ContextManager(this, this._execSubCommand);
        // Clear loaders.
        this.loaders = {};
        this._stage = EditorStage.CONFIGURATION;
    }
    /**
     * Execute the command or arbitrary code in `callback` in memory.
     *
     * @param commandName name identifier of the command to execute or callback
     * @param params arguments object of the command to execute
     */
    async _execSubCommand(commandName, params) {
        if (typeof commandName === 'function') {
            this.memoryInfo.commandNames.push('@custom');
            await commandName(this.contextManager.defaultContext);
        }
        else {
            this.memoryInfo.commandNames.push(commandName);
            await this.dispatcher.dispatch(commandName, params);
        }
    }
}
/* harmony default export */ var src_JWEditor = (JWEditor_JWEditor);

// CONCATENATED MODULE: ./packages/plugin-parser/src/Parser.ts

class Parser_Parser extends JWPlugin {
    constructor() {
        super(...arguments);
        this.engines = {};
        this.loaders = {
            parsingEngines: this.loadParsingEngines,
            parsers: this.loadParsers,
        };
    }
    async parse(engineId, ...items) {
        const engine = this.engines[engineId];
        if (!engine) {
            throw new Error(`No parsing engine for ${engineId} installed.`);
        }
        return engine.parse(...items);
    }
    loadParsingEngines(parsingEngines) {
        for (const EngineClass of parsingEngines) {
            const id = EngineClass.id;
            if (this.engines[id]) {
                throw new Error(`Parsing engine ${id} already registered.`);
            }
            const engine = new EngineClass(this.editor);
            this.engines[id] = engine;
        }
    }
    loadParsers(parsers) {
        parsers = [...parsers].reverse();
        for (const ParserClass of parsers) {
            for (const id in this.engines) {
                const parsingEngine = this.engines[id];
                const supportedTypes = [id, ...parsingEngine.constructor.extends];
                if (supportedTypes.includes(ParserClass.id)) {
                    parsingEngine.register(ParserClass);
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-renderer/src/Renderer.ts

class Renderer_Renderer extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loaders = {
            renderingEngines: this.loadRenderingEngines,
            renderers: this.loadRenderers,
        };
        this.engines = {};
    }
    /**
     * @override
     */
    stop() {
        this.engines = {};
        return super.stop();
    }
    async render(renderingId, nodes) {
        const engine = this.engines[renderingId];
        if (!engine) {
            // The caller might want to fallback on another rendering.
            return;
        }
        if (nodes instanceof Array) {
            const cache = await engine.render(nodes);
            nodes.map(node => cache.renderings.get(node));
        }
        else {
            const cache = await engine.render([nodes]);
            return cache.renderings.get(nodes);
        }
    }
    loadRenderingEngines(renderingEngines) {
        for (const EngineClass of renderingEngines) {
            const id = EngineClass.id;
            if (this.engines[id]) {
                throw new Error(`Rendering engine ${id} already registered.`);
            }
            const engine = new EngineClass(this.editor);
            this.engines[id] = engine;
        }
    }
    loadRenderers(renderers) {
        renderers = [...renderers].reverse();
        for (const RendererClass of renderers) {
            for (const id in this.engines) {
                const renderingEngine = this.engines[id];
                const supportedTypes = [id, ...renderingEngine.constructor.extends];
                if (supportedTypes.includes(RendererClass.id)) {
                    renderingEngine.register(RendererClass);
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-parser/src/ParsingEngine.ts
class ParsingEngine {
    constructor(editor) {
        this.parsers = [];
        this.parsingMap = new Map();
        this.editor = editor;
        const defaultParser = new this.constructor.defaultParser(this);
        if (defaultParser.predicate) {
            throw new Error(`Default renderer cannot have a predicate.`);
        }
        else {
            this.parsers.push(defaultParser);
        }
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Register the given parser by instantiating it with this parser engine.
     *
     * @param ParserClass
     */
    register(ParserClass) {
        if (ParserClass.id === this.constructor.id) {
            this.parsers.unshift(new ParserClass(this));
        }
        else {
            const supportedTypes = [this.constructor.id, ...this.constructor.extends];
            const priorParserIds = supportedTypes.slice(0, supportedTypes.indexOf(ParserClass.id));
            const postParserIndex = this.parsers.findIndex(parser => !priorParserIds.includes(parser.constructor.id));
            this.parsers.splice(postParserIndex, 0, new ParserClass(this));
        }
    }
    /**
     * Parse items into the editor's virtual `VNode` representation.
     *
     * @param items the items to parse
     * @returns Promise resolved by the element parsed into the editor virtual
     * VNode representation
     */
    async parse(...items) {
        const nodes = [];
        const childPromises = items.map(node => this._parseItem(node));
        const resList = await Promise.all(childPromises);
        for (const res of resList) {
            nodes.push(...res);
        }
        return nodes;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Parse an item into the editor's virtual representation.
     *
     */
    async _parseItem(item) {
        let nodes;
        for (const parser of this.parsers) {
            if (!parser.predicate || parser.predicate(item)) {
                nodes = await parser.parse(item);
                break;
            }
        }
        if (nodes.length >= 1) {
            this.parsingMap.set(item, nodes);
        }
        return nodes;
    }
}
ParsingEngine.extends = [];

// CONCATENATED MODULE: ./packages/plugin-parser/src/AbstractParser.ts
class AbstractParser {
    constructor(engine) {
        this.engine = engine;
    }
}

// CONCATENATED MODULE: ./packages/plugin-xml/src/DefaultXmlDomParser.ts



class DefaultXmlDomParser_DefaultXmlDomParser extends AbstractParser {
    async parse(item) {
        // If the node could not be parsed, create a generic element node with
        // the HTML tag of the DOM Node. This way we may not support the node
        // but we don't break it either.
        const element = new VElement_VElement({ htmlTag: nodeName(item) });
        if (item instanceof Element) {
            const attributes = this.engine.parseAttributes(item);
            if (attributes.length) {
                element.modifiers.append(attributes);
            }
        }
        const nodes = await this.engine.parse(...item.childNodes);
        element.append(...nodes);
        return [element];
    }
}
DefaultXmlDomParser_DefaultXmlDomParser.id = 'dom/xml';

// CONCATENATED MODULE: ./packages/plugin-xml/src/XmlDomParsingEngine.ts



class XmlDomParsingEngine_XmlDomParsingEngine extends ParsingEngine {
    /**
     * Parse a node's attributes and return them.
     *
     * @param node
     */
    parseAttributes(node) {
        return new Attributes_Attributes(node.attributes);
    }
}
XmlDomParsingEngine_XmlDomParsingEngine.id = 'dom/xml';
XmlDomParsingEngine_XmlDomParsingEngine.defaultParser = DefaultXmlDomParser_DefaultXmlDomParser;

// CONCATENATED MODULE: ./packages/plugin-renderer/src/ModifierRenderer.ts
class SuperModifierRenderer {
    constructor(renderer) {
        this.renderer = renderer;
    }
    /**
     * Render the given modifier and return a list of DomObject witch
     * the applied modifier. The list can have an other len of the given
     * list of DomObject.
     *
     * @param modifier
     * @param contents
     * @param batch
     */
    render(modifier, contents, batch, worker) {
        const nextRenderer = worker.getCompatibleModifierRenderer(modifier, this.renderer);
        return nextRenderer === null || nextRenderer === void 0 ? void 0 : nextRenderer.render(modifier, contents, batch, worker);
    }
}
class ModifierRenderer {
    constructor(engine) {
        this.engine = engine;
        this.super = new SuperModifierRenderer(this);
    }
}

// CONCATENATED MODULE: ./packages/plugin-renderer/src/NodeRenderer.ts
class SuperRenderer {
    constructor(renderer) {
        this.renderer = renderer;
    }
    /**
     * Render the given node.
     *
     * @param node
     */
    render(node, worker) {
        const nextRenderer = worker.getCompatibleRenderer(node, this.renderer);
        return nextRenderer === null || nextRenderer === void 0 ? void 0 : nextRenderer.render(node, worker);
    }
    /**
     * Render the given group of nodes.
     *
     * @param node
     */
    async renderBatch(nodes, worker) {
        await Promise.all(worker.renderBatched(nodes, this.renderer));
        return nodes.map(node => worker.getRendering(node));
    }
}
class NodeRenderer {
    constructor(engine) {
        this.engine = engine;
        this.super = new SuperRenderer(this);
    }
    /**
     * Render the given group of nodes.
     * The indices of the DomObject list match the indices of the given nodes
     * list.
     *
     * @param node
     */
    renderBatch(nodes, worker) {
        return Promise.all(nodes.map(node => this.render(node, worker)));
    }
}

// CONCATENATED MODULE: ./packages/plugin-renderer/src/RenderingEngineCache.ts
class RenderingEngineCache {
    constructor() {
        // Rendering created by a VNode.
        this.renderings = new Map();
        // Promise resolved when the renderings is ready. We can have a value in renderings before the
        // promise is resolved but it's not the complete value (for eg: we create the node and an other
        // renderer add the attributes on this node)
        this.renderingPromises = new Map();
        // VNodes locations in a rendering (by default the rendering is equal to the location).
        this.locations = new Map();
        // List of VNode and Modifiers linked to a rendering.
        // When the rendering is invalidated every VNode or Modifier will be invalidated.
        this.renderingDependent = new Map();
        // When the VNode or Modifier is invalidated every rendering will be invalidated.
        this.nodeDependent = new Map();
        // When the dependency is invalidated every dependents will be invalidated.
        this.linkedNodes = new Map();
        // Cache for founded renderer.
        this.cachedCompatibleRenderer = new Map();
        this.cachedCompatibleModifierRenderer = new Map();
        // Cache to compare modifiers.
        this.cachedModifierId = new Map();
        this.cachedIsSameAsModifier = {};
        // Used to invalidate the cachedIsSameAsModifier values.
        this.cachedIsSameAsModifierIds = {};
    }
}

// CONCATENATED MODULE: ./packages/plugin-renderer/src/RenderingEngine.ts





let modifierId = 0;
class RenderingEngine_RenderingEngine {
    constructor(editor) {
        this.renderers = [];
        this.modifierRenderers = [];
        this.editor = editor;
        const defaultRenderer = new this.constructor.defaultRenderer(this);
        if (defaultRenderer.predicate) {
            throw new Error(`Default renderer cannot have a predicate.`);
        }
        else {
            this.renderers.push(defaultRenderer);
        }
        const defaultModifierRenderer = new this.constructor.defaultModifierRenderer(this);
        if (defaultModifierRenderer.predicate) {
            throw new Error(`Default renderer cannot have a predicate.`);
        }
        else {
            this.modifierRenderers.push(defaultModifierRenderer);
        }
    }
    /**
     * Register the given renderer by instantiating it with this rendering
     * engine. The renderer constructor will receive a special second parameter
     * which is a magic renderer whose `render` method will call the next
     * compatible renderer in line for the given node.
     *
     * @param RendererClass
     */
    register(RendererClass) {
        // Both input parameter types have the same features with respect to
        // what we are doing in this function. However, Typescript requires a
        // stronger typing for inserting them into an array. We chose to use a
        // blind, somewhat wrong, typecast to reduce the scope of the types
        // in order to avoid duplicating the logic of this function.
        const renderers = (isConstructor(RendererClass, NodeRenderer)
            ? this.renderers
            : this.modifierRenderers);
        RendererClass = RendererClass;
        if (RendererClass.id === this.constructor.id) {
            renderers.unshift(new RendererClass(this));
        }
        else {
            const supportedTypes = [this.constructor.id, ...this.constructor.extends];
            const priorRendererIds = supportedTypes.slice(0, supportedTypes.indexOf(RendererClass.id));
            const postRendererIndex = renderers.findIndex(parser => !priorRendererIds.includes(parser.constructor.id));
            renderers.splice(postRendererIndex, 0, new RendererClass(this));
        }
    }
    /**
     * Render the given node. If a prior rendering already exists for this node
     * in this run, return it directly.
     * The cache are automaticaly invalidate if the nodes are not linked to the
     * memory (linked to a layout root for eg)
     *
     * @param nodes
     */
    async render(nodes, cache) {
        if (!cache) {
            cache = new RenderingEngineCache();
            cache.worker = {
                depends: this._depends.bind(this, cache),
                renderBatched: this.renderBatched.bind(this, cache),
                getCompatibleRenderer: this.getCompatibleRenderer.bind(this, cache),
                getCompatibleModifierRenderer: this.getCompatibleModifierRenderer.bind(this, cache),
                locate: this.locate.bind(this, cache),
                getRendering: (node) => cache.renderings.get(node),
                render: async (nodes) => {
                    await this.render(nodes, cache);
                    return nodes.map(node => cache.renderings.get(node));
                },
            };
        }
        const promises = this.renderBatched(cache, nodes.filter(node => !cache.renderingPromises.get(node)));
        await Promise.all(promises); // wait the newest promises
        await Promise.all(nodes.map(node => cache.renderingPromises.get(node))); // wait indifidual promise
        return cache;
    }
    /**
     * Indicates the location of the nodes in the rendering performed.
     *
     * For example, if you avec a 2 charNodes (X, Y) seperate by a linebreak
     * but, you want to display one text node, you can have a text node equal
     * to 'x_y' and indicate that it's [charNode, LineBreak, CharNode].
     * Or you want to display the Linebreak twice: 'x_y_' and indicate this
     * [charNode, LineBreak, CharNode, LineBreak]
     *
     * @param nodes
     * @param rendering
     */
    locate(cache, nodes, value) {
        cache.locations.set(value, nodes);
    }
    /**
     * Group the nodes and call the renderer 'renderBatch' method with the
     * different groups of nodes. By default each group is composed with only
     * one node.
     * The indices of the DomObject list match the indices of the given nodes
     * list.
     *
     * @see renderBatch
     *
     * @param nodes
     * @param rendered
     */
    renderBatched(cache, nodes, rendered) {
        const promises = [];
        for (const node of nodes) {
            const renderer = cache.worker.getCompatibleRenderer(node, rendered);
            const renderings = renderer.renderBatch(nodes, cache.worker);
            const promise = renderings.then(values => {
                const value = values[0];
                this._depends(cache, node, value);
                this._depends(cache, value, node);
                this._addDefaultLocation(cache, node, value);
                cache.renderings.set(node, value);
            });
            cache.renderingPromises.set(node, promise);
            promises.push(promise);
        }
        return promises;
    }
    /**
     * Return the first matche Renderer for this VNode, starting from the
     * previous renderer.
     *
     * @param node
     * @param previousRenderer
     */
    getCompatibleRenderer(cache, node, previousRenderer) {
        let cacheCompatible = cache.cachedCompatibleRenderer.get(node);
        if (!cacheCompatible) {
            cacheCompatible = new Map();
            cache.cachedCompatibleRenderer.set(node, cacheCompatible);
        }
        else if (cacheCompatible.get(previousRenderer)) {
            return cacheCompatible.get(previousRenderer);
        }
        let nextRendererIndex = this.renderers.indexOf(previousRenderer) + 1;
        let nextRenderer;
        do {
            nextRenderer = this.renderers[nextRendererIndex];
            nextRendererIndex++;
        } while (nextRenderer && !node.test(nextRenderer.predicate));
        cacheCompatible.set(previousRenderer, nextRenderer);
        return nextRenderer;
    }
    /**
     * Return the first matche Renderer for this VNode, starting from the
     * previous renderer.
     *
     * @param node
     * @param previousRenderer
     */
    getCompatibleModifierRenderer(cache, modifier, previousRenderer) {
        let cacheCompatible = cache.cachedCompatibleModifierRenderer.get(modifier);
        if (!cacheCompatible) {
            cacheCompatible = new Map();
            cache.cachedCompatibleModifierRenderer.set(modifier, cacheCompatible);
        }
        else if (cacheCompatible.get(previousRenderer)) {
            return cacheCompatible.get(previousRenderer);
        }
        let nextRendererIndex = this.modifierRenderers.indexOf(previousRenderer) + 1;
        let nextRenderer;
        do {
            nextRenderer = this.modifierRenderers[nextRendererIndex];
            nextRendererIndex++;
        } while (nextRenderer.predicate &&
            !(isConstructor(nextRenderer.predicate, Modifier_Modifier)
                ? modifier instanceof nextRenderer.predicate
                : nextRenderer.predicate(modifier)));
        cacheCompatible.set(previousRenderer, nextRenderer);
        return nextRenderer;
    }
    _depends(cache, dependent, dependency) {
        let dNode;
        let dRendering;
        let dyNode;
        let dyRendering;
        if (dependent instanceof AbstractNode_AbstractNode || dependent instanceof Modifier_Modifier) {
            dNode = dependent;
        }
        else {
            dRendering = dependent;
        }
        if (dependency instanceof AbstractNode_AbstractNode || dependency instanceof Modifier_Modifier) {
            dyNode = dependency;
        }
        else {
            dyRendering = dependency;
        }
        if (dNode) {
            if (dyNode) {
                const linked = cache.linkedNodes.get(dyNode);
                if (linked) {
                    linked.add(dNode);
                }
                else {
                    cache.linkedNodes.set(dyNode, new Set([dNode]));
                }
            }
            else {
                const from = cache.renderingDependent.get(dyRendering);
                if (from) {
                    from.add(dNode);
                }
                else {
                    cache.renderingDependent.set(dyRendering, new Set([dNode]));
                }
            }
        }
        else if (dyNode) {
            const linked = cache.nodeDependent.get(dyNode);
            if (linked) {
                linked.add(dRendering);
            }
            else {
                cache.nodeDependent.set(dyNode, new Set([dRendering]));
            }
        }
    }
    _addDefaultLocation(cache, node, value) {
        cache.locations.set(value, [node]);
    }
    _modifierIsSameAs(cache, modifierA, modifierB) {
        if (modifierA === modifierB) {
            return true;
        }
        let idA = modifierA ? cache.cachedModifierId.get(modifierA) : 'null';
        if (!idA) {
            idA = ++modifierId;
            cache.cachedModifierId.set(modifierA, idA);
        }
        let idB = modifierB ? cache.cachedModifierId.get(modifierB) : 'null';
        if (!idB) {
            idB = ++modifierId;
            cache.cachedModifierId.set(modifierB, idB);
        }
        const key = idA + '-' + idB;
        if (key in cache.cachedIsSameAsModifier) {
            return cache.cachedIsSameAsModifier[key];
        }
        const reverseKey = idB + '-' + idA;
        if (reverseKey in cache.cachedIsSameAsModifier) {
            return cache.cachedIsSameAsModifier[reverseKey];
        }
        const isSame = (!modifierA || modifierA.isSameAs(modifierB)) &&
            (!modifierB || modifierB.isSameAs(modifierA));
        cache.cachedIsSameAsModifier[key] = isSame;
        if (!cache.cachedIsSameAsModifierIds[idA]) {
            cache.cachedIsSameAsModifierIds[idA] = [key];
        }
        else {
            cache.cachedIsSameAsModifierIds[idA].push(key);
        }
        if (!cache.cachedIsSameAsModifierIds[idB]) {
            cache.cachedIsSameAsModifierIds[idB] = [key];
        }
        else {
            cache.cachedIsSameAsModifierIds[idB].push(key);
        }
        return cache.cachedIsSameAsModifier[key];
    }
}
RenderingEngine_RenderingEngine.extends = [];

// CONCATENATED MODULE: ./packages/plugin-renderer-dom-object/src/DefaultDomObjectRenderer.ts




class DefaultDomObjectRenderer_DefaultDomObjectRenderer extends NodeRenderer {
    async render(node) {
        let domObject;
        if (node.tangible) {
            if (node instanceof VElement_VElement && node.htmlTag[0] !== '#') {
                domObject = {
                    tag: node.htmlTag,
                    children: await this.engine.renderChildren(node),
                };
            }
            else if (node instanceof FragmentNode_FragmentNode) {
                domObject = {
                    children: await this.engine.renderChildren(node),
                };
            }
            else if (node instanceof AtomicNode_AtomicNode) {
                domObject = { children: [] };
            }
            else {
                domObject = {
                    tag: node.name,
                    attributes: {
                        id: node.id.toString(),
                    },
                    children: await this.engine.renderChildren(node),
                };
            }
        }
        else {
            domObject = { children: [] };
        }
        return domObject;
    }
}
DefaultDomObjectRenderer_DefaultDomObjectRenderer.id = 'dom/object';

// CONCATENATED MODULE: ./packages/plugin-renderer-dom-object/src/DefaultDomObjectModifierRenderer.ts

class DefaultDomObjectModifierRenderer_DefaultDomObjectModifierRenderer extends ModifierRenderer {
    /**
     * Default rendering for Modifier.
     *
     * @param modifier
     * @param contents
     */
    async render(modifier, contents) {
        return contents;
    }
}
DefaultDomObjectModifierRenderer_DefaultDomObjectModifierRenderer.id = 'dom/object';

// CONCATENATED MODULE: ./packages/plugin-renderer-dom-object/src/DomObjectRenderingEngine.ts





class DomObjectRenderingEngine_DomObjectRenderingEngine extends RenderingEngine_RenderingEngine {
    /**
     * Render the attributes of the given VNode onto the given DOM Element.
     *
     * @param Class
     * @param node
     * @param element
     */
    renderAttributes(Class, node, item, worker) {
        if ('tag' in item) {
            if (!item.attributes)
                item.attributes = {};
            const attributes = node.modifiers.find(Class);
            if (attributes) {
                const attr = item.attributes;
                for (const name of attributes.keys()) {
                    if (name === 'class') {
                        if (!attr.class)
                            attr.class = new Set();
                        for (const className of attributes.classList.items()) {
                            attr.class.add(className);
                        }
                    }
                    else if (name === 'style') {
                        attr.style = Object.assign({}, attributes.style.toJSON(), attr.style);
                    }
                    else {
                        attr[name] = attributes.get(name);
                    }
                }
                worker.depends(item, attributes);
            }
        }
    }
    /**
     * @overwrite
     */
    async renderChildren(node) {
        const children = node.children();
        if (!children.length && this.editor.mode.is(node, RuleProperty.ALLOW_EMPTY) !== true) {
            children.push({ tag: 'BR' });
        }
        return children;
    }
    /**
     * Render a placeholder for the given child node.
     *
     * @param child
     */
    renderPlaceholder(child) {
        const placeholder = document.createElement('jw-domobject-vnode');
        placeholder.id = child.id.toString();
        return placeholder;
    }
    /**
     * Convert every VNode children into domObjects
     *
     * @param domObject
     */
    async resolveChildren(domObject, worker) {
        const stack = [domObject];
        for (const domObject of stack) {
            if ('children' in domObject) {
                const children = [];
                const childNodes = domObject.children.filter(child => child instanceof AbstractNode_AbstractNode);
                const domObjects = await worker.render(childNodes);
                for (const index in domObject.children) {
                    const child = domObject.children[index];
                    let childObject;
                    if (child instanceof AbstractNode_AbstractNode) {
                        childObject = domObjects.shift();
                    }
                    else {
                        childObject = child;
                    }
                    if (!stack.includes(childObject)) {
                        children.push(childObject);
                        stack.push(childObject);
                    }
                }
                domObject.children = children;
            }
        }
    }
    /**
     * Group the nodes by renderer, siblings and format.
     *
     * @override
     */
    renderBatched(cache, nodes, rendered) {
        const renderingUnits = this._getRenderingUnits(cache, nodes, rendered);
        return this._renderBatched(cache, renderingUnits);
    }
    /**
     * Group the nodes by format and by renderer and call 'renderBatch' with
     * the different group. Wrap the created domObject into the fromated
     * domObjectElement if needed.
     * Return a list of the rendered vNode and list of DomObjects. The indices
     * of the DomObject list match the indices of the given nodes
     * list.
     *
     * @param renderingUnits
     */
    _renderBatched(cache, renderingUnits) {
        var _a;
        const batchPromises = [];
        for (let unitIndex = 0; unitIndex < renderingUnits.length; unitIndex++) {
            let nextUnitIndex = unitIndex;
            const unit = renderingUnits[unitIndex];
            if (unit && unit[1].length) {
                // Group same formating.
                const modifier = unit[1][0];
                let lastUnit = [unit[0], unit[1].slice(1), unit[2]];
                const newRenderingUnits = [lastUnit];
                let nextUnit;
                while ((nextUnit = renderingUnits[nextUnitIndex + 1]) &&
                    lastUnit[0].parent === nextUnit[0].parent &&
                    nextUnit[1].length &&
                    this._modifierIsSameAs(cache, modifier, (_a = nextUnit[1]) === null || _a === void 0 ? void 0 : _a[0])) {
                    nextUnitIndex++;
                    lastUnit = renderingUnits[nextUnitIndex];
                    newRenderingUnits.push([lastUnit[0], lastUnit[1].slice(1), lastUnit[2]]);
                }
                // Render wrapped nodes.
                const promises = this._renderBatched(cache, newRenderingUnits);
                const nodes = newRenderingUnits.map(u => u[0]);
                const modifierPromise = Promise.all(promises).then(async () => {
                    const domObjects = [];
                    for (const domObject of nodes.map(node => cache.renderings.get(node))) {
                        if (!domObjects.includes(domObject)) {
                            domObjects.push(domObject);
                        }
                    }
                    // Create format.
                    const modifierRenderer = this.getCompatibleModifierRenderer(cache, modifier);
                    const wraps = await modifierRenderer.render(modifier, domObjects, nodes, cache.worker);
                    // Add origins.
                    for (const wrap of wraps) {
                        const stack = [wrap];
                        for (const domObject of stack) {
                            const origins = cache.renderingDependent.get(domObject);
                            if (origins) {
                                for (const origin of origins) {
                                    this._depends(cache, origin, wrap);
                                    this._depends(cache, wrap, origin);
                                }
                            }
                            if ('children' in domObject) {
                                for (const child of domObject.children) {
                                    if (!(child instanceof AbstractNode_AbstractNode)) {
                                        stack.push(child);
                                    }
                                }
                            }
                        }
                        this._depends(cache, modifier, wrap);
                        this._depends(cache, wrap, modifier);
                    }
                    // Update the renderings promise.
                    for (const node of nodes) {
                        const wrap = wraps.find(wrap => { var _a; return (_a = cache.renderingDependent.get(wrap)) === null || _a === void 0 ? void 0 : _a.has(node); });
                        cache.renderings.set(node, wrap);
                    }
                });
                for (const node of nodes) {
                    cache.renderingPromises.set(node, modifierPromise);
                }
                batchPromises.push(modifierPromise);
            }
            else {
                // Render each node.
                let currentRenderer;
                let renderingUnit;
                const siblings = [];
                while ((renderingUnit = renderingUnits[nextUnitIndex]) &&
                    (!currentRenderer ||
                        (!renderingUnit[1].length &&
                            currentRenderer === renderingUnit[2] &&
                            (!siblings.length ||
                                siblings[siblings.length - 1].parent === renderingUnit[0].parent)))) {
                    nextUnitIndex++;
                    siblings.push(renderingUnit[0]);
                    currentRenderer = renderingUnit[2];
                }
                if (currentRenderer) {
                    const promise = new Promise(resolve => {
                        Promise.resolve().then(() => {
                            currentRenderer.renderBatch(siblings, cache.worker).then(domObjects => {
                                // Set the value, add origins and locations.
                                for (const index in siblings) {
                                    const node = siblings[index];
                                    const value = domObjects[index];
                                    this._depends(cache, node, value);
                                    this._depends(cache, value, node);
                                    this._addDefaultLocation(cache, node, value);
                                    cache.renderings.set(node, value);
                                }
                                resolve();
                            });
                        });
                    });
                    for (const sibling of siblings) {
                        cache.renderingPromises.set(sibling, promise);
                    }
                    batchPromises.push(promise);
                    nextUnitIndex--;
                }
            }
            unitIndex = nextUnitIndex;
        }
        return batchPromises;
    }
    /**
     * Compute list of nodes, format and rendering.
     * Add the siblings node into the list for future grouping for 'renderBatch'
     * method.
     *
     * @param nodes
     * @param rendered
     */
    _getRenderingUnits(cache, nodes, rendered) {
        // Consecutive char nodes are rendered in same time.
        const renderingUnits = [];
        const setNodes = new Set(nodes); // Use set for perf.
        const selected = new Set();
        for (const node of nodes) {
            if (selected.has(node)) {
                continue;
            }
            const parent = node.parent;
            if (parent) {
                const markers = [];
                parent.childVNodes.forEach(sibling => {
                    // Filter and sort the ndoes.
                    if (setNodes.has(sibling)) {
                        if (sibling.tangible) {
                            renderingUnits.push(this._createUnit(cache, sibling, rendered));
                        }
                        else {
                            // Not tangible node are add after other nodes (don't cut text node).
                            markers.push(sibling);
                        }
                        selected.add(sibling);
                    }
                    else if (sibling.tangible) {
                        renderingUnits.push(null);
                    }
                });
                for (const marker of markers) {
                    renderingUnits.push(this._createUnit(cache, marker, rendered));
                }
            }
            else {
                renderingUnits.push(this._createUnit(cache, node, rendered));
            }
        }
        return renderingUnits;
    }
    _createUnit(cache, node, rendered) {
        const renderer = cache.worker.getCompatibleRenderer(node, rendered);
        // Remove modifier who render nothing.
        const modifiers = node.modifiers.filter(modifer => !this._modifierIsSameAs(cache, modifer, null));
        return [node, modifiers, renderer];
    }
    _addDefaultLocation(cache, node, domObject) {
        let located = false;
        const stack = [domObject];
        for (const object of stack) {
            if (cache.locations.get(object)) {
                located = true;
                break;
            }
            if ('children' in object) {
                for (const child of object.children) {
                    if (!(child instanceof AbstractNode_AbstractNode)) {
                        if (stack.includes(child)) {
                            throw new Error('Loop in rendering object.');
                        }
                        stack.push(child);
                    }
                }
            }
        }
        if (!located) {
            cache.locations.set(domObject, [node]);
        }
    }
}
DomObjectRenderingEngine_DomObjectRenderingEngine.id = 'dom/object';
DomObjectRenderingEngine_DomObjectRenderingEngine.defaultRenderer = DefaultDomObjectRenderer_DefaultDomObjectRenderer;
DomObjectRenderingEngine_DomObjectRenderingEngine.defaultModifierRenderer = DefaultDomObjectModifierRenderer_DefaultDomObjectModifierRenderer;

// CONCATENATED MODULE: ./packages/plugin-xml/src/AttributesDomObjectModifierRenderer.ts



class AttributesDomObjectModifierRenderer_AttributesDomObjectModifierRenderer extends ModifierRenderer {
    constructor() {
        super(...arguments);
        this.predicate = Attributes_Attributes;
    }
    /**
     * Rendering for Format Modifier.
     *
     * @param format
     * @param contents
     */
    async render(modifier, contents) {
        const keys = modifier.keys();
        if (keys.length) {
            const attributes = {};
            for (const name of keys) {
                if (name === 'class') {
                    attributes.class = new Set(modifier.classList.items());
                }
                else if (name === 'style') {
                    attributes.style = modifier.style.toJSON();
                }
                else {
                    attributes[name] = modifier.get(name);
                }
            }
            const newContents = [];
            for (let index = 0; index < contents.length; index++) {
                let content = contents[index];
                if ('tag' in content) {
                    this._applyAttributes(content, attributes);
                }
                else if ('children' in content &&
                    !content.children.find(domObject => !('tag' in domObject) &&
                        !('text' in domObject && domObject.text === '\u200b'))) {
                    for (const child of content.children) {
                        if ('tag' in child) {
                            this._applyAttributes(child, attributes);
                        }
                    }
                }
                else {
                    const children = [];
                    let newIndex = index;
                    while (newIndex <= contents.length &&
                        ('text' in content ||
                            'dom' in content ||
                            ('children' in content && content.children.length))) {
                        if (!children.includes(content)) {
                            children.push(content);
                        }
                        newIndex++;
                    }
                    if (children.length) {
                        content = {
                            tag: 'SPAN',
                            attributes: Object.assign({}, attributes),
                            children: children,
                        };
                    }
                }
                newContents.push(content);
            }
            contents = newContents;
        }
        return contents;
    }
    _applyAttributes(content, attributes) {
        if (!content.attributes)
            content.attributes = {};
        const attr = content.attributes;
        for (const name in attributes) {
            if (name === 'class') {
                if (!attr.class)
                    attr.class = new Set();
                for (const className of attributes.class) {
                    attr.class.add(className);
                }
            }
            else if (name === 'style') {
                attr.style = Object.assign({}, attributes.style, attr.style);
            }
            else {
                attr[name] = attributes[name];
            }
        }
    }
}
AttributesDomObjectModifierRenderer_AttributesDomObjectModifierRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-xml/src/Xml.ts





class Xml_Xml extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsingEngines: [XmlDomParsingEngine_XmlDomParsingEngine],
            renderers: [AttributesDomObjectModifierRenderer_AttributesDomObjectModifierRenderer],
        };
    }
}
Xml_Xml.dependencies = [Parser_Parser, Renderer_Renderer];

// CONCATENATED MODULE: ./packages/core/src/Format.ts



class Format_Format extends Modifier_Modifier {
    constructor(htmlTag) {
        super();
        this.modifiers = new Modifiers_Modifiers();
        this.htmlTag = htmlTag;
    }
    get name() {
        return this.htmlTag.toLowerCase();
    }
    toString() {
        const nonEmptyAttributes = this.modifiers.filter(modifier => !(modifier instanceof Attributes_Attributes) || !!modifier.length);
        if (nonEmptyAttributes.length) {
            const modifiersRepr = [];
            for (const modifier of nonEmptyAttributes) {
                modifiersRepr.push(modifier.toString());
            }
            return `${this.name}[${modifiersRepr.join(', ')}]`;
        }
        else {
            return this.name;
        }
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    clone() {
        const clone = new this.constructor();
        clone.htmlTag = this.htmlTag;
        clone.modifiers = this.modifiers.clone();
        return clone;
    }
    isSameAs(otherFormat) {
        const aModifiers = this.modifiers;
        const bModifiers = otherFormat === null || otherFormat === void 0 ? void 0 : otherFormat.modifiers;
        return otherFormat instanceof this.constructor && aModifiers.areSameAs(bModifiers);
    }
}

// CONCATENATED MODULE: ./packages/plugin-renderer-dom-object/src/FormatDomObjectModifierRenderer.ts




class FormatDomObjectModifierRenderer_FormatDomObjectModifierRenderer extends ModifierRenderer {
    constructor() {
        super(...arguments);
        this.predicate = Format_Format;
    }
    /**
     * Rendering for Format Modifier.
     *
     * @param format
     * @param contents
     */
    async render(format, contents) {
        const domObject = {
            tag: format.htmlTag.toUpperCase(),
            children: contents,
        };
        const attributes = format.modifiers.find(Attributes_Attributes);
        const keys = attributes === null || attributes === void 0 ? void 0 : attributes.keys();
        if (keys === null || keys === void 0 ? void 0 : keys.length) {
            domObject.attributes = {};
            const attr = domObject.attributes;
            for (const name of keys) {
                if (name === 'class') {
                    if (!attr.class)
                        attr.class = new Set();
                    for (const className of attributes.classList.items()) {
                        attr.class.add(className);
                    }
                }
                else if (name === 'style') {
                    attr.style = Object.assign({}, attributes.style.toJSON(), attr.style);
                }
                else {
                    attr[name] = attributes.get(name);
                }
            }
        }
        return [domObject];
    }
}
FormatDomObjectModifierRenderer_FormatDomObjectModifierRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-renderer-dom-object/src/DomObjectRenderer.ts






class DomObjectRenderer_DomObjectRenderer extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            renderingEngines: [DomObjectRenderingEngine_DomObjectRenderingEngine],
            renderers: [FormatDomObjectModifierRenderer_FormatDomObjectModifierRenderer],
        };
    }
}
DomObjectRenderer_DomObjectRenderer.dependencies = [Parser_Parser, Renderer_Renderer, Xml_Xml];

// CONCATENATED MODULE: ./packages/plugin-html/src/DefaultHtmlTextParser.ts


const autoCloseRegExp = /(<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)[^/]*)>/gi;
class DefaultHtmlTextParser_DefaultHtmlTextParser extends AbstractParser {
    async parse(item) {
        const domParser = new DOMParser();
        const template = item.replace(autoCloseRegExp, '$1/>');
        const xmlDoc = domParser.parseFromString('<t>' + template + '</t>', 'text/xml');
        const parser = this.engine.editor.plugins.get(Parser_Parser);
        return parser.parse('dom/xml', ...xmlDoc.firstChild.childNodes);
    }
}
DefaultHtmlTextParser_DefaultHtmlTextParser.id = 'text/html';

// CONCATENATED MODULE: ./packages/plugin-html/src/HtmlTextParsingEngine.ts


class HtmlTextParsingEngine_HtmlTextParsingEngine extends ParsingEngine {
}
HtmlTextParsingEngine_HtmlTextParsingEngine.id = 'text/html';
HtmlTextParsingEngine_HtmlTextParsingEngine.defaultParser = DefaultHtmlTextParser_DefaultHtmlTextParser;

// CONCATENATED MODULE: ./packages/plugin-html/src/HtmlDomParsingEngine.ts

class HtmlDomParsingEngine_HtmlDomParsingEngine extends XmlDomParsingEngine_XmlDomParsingEngine {
}
HtmlDomParsingEngine_HtmlDomParsingEngine.id = 'dom/html';
HtmlDomParsingEngine_HtmlDomParsingEngine.extends = ['dom/xml'];

// CONCATENATED MODULE: ./packages/plugin-html/src/DefaultHtmlDomRenderer.ts



class DefaultHtmlDomRenderer_DefaultHtmlDomRenderer extends NodeRenderer {
    async render(node) {
        const renderer = this.engine.editor.plugins.get(Renderer_Renderer);
        const objectEngine = renderer.engines['dom/object'];
        const cache = await objectEngine.render([node]);
        const domNodes = [];
        for (const [, domObject] of cache.renderings) {
            await objectEngine.resolveChildren(domObject, cache.worker);
            const domNode = this._objectToDom(domObject);
            if (domNode instanceof DocumentFragment) {
                domNodes.push(...domNode.childNodes);
            }
            else {
                domNodes.push(domNode);
            }
        }
        return domNodes;
    }
    _objectToDom(domObject) {
        let domNode;
        if ('tag' in domObject) {
            const element = document.createElement(domObject.tag);
            const attributes = domObject.attributes;
            if (attributes) {
                for (const name in attributes) {
                    if (name === 'style') {
                        element.setAttribute('style', Object.keys(attributes.style)
                            .map(styleName => `${styleName}: ${attributes.style[styleName]};`)
                            .join(''));
                    }
                    else if (name === 'class') {
                        const classList = attributes[name];
                        for (const className of classList) {
                            element.classList.add(className);
                        }
                    }
                    else {
                        const value = attributes[name];
                        if (typeof value === 'string') {
                            element.setAttribute(name, value);
                        }
                    }
                }
            }
            if (domObject.children) {
                for (const child of domObject.children) {
                    if (!(child instanceof AbstractNode_AbstractNode)) {
                        element.appendChild(this._objectToDom(child));
                    }
                }
            }
            // Implement attach & detach: domObject into html.
            element.addEventListener('detach', () => {
                [...element.children].forEach(childElement => {
                    childElement.dispatchEvent(new CustomEvent('detach'));
                });
                if (domObject.detach) {
                    domObject.detach(element);
                }
            });
            if (domObject.attach) {
                domObject.attach(element);
            }
            domNode = element;
        }
        else if ('text' in domObject) {
            domNode = document.createTextNode(domObject.text);
        }
        else if ('children' in domObject) {
            domNode = document.createDocumentFragment();
            for (const child of domObject.children) {
                if (!(child instanceof AbstractNode_AbstractNode)) {
                    domNode.appendChild(this._objectToDom(child));
                }
            }
        }
        else {
            domNode = document.createDocumentFragment();
            for (const domNode of domObject.dom) {
                domNode.appendChild(domNode);
            }
        }
        return domNode;
    }
}
DefaultHtmlDomRenderer_DefaultHtmlDomRenderer.id = 'dom/html';

// CONCATENATED MODULE: ./packages/plugin-html/src/DefaultHtmlDomModifierRenderer.ts

class DefaultHtmlDomModifierRenderer_DefaultHtmlDomModifierRenderer extends ModifierRenderer {
    /**
     * Default rendering for Format.
     *
     * @param modifier
     * @param contents
     */
    async render(modifier, contents) {
        return contents;
    }
}
DefaultHtmlDomModifierRenderer_DefaultHtmlDomModifierRenderer.id = 'dom/html';

// CONCATENATED MODULE: ./packages/plugin-html/src/HtmlDomRenderingEngine.ts



class HtmlDomRenderingEngine_HtmlDomRenderingEngine extends RenderingEngine_RenderingEngine {
}
HtmlDomRenderingEngine_HtmlDomRenderingEngine.id = 'dom/html';
HtmlDomRenderingEngine_HtmlDomRenderingEngine.defaultRenderer = DefaultHtmlDomRenderer_DefaultHtmlDomRenderer;
HtmlDomRenderingEngine_HtmlDomRenderingEngine.defaultModifierRenderer = DefaultHtmlDomModifierRenderer_DefaultHtmlDomModifierRenderer;

// CONCATENATED MODULE: ./packages/plugin-html/src/HtmlNode.ts

class HtmlNode_HtmlNode extends AtomicNode_AtomicNode {
    constructor(params) {
        super();
        this.domNode = params.domNode;
    }
}

// CONCATENATED MODULE: ./packages/plugin-html/src/HtmlNodeDomRenderer.ts



class HtmlNodeDomRenderer_HtmlHtmlDomRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = HtmlNode_HtmlNode;
    }
    async render(node) {
        const domObject = { dom: [node.domNode()] };
        return domObject;
    }
}
HtmlNodeDomRenderer_HtmlHtmlDomRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-html/src/Html.ts








class Html_Html extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsingEngines: [HtmlDomParsingEngine_HtmlDomParsingEngine, HtmlTextParsingEngine_HtmlTextParsingEngine],
            renderingEngines: [HtmlDomRenderingEngine_HtmlDomRenderingEngine],
            renderers: [HtmlNodeDomRenderer_HtmlHtmlDomRenderer],
        };
    }
}
Html_Html.dependencies = [Parser_Parser, DomObjectRenderer_DomObjectRenderer, Xml_Xml];

// CONCATENATED MODULE: ./packages/plugin-inline/src/InlineNode.ts

class InlineNode_InlineNode extends AtomicNode_AtomicNode {
}

// CONCATENATED MODULE: ./packages/plugin-char/src/CharNode.ts

class CharNode_CharNode extends InlineNode_InlineNode {
    constructor(params) {
        super(params);
        if (params.char.length !== 1) {
            throw new Error('Cannot make a CharNode out of anything else than a string of length 1.');
        }
        this.char = params.char;
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    get name() {
        return this.char;
    }
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     *
     * @override
     */
    clone(params) {
        const defaults = {
            char: this.char,
            modifiers: this.modifiers.clone(),
        };
        return super.clone(Object.assign(Object.assign({}, defaults), params));
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return the length of this VNode.
     */
    get length() {
        return 1;
    }
    /**
     * Return the text content of this node.
     *
     * @override
     */
    get textContent() {
        return this.char;
    }
    /**
     * Return true if `a` has the same format properties as `b`.
     *
     * @param a
     * @param b
     */
    isSameTextNode(node) {
        if (node instanceof CharNode_CharNode) {
            // Char VNodes are the same text node if they have the same
            // modifiers.
            return this.modifiers.areSameAs(node.modifiers);
        }
        else {
            // Nodes that are not valid in a text node must end the text node.
            return false;
        }
    }
}
CharNode_CharNode.atomic = true;

// CONCATENATED MODULE: ./packages/plugin-linebreak/src/LineBreakNode.ts


class LineBreakNode_LineBreakNode extends SeparatorNode_SeparatorNode {
    get name() {
        return '↲';
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Transform the given DOM location into its VDocument counterpart.
     *
     * @override
     * @param domNode DOM node corresponding to this VNode
     * @param offset The offset of the location in the given domNode
     */
    locate(domNode, offset) {
        const location = super.locate(domNode, offset);
        // When clicking on a trailing line break, we need to target after the
        // line break. The DOM represents these as 2 <br> so this is a special
        // case.
        if (!this.nextSibling() && !domNode.nextSibling) {
            location[1] = RelativePosition.AFTER;
        }
        return location;
    }
}

// CONCATENATED MODULE: ./packages/plugin-layout/src/ActionableNode.ts


class ActionableNode_ActionableNode extends AtomicNode_AtomicNode {
    constructor(params) {
        super(params);
        this.actionName = params.name;
        this.label = params.label;
        this.commandId = params.commandId;
        this.commandArgs = params.commandArgs && makeVersionable(params.commandArgs);
        if (params.selected) {
            this.selected = params.selected;
        }
        if (params.enabled) {
            this.enabled = params.enabled;
        }
        if (params.visible) {
            this.visible = params.visible;
        }
    }
    get name() {
        return super.name + ': ' + this.actionName;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    selected(editor) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    enabled(editor) {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    visible(editor) {
        return true;
    }
}

// CONCATENATED MODULE: ./packages/plugin-inline/src/Inline.ts






class Inline_Inline extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            toggleFormat: {
                handler: this.toggleFormat,
            },
            removeFormat: {
                handler: this.removeFormat,
            },
        };
        this.commandHooks = {
            setSelection: this.resetCache,
        };
        this.loadables = {
            components: [
                {
                    id: 'RemoveFormatButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'removeFormat',
                            label: 'Remove format',
                            commandId: 'removeFormat',
                            commandArgs: {},
                            selected: () => false,
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-eraser fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [['RemoveFormatButton', ['actionables']]],
        };
        /**
         * When applying a modifier on a collapsed range, cache the calculation of
         * the modifier in the following property. This value is reset each time the
         * range changes in a document.
         */
        this.cache = makeVersionable({
            modifiers: undefined,
            style: undefined,
        });
    }
    start() {
        this.editor.memory.attach(this.cache);
        this.getCurrentModifiers();
        this.getCurrentStyle();
        return super.start();
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Apply the `format` to the range.
     *
     * @param params
     */
    toggleFormat(params) {
        const range = params.context.range;
        const FormatClass = params.FormatClass;
        if (range.isCollapsed()) {
            if (!this.cache.modifiers) {
                this.cache.modifiers = this.getCurrentModifiers(range);
            }
            const format = this.cache.modifiers.find(FormatClass);
            if (format) {
                this.cache.modifiers.remove(format);
            }
            else {
                this.cache.modifiers.append(new FormatClass());
            }
        }
        else {
            const selectedInlines = range.selectedNodes(InlineNode_InlineNode);
            // If every char in the range has the format `FormatClass`, remove
            // the format for all of them.
            const allHaveFormat = selectedInlines.every(inline => {
                return !!inline.modifiers.find(FormatClass);
            });
            if (allHaveFormat) {
                for (const inline of selectedInlines) {
                    const format = inline.modifiers.find(FormatClass);
                    // Apply the attributes of the format we're about to remove
                    // to the inline itself.
                    const attributes = inline.modifiers.get(Attributes_Attributes);
                    const matchingFormatAttributes = format.modifiers.find(Attributes_Attributes);
                    if (matchingFormatAttributes) {
                        for (const key of matchingFormatAttributes.keys()) {
                            attributes.set(key, matchingFormatAttributes.get(key));
                        }
                    }
                    // Remove the format.
                    inline.modifiers.remove(format);
                }
            }
            else {
                // If there is at least one char in the range without the format
                // `FormatClass`, set the format for all nodes.
                for (const inline of selectedInlines) {
                    if (!inline.modifiers.find(FormatClass)) {
                        new FormatClass().applyTo(inline);
                    }
                }
            }
        }
    }
    isAllFormat(FormatClass, range = this.editor.selection.range) {
        var _a;
        if (range.isCollapsed()) {
            if (!this.cache.modifiers) {
                return !!((_a = this.getCurrentModifiers(range)) === null || _a === void 0 ? void 0 : _a.find(FormatClass));
            }
            return !!this.cache.modifiers.find(FormatClass);
        }
        else {
            const selectedInlines = range.selectedNodes(InlineNode_InlineNode);
            for (const char of selectedInlines) {
                if (!char.modifiers.find(FormatClass)) {
                    return false;
                }
            }
            return !!selectedInlines.length;
        }
    }
    /**
     * Get the modifiers for the next insertion.
     */
    getCurrentModifiers(range) {
        const storeInCache = !range;
        range = range || this.editor.selection.range;
        if (this.cache.modifiers === undefined || range !== this.editor.selection.range) {
            let inlineToCopyModifiers;
            if (range.isCollapsed()) {
                // TODO: LineBreakNode should have the formats as well.
                inlineToCopyModifiers =
                    range.start.previousSibling(node => !(node instanceof LineBreakNode_LineBreakNode)) ||
                        range.start.nextSibling();
            }
            else {
                inlineToCopyModifiers = range.start.nextSibling();
            }
            let modifiers = null;
            if (inlineToCopyModifiers && inlineToCopyModifiers instanceof InlineNode_InlineNode) {
                modifiers = inlineToCopyModifiers.modifiers.clone();
            }
            if (storeInCache) {
                this.cache.modifiers = modifiers;
            }
            return modifiers;
        }
        else {
            return this.cache.modifiers;
        }
    }
    /**
     * Get the styles for the next insertion.
     */
    getCurrentStyle(range) {
        var _a;
        const storeInCache = !range;
        range = range || this.editor.selection.range;
        if (this.cache.style === undefined || range !== this.editor.selection.range) {
            let inlineToCopyStyle;
            if (range.isCollapsed()) {
                inlineToCopyStyle = range.start.previousSibling() || range.start.nextSibling();
            }
            else {
                inlineToCopyStyle = range.start.nextSibling();
            }
            let style = null;
            if (inlineToCopyStyle && inlineToCopyStyle instanceof InlineNode_InlineNode) {
                style = ((_a = inlineToCopyStyle.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.style.clone()) || null;
            }
            if (storeInCache) {
                this.cache.style = style;
            }
            return style;
        }
        return this.cache.style;
    }
    /**
     * Each time the selection changes, we reset its format and style.
     */
    resetCache() {
        this.cache.modifiers = undefined;
        this.cache.style = undefined;
    }
    /**
     * Remove the formatting of the nodes in the range.
     *
     * @param params
     */
    removeFormat(params) {
        const nodes = params.context.range.selectedNodes();
        for (const node of nodes) {
            // TODO: some formats might be on the parent...
            node.modifiers.empty();
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-char/src/CharDomObjectRenderer.ts




class CharDomObjectRenderer_CharDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = CharNode_CharNode;
    }
    async render(charNode, worker) {
        return this._renderText([charNode], worker);
    }
    async renderBatch(charNodes, worker) {
        const domObjects = [];
        const domObject = this._renderText(charNodes, worker);
        for (let i = 0; i < charNodes.length; i++)
            domObjects.push(domObject);
        return domObjects;
    }
    _renderText(charNodes, worker) {
        // Create textObject.
        const texts = [];
        for (const charNode of charNodes) {
            // Same text node.
            if (charNode.char === ' ' && texts[texts.length - 1] === ' ') {
                // Browsers don't render consecutive space chars otherwise.
                texts.push('\u00A0');
            }
            else {
                texts.push(charNode.char);
            }
        }
        // Render block edge spaces as non-breakable space (otherwise browsers
        // won't render them).
        const previous = charNodes[0].previousSibling();
        if (!previous || !(previous instanceof InlineNode_InlineNode)) {
            texts[0] = texts[0].replace(/^ /g, '\u00A0');
        }
        const next = charNodes[charNodes.length - 1].nextSibling();
        if (!next || !(next instanceof InlineNode_InlineNode)) {
            texts[texts.length - 1] = texts[texts.length - 1].replace(/^ /g, '\u00A0');
        }
        const textObject = { text: texts.join('') };
        worker.locate(charNodes, textObject);
        return textObject;
    }
}
CharDomObjectRenderer_CharDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/utils/src/isBlock.ts

/**
 * The following is a complete list of all HTML "block-level" elements.
 *
 * Source:
 * https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
 *
 * */
const blockTagNames = [
    'ADDRESS',
    'ARTICLE',
    'ASIDE',
    'BLOCKQUOTE',
    'DETAILS',
    'DIALOG',
    'DD',
    'DIV',
    'DL',
    'DT',
    'FIELDSET',
    'FIGCAPTION',
    'FIGURE',
    'FOOTER',
    'FORM',
    'H1',
    'H2',
    'H3',
    'H4',
    'H5',
    'H6',
    'HEADER',
    'HGROUP',
    'HR',
    'LI',
    'MAIN',
    'NAV',
    'OL',
    'P',
    'PRE',
    'SECTION',
    'TABLE',
    'UL',
    // The following elements are not in the W3C list, for some reason.
    'TR',
    'TD',
    'TBODY',
    'THEAD',
    'TH',
];
const computedStyles = new WeakMap();
/**
 * Return true if the given node is a block-level element, false otherwise.
 *
 * @param node
 */
function isBlock(node) {
    let result;
    if (node instanceof Element) {
        const tagName = nodeName(node);
        // every custom jw-* node will be considered as blocks
        if (tagName.startsWith('JW-') || tagName === 'T') {
            return true;
        }
        // We won't call `getComputedStyle` more than once per node.
        let style = computedStyles.get(node);
        if (!style) {
            style = window.getComputedStyle(node);
        }
        // The node might not be in the DOM, in which case it has no CSS values.
        if (style.display) {
            result = !style.display.includes('inline') && style.display !== 'contents';
        }
        else {
            result = blockTagNames.includes(tagName);
        }
    }
    else {
        result = false;
    }
    return result;
}

// CONCATENATED MODULE: ./packages/utils/src/formattingSpace.ts


const spaceBeforeNewline = /([ \t])*(\n)/g;
const spaceAfterNewline = /(\n)([ \t])*/g;
const tabs = /\t/g;
const newlines = /\n/g;
const onlyTabsSpacesAndNewLines = /^[\t \n]*$/g;
const consecutiveSpace = /  */g;
const endWithSpace = /[ \t\n]$/g;
const startSpace = /^ */g;
const endSpace = /[ \u3000]*$/g;
/**
 * Return a string with the value of a text node stripped of its formatting
 * space, applying the w3 rules for white space processing
 * TODO: decide what exactly to do with formatting spaces:
 * remove, keep, recompute?
 *
 * @see https://www.w3.org/TR/css-text-3/#white-space-processing
 * @returns {string}
 */
function removeFormattingSpace(node) {
    var _a;
    // TODO: check the value of the `white-space` property
    const text = node.textContent;
    if ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.closest('PRE, TEXTAREA')) {
        return text;
    }
    // (Comments refer to the w3 link provided above.)
    // Phase I: Collapsing and Transformation
    let newText = text
        // 1. All spaces and tabs immediately preceding or following a
        //    segment break are removed.
        .replace(spaceBeforeNewline, '$2')
        .replace(spaceAfterNewline, '$1')
        // 2. Segment breaks are transformed for rendering according to the
        //    segment break transformation rules.
        .replace(newlines, ' ')
        // 3. Every tab is converted to a space (U+0020).
        .replace(tabs, ' ')
        // 4. Any space immediately following another collapsible space —
        //    even one outside the boundary of the inline containing that
        //    space, provided both spaces are within the same inline
        //    formatting context—is collapsed to have zero advance width.
        //    (It is invisible, but retains its soft wrap opportunity, if
        //    any.)
        .replace(consecutiveSpace, ' ');
    // Phase II: Trimming and Positioning
    // 1. A sequence of collapsible spaces at the beginning of a line
    //    (ignoring any intervening inline box boundaries) is removed.
    // 1.2. The space at the beginning of the line is collapsed if
    //    a space is present in the previous inline siblings node
    //    see : https://www.w3.org/TR/css-text-3/#collapse
    if (_isAtSegmentBreak(node, 'start') || _followsInlineSpace(node)) {
        newText = newText.replace(startSpace, '');
    }
    // 2. If the tab size is zero, tabs are not rendered. Otherwise, each
    //    tab is rendered as a horizontal shift that lines up the start edge
    //    of the next glyph with the next tab stop. If this distance is less
    //    than 0.5ch, then the subsequent tab stop is used instead. Tab
    //    stops occur at points that are multiples of the tab size from the
    //    block’s starting content edge. The tab size is given by the
    //    tab-size property.
    // TODO
    // 3. A sequence at the end of a line (ignoring any intervening inline
    //    box boundaries) of collapsible spaces (U+0020) and/or ideographic
    //    spaces (U+3000) whose white-space value collapses spaces is
    //    removed.
    if (_isAtSegmentBreak(node, 'end')) {
        newText = newText.replace(endSpace, '');
    }
    return newText;
}
/**
 * Return true if the given node is immediately folowing a space inside the same inline context,
 * to see if its frontal space must be removed.
 *
 * @param {Element} node
 * @returns {boolean}
 */
function _followsInlineSpace(node) {
    let sibling = node && node.previousSibling;
    if (_isTextNode(node) && !sibling) {
        sibling = node.parentElement.previousSibling;
    }
    if (!sibling || isBlock(sibling))
        return false;
    return !!sibling.textContent.match(endWithSpace);
}
/**
 * Return true if the given node is immediately preceding (`side` === 'end')
 * or following (`side` === 'start') a segment break, to see if its edge
 * space must be removed.
 * A segment break is a sort of line break, not considering automatic breaks
 * that are function of the screen size. In this context, a segment is what
 * you see when you triple click in text in the browser.
 * Eg: `<div><p>◆one◆</p>◆two◆<br>◆three◆</div>` where ◆ = segment breaks.
 *
 * @param {Element} node
 * @param {'start'|'end'} side
 * @returns {boolean}
 */
function _isAtSegmentBreak(node, side) {
    const siblingSide = side === 'start' ? 'previousSibling' : 'nextSibling';
    const sibling = node && node[siblingSide];
    const isAgainstAnotherSegment = sibling && _isSegment(sibling);
    const isAtEdgeOfOwnSegment = _isBlockEdge(node, side);
    // In the DOM, a space before a BR is rendered but a space after a BR isn't.
    const isBeforeBR = side === 'end' && sibling && nodeName(sibling) === 'BR';
    return (isAgainstAnotherSegment && !isBeforeBR) || isAtEdgeOfOwnSegment;
}
/**
 * Return true if the node is a segment according to W3 formatting model.
 *
 * @param node to check
 */
function _isSegment(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
        // Only proper elements can be a segment.
        return false;
    }
    else if (nodeName(node) === 'BR') {
        // Break (BR) tags end a segment.
        return true;
    }
    else {
        // The W3 specification has many specific cases that defines what is
        // or is not a segment. For the moment, we only handle display: block.
        return isBlock(node);
    }
}
/**
 * Return true if the node is at the given edge of a block.
 *
 * @param node to check
 * @param side of the block to check ('start' or 'end')
 */
function _isBlockEdge(node, side) {
    const ancestorsUpToBlock = [];
    // Move up to the first block ancestor
    let ancestor = node;
    while (ancestor && (_isTextNode(ancestor) || !_isSegment(ancestor))) {
        ancestorsUpToBlock.push(ancestor);
        ancestor = ancestor.parentElement;
    }
    // Return true if no ancestor up to the first block ancestor has a
    // sibling on the specified side
    const siblingSide = side === 'start' ? 'previousSibling' : 'nextSibling';
    return ancestorsUpToBlock.every(ancestor => {
        let sibling = ancestor[siblingSide];
        while (sibling &&
            _isTextNode(sibling) &&
            sibling.textContent.match(onlyTabsSpacesAndNewLines)) {
            sibling = sibling[siblingSide];
        }
        return !sibling;
    });
}
/**
 * Return true if the given node is a text node, false otherwise.
 *
 * @param node to check
 */
function _isTextNode(node) {
    return node.nodeType === Node.TEXT_NODE;
}

// CONCATENATED MODULE: ./packages/plugin-char/src/CharXmlDomParser.ts




class CharXmlDomParser_CharXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item.nodeType === Node.TEXT_NODE;
        };
    }
    async parse(item) {
        const nodes = [];
        const text = removeFormattingSpace(item);
        for (let i = 0; i < text.length; i++) {
            const char = text.charAt(i);
            let parsedVNode;
            if (char === '\n') {
                parsedVNode = new this.engine.editor.configuration.defaults.Separator();
            }
            else {
                parsedVNode = new CharNode_CharNode({ char: char });
            }
            nodes.push(parsedVNode);
        }
        return nodes;
    }
}
CharXmlDomParser_CharXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-char/src/Char.ts







class Char_Char extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [CharXmlDomParser_CharXmlDomParser],
            renderers: [CharDomObjectRenderer_CharDomObjectRenderer],
        };
        this.commands = {
            insertText: {
                handler: this.insertText,
            },
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Insert text at the current position of the selection.
     *
     * If the selection is collapsed, add `text` to the vDocument and copy the
     * formating of the previous char or the next char.
     *
     * If the selection is not collapsed, replace the text with the formating
     * that was present in the selection.
     *
     * @param params
     */
    insertText(params) {
        const range = params.context.range;
        const text = params.text;
        const inline = this.editor.plugins.get(Inline_Inline);
        let modifiers = inline.getCurrentModifiers(range);
        // Ony preserved modifiers are applied at the start of a container.
        const previousSibling = range.start.previousSibling();
        if (!previousSibling && modifiers) {
            const preservedModifiers = modifiers.filter(mod => mod.preserve);
            if (preservedModifiers.length) {
                modifiers = new Modifiers_Modifiers(...preservedModifiers);
            }
            else {
                modifiers = null;
            }
        }
        if (params.formats) {
            if (!modifiers) {
                modifiers = new Modifiers_Modifiers();
            }
            modifiers.set(...params.formats.map(format => format.clone()));
        }
        const style = inline.getCurrentStyle(range);
        // Remove the contents of the range if needed.
        if (!range.isCollapsed()) {
            range.empty();
        }
        // Split the text into CHAR nodes and insert them at the range.
        const characters = text.split('');
        const charNodes = characters.map(char => {
            if (modifiers) {
                return new CharNode_CharNode({ char: char, modifiers: modifiers.clone() });
            }
            else {
                return new CharNode_CharNode({ char: char });
            }
        });
        charNodes.forEach(charNode => {
            if (style === null || style === void 0 ? void 0 : style.length) {
                charNode.modifiers.get(Attributes_Attributes).style = style;
            }
            range.start.before(charNode);
        });
        if (params.select && charNodes.length) {
            this.editor.selection.select(charNodes[0], charNodes[charNodes.length - 1]);
        }
    }
}
Char_Char.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-linebreak/src/LineBreakXmlDomParser.ts





class LineBreakXmlDomParser_LineBreakXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'BR';
        };
    }
    async parse(item) {
        if (this._isInvisibleBR(item)) {
            return [];
        }
        const lineBreak = new LineBreakNode_LineBreakNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            lineBreak.modifiers.append(attributes);
        }
        return [lineBreak];
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return true if the given <br/> node is invisible. A <br/> at the end edge
     * of a block or before another block is there only to make its parent
     * visible. Consume it since it was just parsed as its parent element node.
     * TODO: account for formatting space.
     *
     * @param node
     */
    _isInvisibleBR(node) {
        // Search for another non-block cousin in the same block parent.
        while (node && !node.nextSibling && node.parentNode && !isBlock(node.parentNode)) {
            node = node.parentNode;
        }
        return !node || !node.nextSibling || isBlock(node.nextSibling);
    }
}
LineBreakXmlDomParser_LineBreakXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-linebreak/src/LineBreakDomObjectRenderer.ts



class LineBreakDomObjectRenderer_LineBreakDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = LineBreakNode_LineBreakNode;
    }
    /**
     * Render the VNode to the given format.
     */
    async render(node, worker) {
        const br = { tag: 'BR' };
        worker.locate([node], br);
        if (!node.nextSibling()) {
            // If a LineBreakNode has no next sibling, it must be rendered
            // as two BRs in order for it to be visible.
            const br2 = { tag: 'BR' };
            const domObject = { children: [br, br2] };
            worker.locate([node], br2);
            return domObject;
        }
        return br;
    }
}
LineBreakDomObjectRenderer_LineBreakDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-linebreak/src/LineBreak.ts




class LineBreak_LineBreak extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [LineBreakXmlDomParser_LineBreakXmlDomParser],
            renderers: [LineBreakDomObjectRenderer_LineBreakDomObjectRenderer],
        };
        this.commands = {
            insertLineBreak: {
                handler: this.insertLineBreak,
            },
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Insert a line break node at range.
     */
    insertLineBreak(params) {
        return params.context.execCommand('insert', {
            node: new LineBreakNode_LineBreakNode(),
        });
    }
}

// CONCATENATED MODULE: ./packages/plugin-heading/src/HeadingNode.ts

class HeadingNode_HeadingNode extends VElement_VElement {
    constructor(params) {
        super({ htmlTag: 'H' + params.level });
        this.level = params.level;
    }
    get name() {
        return super.name + ': ' + this.level;
    }
    clone(deepClone, params) {
        const defaults = {
            level: this.level,
        };
        return super.clone(deepClone, Object.assign(Object.assign({}, defaults), params));
    }
}

// CONCATENATED MODULE: ./packages/plugin-heading/src/HeadingXmlDomParser.ts




const HeadingTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
class HeadingXmlDomParser_HeadingXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && HeadingTags.includes(nodeName(item));
        };
    }
    async parse(item) {
        const heading = new HeadingNode_HeadingNode({ level: parseInt(nodeName(item)[1], 10) });
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            heading.modifiers.append(attributes);
        }
        const nodes = await this.engine.parse(...item.childNodes);
        heading.append(...nodes);
        return [heading];
    }
}
HeadingXmlDomParser_HeadingXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-heading/src/Heading.ts






function headingButton(level) {
    return {
        id: 'Heading' + level + 'Button',
        async render() {
            const button = new ActionableNode_ActionableNode({
                name: 'heading' + level,
                label: 'Heading' + level,
                commandId: 'applyHeadingStyle',
                commandArgs: { level: level },
                selected: (editor) => {
                    var _a, _b;
                    const range = editor.selection.range;
                    const startIsHeading = ((_a = range.start.closest(HeadingNode_HeadingNode)) === null || _a === void 0 ? void 0 : _a.level) === level;
                    if (!startIsHeading || range.isCollapsed()) {
                        return startIsHeading;
                    }
                    else {
                        return ((_b = range.end.closest(HeadingNode_HeadingNode)) === null || _b === void 0 ? void 0 : _b.level) === level;
                    }
                },
                modifiers: [new Attributes_Attributes({ class: 'h' + level })],
            });
            return [button];
        },
    };
}
class Heading_Heading extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            applyHeadingStyle: {
                handler: this.applyHeadingStyle,
            },
            insertParagraphBreak: {
                selector: [HeadingNode_HeadingNode],
                check: (context) => {
                    const range = context.range;
                    return range.isCollapsed() && !range.start.nextSibling();
                },
                handler: this.insertParagraphBreak,
            },
        };
        this.loadables = {
            parsers: [HeadingXmlDomParser_HeadingXmlDomParser],
            shortcuts: [0, 1, 2, 3, 4, 5, 6].map(level => {
                return {
                    pattern: 'CTRL+SHIFT+<Digit' + level + '>',
                    commandId: 'applyHeadingStyle',
                    commandArgs: { level: level },
                };
            }),
            components: [
                {
                    id: 'ParagraphButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'paragraph',
                            label: 'Paragraph',
                            commandId: 'applyHeadingStyle',
                            commandArgs: { level: 0 },
                            selected: (editor) => {
                                const range = editor.selection.range;
                                if (range.start.parent) {
                                    const startIsDefault = !!range.start.closest(ancestor => ancestor instanceof editor.configuration.defaults.Container);
                                    if (!startIsDefault || range.isCollapsed()) {
                                        return startIsDefault;
                                    }
                                    else {
                                        return !!range.end.closest(ancestor => ancestor instanceof
                                            editor.configuration.defaults.Container);
                                    }
                                }
                                else {
                                    return true;
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'p' })],
                        });
                        return [button];
                    },
                },
                ...[1, 2, 3, 4, 5, 6].map(headingButton),
            ],
            componentZones: [
                ['ParagraphButton', ['actionables']],
                ['Heading1Button', ['actionables']],
                ['Heading2Button', ['actionables']],
                ['Heading3Button', ['actionables']],
                ['Heading4Button', ['actionables']],
                ['Heading5Button', ['actionables']],
                ['Heading6Button', ['actionables']],
            ],
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Change the formatting of the nodes in given range to Heading.
     *
     * @param params
     */
    applyHeadingStyle(params) {
        for (const node of params.context.range.targetedNodes(ContainerNode_ContainerNode)) {
            const heading = this._createHeadingContainer(params.level);
            heading.modifiers = node.modifiers.clone();
            node.replaceWith(heading);
        }
    }
    /**
     * Inserting a paragraph break at the end of a heading exits the heading.
     *
     * @param params
     */
    insertParagraphBreak(params) {
        const range = params.context.range;
        const heading = range.targetedNodes(HeadingNode_HeadingNode)[0];
        const duplicate = heading.splitAt(range.start);
        const newContainer = new this.editor.configuration.defaults.Container();
        duplicate.replaceWith(newContainer);
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return a heading node or a base container based on the given level.
     *
     * @param level
     */
    _createHeadingContainer(level) {
        if (level === 0) {
            return new this.editor.configuration.defaults.Container();
        }
        else {
            return new HeadingNode_HeadingNode({ level: level });
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-paragraph/src/ParagraphNode.ts

class ParagraphNode_ParagraphNode extends VElement_VElement {
    constructor() {
        super({ htmlTag: 'P' });
    }
}

// CONCATENATED MODULE: ./packages/plugin-paragraph/src/ParagraphXmlDomParser.ts




class ParagraphXmlDomParser_ParagraphXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'P';
        };
    }
    async parse(item) {
        const paragraph = new ParagraphNode_ParagraphNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            paragraph.modifiers.append(attributes);
        }
        const nodes = await this.engine.parse(...item.childNodes);
        paragraph.append(...nodes);
        return [paragraph];
    }
}
ParagraphXmlDomParser_ParagraphXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-paragraph/src/Paragraph.ts


class Paragraph_Paragraph extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [ParagraphXmlDomParser_ParagraphXmlDomParser],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-list/src/ListNode.ts


var ListType;
(function (ListType) {
    ListType["ORDERED"] = "ORDERED";
    ListType["UNORDERED"] = "UNORDERED";
    ListType["CHECKLIST"] = "CHECKLIST";
})(ListType || (ListType = {}));
class ListNode_IsChecked extends Modifier_Modifier {
}
class ListNode_ListNode extends ContainerNode_ContainerNode {
    constructor(params) {
        super(params);
        this.listType = params.listType;
    }
    // Typescript currently doesn't support using enum as keys in interfaces.
    // Source: https://github.com/microsoft/TypeScript/issues/13042
    static ORDERED(node) {
        return node && node instanceof ListNode_ListNode && node.listType === ListType.ORDERED;
    }
    static UNORDERED(node) {
        return node && node instanceof ListNode_ListNode && node.listType === ListType.UNORDERED;
    }
    static CHECKLIST(node) {
        return node && node instanceof ListNode_ListNode && node.listType === ListType.CHECKLIST;
    }
    get name() {
        return super.name + ': ' + this.listType;
    }
    /**
     * Return true if the given node is a checked checklist or checklist item.
     *
     * @param node
     */
    static isChecked(node) {
        if (ListNode_ListNode.CHECKLIST(node) && node.hasChildren()) {
            // If the node is a populated checklist, it is checked in the case
            // that every one of its children is checked.
            return node.children().every(ListNode_ListNode.isChecked);
        }
        else {
            const indentedChild = node.nextSibling();
            if (ListNode_ListNode.CHECKLIST(indentedChild)) {
                // If the next list item is a checklist, this list item is its
                // title, which is checked if said checklist's children are
                // checked.
                return ListNode_ListNode.isChecked(indentedChild);
            }
            else {
                return !!node.modifiers.find(ListNode_IsChecked);
            }
        }
    }
    /**
     * Set the given nodes as checked.
     *
     * @param nodes
     */
    static check(...nodes) {
        for (const node of nodes) {
            if (node instanceof ListNode_ListNode) {
                // Check the list's children.
                ListNode_ListNode.check(...node.children());
            }
            else {
                // Check the node itself otherwise.
                node.modifiers.set(ListNode_IsChecked);
                // Propagate to next indented list if any.
                const indentedChild = node.nextSibling();
                if (indentedChild && indentedChild instanceof ListNode_ListNode) {
                    ListNode_ListNode.check(indentedChild);
                }
            }
        }
    }
    /**
     * Set the given nodes as unchecked.
     *
     * @param nodes
     */
    static uncheck(...nodes) {
        for (const node of nodes) {
            if (node instanceof ListNode_ListNode) {
                // Uncheck the list's children.
                ListNode_ListNode.uncheck(...node.children());
            }
            else {
                // Uncheck the node.
                node.modifiers.remove(ListNode_IsChecked);
                // Propagate to next indented list.
                const indentedChild = node.nextSibling();
                if (indentedChild && indentedChild instanceof ListNode_ListNode) {
                    ListNode_ListNode.uncheck(indentedChild);
                }
            }
        }
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Return a new VNode with the same type and attributes as this VNode.
     *
     *  @override
     */
    clone(deepClone, params) {
        const defaults = {
            listType: this.listType,
        };
        return super.clone(deepClone, Object.assign(Object.assign({}, defaults), params));
    }
}

// EXTERNAL MODULE: ./packages/plugin-list/assets/checklist.css
var checklist = __webpack_require__(7);

// CONCATENATED MODULE: ./packages/plugin-list/src/ListItemXmlDomParser.ts






class ListItemXmlDomParser_ListItemAttributes extends Attributes_Attributes {
}
class ListItemXmlDomParser_ListItemXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'LI';
        };
    }
    /**
     * Parse a list element (LI).
     *
     * @param context
     */
    async parse(item) {
        const children = Array.from(item.childNodes);
        const nodes = [];
        let inlinesContainer;
        // Parse the list item's attributes into the node's ListItemAttributes,
        // which will be read only by ListItemDomRenderer.
        const itemModifiers = new Modifiers_Modifiers();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            itemModifiers.append(attributes);
        }
        const Container = this.engine.editor.configuration.defaults.Container;
        for (let childIndex = 0; childIndex < children.length; childIndex++) {
            const domChild = children[childIndex];
            const parsedChild = await this.engine.parse(domChild);
            if (parsedChild.length) {
                if (this._isInlineListItem(domChild)) {
                    // Contiguous inline elements in a list item should be
                    // wrapped together in a base container.
                    if (!inlinesContainer) {
                        inlinesContainer = new Container();
                        inlinesContainer.modifiers.append(new ListItemXmlDomParser_ListItemAttributes(itemModifiers.get(Attributes_Attributes)));
                        nodes.push(inlinesContainer);
                    }
                    inlinesContainer.append(...parsedChild);
                }
                else {
                    if (inlinesContainer && !['UL', 'OL'].includes(nodeName(domChild))) {
                        inlinesContainer.append(...parsedChild);
                    }
                    else {
                        inlinesContainer = null; // Close the inlinesContainer.
                        for (const child of parsedChild) {
                            child.modifiers.set(new ListItemXmlDomParser_ListItemAttributes(itemModifiers.get(Attributes_Attributes)));
                        }
                        nodes.push(...parsedChild);
                    }
                }
            }
        }
        // A list item with children but whose parsing returned nothing should
        // be parsed as an empty base container. Eg: <li><br/></li>: li has a
        // child so it will not return [] above (and therefore be ignored), but
        // br will parse to nothing because it's a placeholder br, not a real
        // line break. We cannot ignore that li because it does in fact exist so
        // we parse it as an empty base container.
        if (nodes.length) {
            return nodes;
        }
        else {
            const container = new Container();
            container.modifiers.append(new ListItemXmlDomParser_ListItemAttributes(itemModifiers.get(Attributes_Attributes)));
            return [container];
        }
    }
    /**
     * Return true if the given node is an inline list item.
     *
     * @param item
     */
    _isInlineListItem(item) {
        return item && (!isBlock(item) || nodeName(item) === 'BR');
    }
}
ListItemXmlDomParser_ListItemXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-list/src/ListDomObjectRenderer.ts






class ListDomObjectRenderer_ListDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ListNode_ListNode;
    }
    async render(listNode, worker) {
        const list = {
            tag: listNode.listType === ListType.ORDERED ? 'OL' : 'UL',
            children: [],
        };
        if (ListNode_ListNode.CHECKLIST(listNode)) {
            list.attributes = { class: new Set(['checklist']) };
        }
        const children = listNode.children();
        const domObjects = await worker.render(children);
        for (const index in children) {
            list.children.push(this._renderLi(listNode, children[index], domObjects[index], worker));
        }
        return list;
    }
    _renderLi(listNode, listItem, rendering, worker) {
        let li;
        // The node was wrapped in a "LI" but needs to be rendered as well.
        if ('tag' in rendering && rendering.tag === 'P' && !rendering.shadowRoot) {
            // Direct ListNode's VElement children "P" are rendered as "LI"
            // while other nodes will be rendered inside the "LI".
            li = rendering;
            li.tag = 'LI';
        }
        else if ('dom' in rendering && rendering.dom[0].nodeName === 'LI') {
            // If there is no child-specific renderer, the default renderer
            // is used. This takes the result of the Dom renderer which
            // itself wrap the children in LI.
            rendering.dom = [...rendering.dom[0].childNodes];
            li = {
                tag: 'LI',
                children: [rendering],
            };
            // Mark as origin. If the listItem or the listNode change, the other are invalidate.
            worker.depends(listItem, li);
            worker.depends(li, listItem);
        }
        else {
            li = {
                tag: 'LI',
                children: [listItem],
            };
            // Mark as dependent. If the listItem change, the listNode are invalidate. But if the
            // list change, the listItem will not invalidate.
            worker.depends(li, listItem);
        }
        worker.depends(li, listNode);
        worker.depends(listNode, li);
        // Render the node's attributes that were stored on the technical key
        // that specifies those attributes belong on the list item.
        this.engine.renderAttributes(ListItemXmlDomParser_ListItemAttributes, listItem, li, worker);
        if (listNode.listType === ListType.ORDERED) {
            // Adapt numbering to skip previous list item
            // Source: https://stackoverflow.com/a/12860083
            const previousIdentedList = listItem.previousSibling();
            if (previousIdentedList instanceof ListNode_ListNode) {
                const previousLis = previousIdentedList.previousSiblings(sibling => !(sibling instanceof ListNode_ListNode));
                const value = Math.max(previousLis.length, 1) + 1;
                li.attributes.value = value.toString();
            }
        }
        if (listItem instanceof ListNode_ListNode) {
            const style = li.attributes.style || {};
            if (!style['list-style']) {
                style['list-style'] = 'none';
            }
            li.attributes.style = style;
            if (ListNode_ListNode.CHECKLIST(listItem)) {
                const prev = listItem.previousSibling();
                if (prev && !ListNode_ListNode.CHECKLIST(prev)) {
                    // Add dependencie to check/uncheck with previous checklist item used as title.
                    worker.depends(prev, listItem);
                    worker.depends(listItem, prev);
                }
            }
        }
        else if (ListNode_ListNode.CHECKLIST(listNode)) {
            // Add dependencie because the modifier on the listItem change the li rendering.
            worker.depends(li, listItem);
            worker.depends(listItem, listNode);
            const className = ListNode_ListNode.isChecked(listItem) ? 'checked' : 'unchecked';
            if (li.attributes.class) {
                li.attributes.class.add(className);
            }
            else {
                li.attributes.class = new Set([className]);
            }
            // Handle click in the checkbox.
            const handlerMouseDown = (ev) => {
                if (ev.offsetX < 0) {
                    ev.stopImmediatePropagation();
                    ev.preventDefault();
                    this.engine.editor.execCommand(() => {
                        return this.engine.editor.execWithRange(VRange_VRange.at(listItem.firstChild() || listItem), 'toggleChecked');
                    });
                }
            };
            li.attach = (el) => {
                el.addEventListener('mousedown', handlerMouseDown);
            };
            li.detach = (el) => {
                el.removeEventListener('mousedown', handlerMouseDown);
            };
        }
        return li;
    }
}
ListDomObjectRenderer_ListDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-list/src/ListItemAttributesDomObjectModifierRenderer.ts



class ListItemAttributesDomObjectModifierRenderer_ListItemAttributesDomObjectModifierRenderer extends ModifierRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ListItemXmlDomParser_ListItemAttributes;
    }
    /**
     * Rendering for ListItemAttributes Modifier.
     *
     * @param format
     * @param contents
     */
    async render(format, contents) {
        return contents;
    }
}
ListItemAttributesDomObjectModifierRenderer_ListItemAttributesDomObjectModifierRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-list/src/ListXmlDomParser.ts





const listTags = ['UL', 'OL'];
class ListXmlDomParser_ListXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && listTags.includes(nodeName(item));
        };
    }
    /**
     * Parse a list (UL, OL) and its children list elements (LI).
     *
     * @param context
     */
    async parse(item) {
        // Get the list's type (ORDERED, UNORDERED, CHECKLIST).
        let type;
        if (item.className.match(/(^| )checklist( |$)/i)) {
            type = ListType.CHECKLIST;
        }
        else {
            type = nodeName(item) === 'UL' ? ListType.UNORDERED : ListType.ORDERED;
        }
        // Create the list node and parse its children and attributes.
        const list = new ListNode_ListNode({ listType: type });
        const attributes = this.engine.parseAttributes(item);
        if (type === ListType.CHECKLIST) {
            attributes.classList.remove('checklist');
        }
        if (attributes.length) {
            list.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        list.append(...children);
        // In the case of a checklist, parse their checked/unchecked status and
        // ensure vertical propagation.
        if (type === ListType.CHECKLIST) {
            for (const child of children) {
                const liAttributes = child.modifiers.find(ListItemXmlDomParser_ListItemAttributes);
                if (liAttributes) {
                    // Parse the list item's checked status.
                    if (liAttributes.classList.has('checked')) {
                        ListNode_ListNode.check(child);
                    }
                    // Remove the checklist-related classes from `liAttributes`.
                    liAttributes.classList.remove('checklist checked unchecked');
                }
            }
        }
        return [list];
    }
}
ListXmlDomParser_ListXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-list/src/List.ts










class List_List extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            toggleList: {
                title: 'Toggle list',
                handler: this.toggleList,
            },
            indent: {
                title: 'Indent list items',
                selector: [ListNode_ListNode],
                handler: this.indent,
            },
            outdent: {
                title: 'Outdent list items',
                selector: [ListNode_ListNode],
                handler: this.outdent,
            },
            insertParagraphBreak: {
                selector: [ListNode_ListNode, List_List.isListItem],
                check: (context) => {
                    const [list, listItem] = context.selector;
                    return !listItem.hasChildren() && listItem === list.lastChild();
                },
                handler: this.insertParagraphBreak,
            },
            toggleChecked: {
                title: 'Check or uncheck list items',
                selector: [ListNode_ListNode.CHECKLIST],
                handler: this.toggleChecked,
            },
        };
        this.commandHooks = {
            // TODO: replace this with `onSiblingsChange` when we introduce events.
            deleteBackward: this.rejoin.bind(this),
            deleteForward: this.rejoin.bind(this),
        };
        this.loadables = {
            parsers: [ListXmlDomParser_ListXmlDomParser, ListItemXmlDomParser_ListItemXmlDomParser],
            renderers: [ListDomObjectRenderer_ListDomObjectRenderer, ListItemAttributesDomObjectModifierRenderer_ListItemAttributesDomObjectModifierRenderer],
            shortcuts: [
                {
                    pattern: 'CTRL+SHIFT+<Digit7>',
                    commandId: 'toggleList',
                    commandArgs: { type: ListType.ORDERED },
                },
                {
                    pattern: 'CTRL+SHIFT+<Digit8>',
                    commandId: 'toggleList',
                    commandArgs: { type: ListType.UNORDERED },
                },
                {
                    pattern: 'CTRL+SHIFT+<Digit9>',
                    commandId: 'toggleList',
                    commandArgs: { type: ListType.CHECKLIST },
                },
                {
                    pattern: 'CTRL+<Space>',
                    commandId: 'toggleChecked',
                },
                {
                    pattern: 'Backspace',
                    selector: [List_List.isListItem],
                    check: (context) => {
                        return !context.range.start.previousSibling();
                    },
                    commandId: 'outdent',
                },
            ],
            components: [
                {
                    id: 'OrderedListButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'ordered',
                            label: 'Toggle ordered list',
                            commandId: 'toggleList',
                            commandArgs: { type: ListType.ORDERED },
                            selected: (editor) => {
                                const range = editor.selection.range;
                                const startIsList = List_List.isInList(ListType.ORDERED, range.start);
                                if (!startIsList || range.isCollapsed()) {
                                    return startIsList;
                                }
                                else {
                                    return List_List.isInList(ListType.ORDERED, range.end);
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-list-ol fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'UnorderedListButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'unordered',
                            label: 'Toggle unordered list',
                            commandId: 'toggleList',
                            commandArgs: { type: ListType.UNORDERED },
                            selected: (editor) => {
                                const range = editor.selection.range;
                                const startIsList = List_List.isInList(ListType.UNORDERED, range.start);
                                if (!startIsList || range.isCollapsed()) {
                                    return startIsList;
                                }
                                else {
                                    return List_List.isInList(ListType.UNORDERED, range.end);
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-list-ul fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'ChecklistButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'checkbox',
                            label: 'Toggle checkbox list',
                            commandId: 'toggleList',
                            commandArgs: { type: ListType.CHECKLIST },
                            selected: (editor) => {
                                const range = editor.selection.range;
                                const startIsList = List_List.isInList(ListType.CHECKLIST, range.start);
                                if (!startIsList || range.isCollapsed()) {
                                    return startIsList;
                                }
                                else {
                                    return List_List.isInList(ListType.CHECKLIST, range.end);
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa far fa-check-square fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [
                ['OrderedListButton', ['actionables']],
                ['UnorderedListButton', ['actionables']],
                ['ChecklistButton', ['actionables']],
            ],
        };
    }
    static isListItem(node) {
        return node.parent && node.parent instanceof ListNode_ListNode;
    }
    static isInList(type, node) {
        var _a;
        return ((_a = node === null || node === void 0 ? void 0 : node.ancestor(ListNode_ListNode)) === null || _a === void 0 ? void 0 : _a.listType) === type;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Insert/remove a list at range.
     *
     * @param params
     */
    toggleList(params) {
        const type = params.type;
        const bounds = VRange_VRange.clone(params.context.range);
        const range = new VRange_VRange(this.editor, bounds);
        // Extend the range to cover the entirety of its containers.
        if (range.startContainer.hasChildren()) {
            range.setStart(range.startContainer.firstChild());
        }
        if (range.endContainer.hasChildren()) {
            range.setEnd(range.endContainer.lastChild());
        }
        // If all targeted nodes are within a list of given type then unlist
        // them. Otherwise, convert them to the given list type.
        const targetedNodes = range.targetedNodes();
        const ancestors = targetedNodes.map(node => node.closest(ListNode_ListNode));
        const targetedLists = ancestors.filter(list => !!list);
        if (targetedLists.length === targetedNodes.length &&
            targetedLists.every(list => list.listType === type)) {
            // Unlist the targeted nodes from all its list ancestors.
            while (range.start.ancestor(ListNode_ListNode)) {
                const nodesToUnlist = range.split(ListNode_ListNode);
                for (const list of nodesToUnlist) {
                    for (const child of list.childVNodes) {
                        // TODO: automatically invalidate `li-attributes`.
                        child.modifiers.remove(ListItemXmlDomParser_ListItemAttributes);
                    }
                    list.unwrap();
                }
            }
        }
        else if (targetedLists.length === targetedNodes.length) {
            // If all nodes are in lists, convert the targeted list
            // nodes to the given list type.
            const lists = distinct(targetedLists);
            const listsToConvert = lists.filter(l => l.listType !== type);
            for (const list of listsToConvert) {
                let newList = new ListNode_ListNode({ listType: type });
                list.replaceWith(newList);
                // If the new list is after or before a list of the same
                // type, merge them. Example:
                // <ol><li>a</li></ol><ol><li>b</li></ol>
                // => <ol><li>a</li><li>b</li></ol>).
                const previousSibling = newList.previousSibling();
                if (previousSibling && ListNode_ListNode[type](previousSibling)) {
                    newList.mergeWith(previousSibling);
                    newList = previousSibling;
                }
                const nextSibling = newList.nextSibling();
                if (nextSibling && ListNode_ListNode[type](nextSibling)) {
                    nextSibling.mergeWith(newList);
                }
            }
        }
        else {
            // If only some nodes are in lists and other aren't then only
            // wrap the ones that were not already in a list into a list of
            // the given type.
            let newList = new ListNode_ListNode({ listType: type });
            const nodesToConvert = range.split(ListNode_ListNode);
            for (const node of nodesToConvert) {
                // Merge top-level lists instead of nesting them.
                if (node instanceof ListNode_ListNode) {
                    node.mergeWith(newList);
                }
                else {
                    node.wrap(newList);
                }
            }
            // If the new list is after or before a list of the same type,
            // merge them. Example:
            // <ol><li>a</li></ol><ol><li>b</li></ol>
            // => <ol><li>a</li><li>b</li></ol>).
            const previousSibling = newList.previousSibling();
            if (previousSibling && ListNode_ListNode[type](previousSibling)) {
                newList.mergeWith(previousSibling);
                newList = previousSibling;
            }
            const nextSibling = newList.nextSibling();
            if (nextSibling && ListNode_ListNode[type](nextSibling)) {
                nextSibling.mergeWith(newList);
            }
        }
        range.remove();
    }
    /**
     * Indent one or more list items.
     *
     * @param params
     */
    indent(params) {
        const range = params.context.range;
        const items = range.targetedNodes(node => node.parent instanceof ListNode_ListNode);
        // Do not indent items of a targeted nested list, since they
        // will automatically be indented with their list ancestor.
        const itemsToIndent = items.filter(item => {
            return !items.includes(item.ancestor(ListNode_ListNode));
        });
        for (const item of itemsToIndent) {
            const prev = item.previousSibling();
            const next = item.nextSibling();
            // Indent the item by putting it into a pre-existing list sibling.
            if (prev && prev instanceof ListNode_ListNode) {
                prev.append(item);
                // The two list siblings might be rejoinable now that the lower
                // level item breaking them into two different lists is no more.
                const listType = prev.listType;
                if (ListNode_ListNode[listType](next) && !itemsToIndent.includes(next)) {
                    next.mergeWith(prev);
                }
            }
            else if (next instanceof ListNode_ListNode && !itemsToIndent.includes(next)) {
                next.prepend(item);
            }
            else {
                // If no other candidate exists then wrap it in a new ListNode.
                const listType = item.ancestor(ListNode_ListNode).listType;
                item.wrap(new ListNode_ListNode({ listType: listType }));
            }
        }
    }
    /**
     * Outdent one or more list items.
     *
     * @param params
     */
    outdent(params) {
        const range = params.context.range;
        const items = range.targetedNodes(node => node.parent instanceof ListNode_ListNode);
        // Do not outdent items of a targeted nested list, since they
        // will automatically be outdented with their list ancestor.
        const itemsToOutdent = items.filter(item => {
            return !items.includes(item.ancestor(ListNode_ListNode));
        });
        for (const item of itemsToOutdent) {
            const list = item.ancestor(ListNode_ListNode);
            const previousSibling = item.previousSibling();
            const nextSibling = item.nextSibling();
            if (previousSibling && nextSibling) {
                const splitList = item.parent.splitAt(item);
                splitList.before(item);
            }
            else if (previousSibling) {
                list.after(item);
            }
            else if (nextSibling) {
                list.before(item);
            }
            else {
                for (const child of list.childVNodes) {
                    // TODO: automatically invalidate `li-attributes`.
                    child.modifiers.remove(ListItemXmlDomParser_ListItemAttributes);
                }
                list.unwrap();
            }
        }
    }
    /**
     * Insert a paragraph break in the last empty item of a list by unwrapping
     * the list item from the list, thus becoming the new paragraph.
     *
     * @param params
     */
    insertParagraphBreak(params) {
        const range = params.context.range;
        const listItem = range.startContainer;
        const listNode = listItem.ancestor(ListNode_ListNode);
        if (listNode.children().length === 1) {
            listNode.unwrap();
        }
        else {
            listNode.after(listItem);
        }
    }
    /**
     * Rejoin same type lists that are now direct siblings after the remove.
     *
     * @param params
     */
    rejoin(params) {
        const range = params.context.range;
        const listAncestors = range.start.ancestors(ListNode_ListNode);
        if (listAncestors.length) {
            let list = listAncestors[listAncestors.length - 1];
            let nextSibling = list && list.nextSibling();
            while (list &&
                nextSibling &&
                list instanceof ListNode_ListNode &&
                ListNode_ListNode[list.listType](nextSibling)) {
                const nextList = list.lastChild();
                const nextListSibling = nextSibling.firstChild();
                nextSibling.mergeWith(list);
                list = nextList;
                nextSibling = nextListSibling;
            }
        }
    }
    /**
     * Check or uncheck the list items at range.
     *
     * @param params
     */
    toggleChecked(params) {
        const range = params.context.range;
        const items = range.targetedNodes(node => ListNode_ListNode.CHECKLIST(node.parent));
        const areAllChecked = items.every(ListNode_ListNode.isChecked);
        for (const item of items) {
            if (areAllChecked) {
                ListNode_ListNode.uncheck(item);
            }
            else {
                ListNode_ListNode.check(item);
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-indent/src/Indent.ts











class Indent_Indent extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            indent: {
                title: 'Indent chars',
                handler: this.indent,
            },
            outdent: {
                title: 'Outdent chars',
                handler: this.outdent,
            },
        };
        this.loadables = {
            shortcuts: [
                {
                    pattern: 'TAB',
                    commandId: 'indent',
                },
                {
                    pattern: 'SHIFT+TAB',
                    commandId: 'outdent',
                },
            ],
            components: [
                {
                    id: 'IndentButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'indent',
                            label: 'Indent',
                            commandId: 'indent',
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-indent fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'OutdentButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'outdent',
                            label: 'Outdent',
                            commandId: 'outdent',
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-outdent fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [
                ['IndentButton', ['actionables']],
                ['OutdentButton', ['actionables']],
            ],
        };
        this.tab = '\u2003'; // `&emsp;` ("em space")
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Indent text or lines.
     *
     * - If there is more than one line selected in range, indent each lines.
     * - Otherwise, insert 4 spaces.
     */
    async indent(params) {
        const range = params.context.range;
        const segmentBreaks = range.traversedNodes(this._isSegmentBreak);
        // Only indent when there is at leat two lines selected, that is when
        // at least one segment break could be identified in the selection.
        if (range.isCollapsed() || !segmentBreaks.length) {
            await params.context.execCommand('insertText', {
                text: this.tab,
                context: Object.assign(Object.assign({}, params.context), { range }),
            });
        }
        else {
            // The first line of the selection is neither fully selected nor
            // traversed so its segment break was not in `range.traversedNodes`.
            const nextSegmentBreak = range.start.previous(this._isSegmentBreak);
            if (nextSegmentBreak) {
                segmentBreaks.unshift(nextSegmentBreak);
            }
            for (const segmentBreak of segmentBreaks) {
                // Insert 4 spaces at the start of next segment.
                const [node, position] = this._nextSegmentStart(segmentBreak);
                await this.editor.execWithRange(VRange_VRange.at(node, position), 'insertText', {
                    text: this.tab,
                });
            }
        }
    }
    /**
     * Outdent lines.
     *
     * If there is more than one line selected, for each of the lines, remove up
     * to 4 spaces in the beggining of the line.
     */
    outdent(params) {
        const range = params.context.range;
        const segmentBreaks = range.traversedNodes(this._isSegmentBreak);
        // The first line of the selection is neither fully selected nor
        // traversed so its segment break was not in `range.traversedNodes`.
        const previousSegmentBreak = range.start.previous(this._isSegmentBreak);
        if (previousSegmentBreak) {
            segmentBreaks.unshift(previousSegmentBreak);
        }
        // Only outdent when there is at leat two lines selected, that is when
        // at least one segment break could be identified in the selection.
        if (segmentBreaks.length) {
            segmentBreaks.forEach(segmentBreak => {
                for (let i = 0; i < this.tab.length; i++) {
                    const space = this._nextIndentationSpace(segmentBreak);
                    if (space) {
                        space.remove();
                    }
                }
            });
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return true if the given VNode can be considered to be a segment break.
     *
     * @param params
     */
    _isSegmentBreak(node) {
        return node instanceof ContainerNode_ContainerNode || node instanceof LineBreakNode_LineBreakNode;
    }
    /**
     * Return the next segment start point after the given segment break.
     *
     * @param segmentBreak
     */
    _nextSegmentStart(segmentBreak) {
        let reference = segmentBreak;
        let position = RelativePosition.BEFORE;
        if (segmentBreak instanceof AtomicNode_AtomicNode) {
            reference = segmentBreak.nextSibling();
        }
        else if (segmentBreak.hasChildren()) {
            reference = segmentBreak.firstChild();
        }
        else {
            position = RelativePosition.INSIDE;
        }
        return [reference, position];
    }
    /**
     * Return true if the given VNode is a CharNode containing a space.
     *
     * @param node
     */
    _isSpace(node) {
        return node instanceof CharNode_CharNode && /^\s$/g.test(node.char);
    }
    /**
     * Return true if the given VNode can be considered to be a segment break.
     *
     * @param segmentBreak
     */
    _nextIndentationSpace(segmentBreak) {
        let space;
        if (segmentBreak instanceof AtomicNode_AtomicNode) {
            space = segmentBreak.nextSibling();
        }
        else {
            space = segmentBreak.firstChild();
        }
        return space && space.test(this._isSpace) && space;
    }
}
Indent_Indent.dependencies = [Char_Char, LineBreak_LineBreak];

// CONCATENATED MODULE: ./packages/plugin-inline/src/FormatXmlDomParser.ts



class FormatXmlDomParser_FormatXmlDomParser extends AbstractParser {
    /**
     * Parse a span node.
     *
     * @param nodes
     */
    applyFormat(format, nodes) {
        for (const node of nodes) {
            if (node instanceof InlineNode_InlineNode) {
                format.clone().applyTo(node);
            }
            else {
                const inlineNodes = node.descendants(InlineNode_InlineNode);
                for (const inline of inlineNodes) {
                    format.clone().applyTo(inline);
                }
            }
        }
    }
}
FormatXmlDomParser_FormatXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-span/src/SpanFormat.ts

class SpanFormat_SpanFormat extends Format_Format {
    constructor(htmlTag = 'SPAN') {
        super(htmlTag);
    }
}

// CONCATENATED MODULE: ./packages/plugin-span/src/SpanXmlDomParser.ts




class SpanXmlDomParser_SpanXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && (nodeName(item) === 'SPAN' || nodeName(item) === 'FONT');
        };
    }
    /**
     * Parse a span node.
     *
     * @param item
     */
    async parse(item) {
        const span = new SpanFormat_SpanFormat(nodeName(item));
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            span.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        // Handle empty spans.
        if (!children.length) {
            children.push(new InlineNode_InlineNode());
        }
        this.applyFormat(span, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-span/src/Span.ts



class Span_Span extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [SpanXmlDomParser_SpanXmlDomParser],
        };
    }
}
Span_Span.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-bold/src/BoldFormat.ts

class BoldFormat_BoldFormat extends Format_Format {
    constructor(htmlTag = 'B') {
        super(htmlTag);
    }
}

// CONCATENATED MODULE: ./packages/plugin-bold/src/BoldXmlDomParser.ts



class BoldXmlDomParser_BoldXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && (nodeName(item) === 'B' || nodeName(item) === 'STRONG');
        };
    }
    /**
     * Parse a bold node.
     *
     * @param item
     */
    async parse(item) {
        const bold = new BoldFormat_BoldFormat(nodeName(item));
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            bold.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(bold, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-bold/src/Bold.ts







class Bold_Bold extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [BoldXmlDomParser_BoldXmlDomParser],
            shortcuts: [
                {
                    pattern: 'CTRL+B',
                    commandId: 'toggleFormat',
                    commandArgs: { FormatClass: BoldFormat_BoldFormat },
                },
            ],
            components: [
                {
                    id: 'BoldButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'bold',
                            label: 'Toggle bold',
                            commandId: 'toggleFormat',
                            commandArgs: { FormatClass: BoldFormat_BoldFormat },
                            selected: (editor) => {
                                var _a, _b, _c;
                                const range = editor.selection.range;
                                if (range.isCollapsed()) {
                                    const pluginInline = editor.plugins.get(Inline_Inline);
                                    return !!((_a = pluginInline.getCurrentModifiers(range)) === null || _a === void 0 ? void 0 : _a.find(BoldFormat_BoldFormat));
                                }
                                else {
                                    const startIsFormated = !!((_b = range.start
                                        .nextSibling(InlineNode_InlineNode)) === null || _b === void 0 ? void 0 : _b.modifiers.find(BoldFormat_BoldFormat));
                                    if (!startIsFormated || range.isCollapsed()) {
                                        return startIsFormated;
                                    }
                                    else {
                                        return !!((_c = range.end
                                            .previousSibling(InlineNode_InlineNode)) === null || _c === void 0 ? void 0 : _c.modifiers.find(BoldFormat_BoldFormat));
                                    }
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-bold fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [['BoldButton', ['actionables']]],
        };
    }
}
Bold_Bold.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-italic/src/ItalicFormat.ts

class ItalicFormat_ItalicFormat extends Format_Format {
    constructor(htmlTag = 'I') {
        super(htmlTag);
    }
}

// CONCATENATED MODULE: ./packages/plugin-italic/src/ItalicXmlDomParser.ts



class ItalicXmlDomParser_ItalicXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && (nodeName(item) === 'I' || nodeName(item) === 'EM');
        };
    }
    /**
     * Parse an italic node.
     *
     * @param item
     */
    async parse(item) {
        const italic = new ItalicFormat_ItalicFormat(nodeName(item));
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            italic.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(italic, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-italic/src/Italic.ts







class Italic_Italic extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [ItalicXmlDomParser_ItalicXmlDomParser],
            shortcuts: [
                {
                    pattern: 'CTRL+I',
                    commandId: 'toggleFormat',
                    commandArgs: { FormatClass: ItalicFormat_ItalicFormat },
                },
            ],
            components: [
                {
                    id: 'ItalicButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'italic',
                            label: 'Toggle italic',
                            commandId: 'toggleFormat',
                            commandArgs: { FormatClass: ItalicFormat_ItalicFormat },
                            selected: (editor) => {
                                var _a, _b, _c;
                                const range = editor.selection.range;
                                if (range.isCollapsed()) {
                                    const pluginInline = editor.plugins.get(Inline_Inline);
                                    return !!((_a = pluginInline
                                        .getCurrentModifiers(range)) === null || _a === void 0 ? void 0 : _a.find(ItalicFormat_ItalicFormat));
                                }
                                else {
                                    const startIsFormated = !!((_b = range.start
                                        .nextSibling(InlineNode_InlineNode)) === null || _b === void 0 ? void 0 : _b.modifiers.find(ItalicFormat_ItalicFormat));
                                    if (!startIsFormated || range.isCollapsed()) {
                                        return startIsFormated;
                                    }
                                    else {
                                        return !!((_c = range.end
                                            .previousSibling(InlineNode_InlineNode)) === null || _c === void 0 ? void 0 : _c.modifiers.find(ItalicFormat_ItalicFormat));
                                    }
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-italic fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [['ItalicButton', ['actionables']]],
        };
    }
}
Italic_Italic.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-underline/src/UnderlineFormat.ts

class UnderlineFormat_UnderlineFormat extends Format_Format {
    constructor() {
        super(...arguments);
        this.htmlTag = 'U';
    }
}

// CONCATENATED MODULE: ./packages/plugin-underline/src/UnderlineXmlDomParser.ts



class UnderlineXmlDomParser_UnderlineXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'U';
        };
    }
    /**
     * Parse an underline node.
     *
     * @param item
     */
    async parse(item) {
        const underline = new UnderlineFormat_UnderlineFormat();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            underline.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(underline, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-underline/src/Underline.ts







class Underline_Underline extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [UnderlineXmlDomParser_UnderlineXmlDomParser],
            shortcuts: [
                {
                    pattern: 'CTRL+U',
                    commandId: 'toggleFormat',
                    commandArgs: { FormatClass: UnderlineFormat_UnderlineFormat },
                },
            ],
            components: [
                {
                    id: 'UnderlineButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'underline',
                            label: 'Toggle underline',
                            commandId: 'toggleFormat',
                            commandArgs: { FormatClass: UnderlineFormat_UnderlineFormat },
                            selected: (editor) => {
                                var _a, _b, _c;
                                const range = editor.selection.range;
                                if (range.isCollapsed()) {
                                    const pluginInline = editor.plugins.get(Inline_Inline);
                                    return !!((_a = pluginInline
                                        .getCurrentModifiers(range)) === null || _a === void 0 ? void 0 : _a.find(UnderlineFormat_UnderlineFormat));
                                }
                                else {
                                    const startIsFormated = !!((_b = range.start
                                        .nextSibling(InlineNode_InlineNode)) === null || _b === void 0 ? void 0 : _b.modifiers.find(UnderlineFormat_UnderlineFormat));
                                    if (!startIsFormated || range.isCollapsed()) {
                                        return startIsFormated;
                                    }
                                    else {
                                        return !!((_c = range.end
                                            .previousSibling(InlineNode_InlineNode)) === null || _c === void 0 ? void 0 : _c.modifiers.find(UnderlineFormat_UnderlineFormat));
                                    }
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-underline fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [['UnderlineButton', ['actionables']]],
        };
    }
}
Underline_Underline.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-link/src/LinkFormat.ts


class LinkFormat_LinkFormat extends Format_Format {
    constructor(url = '#', target = '') {
        super('A');
        this.preserve = false;
        this.url = url;
        if (target) {
            this.target = target;
        }
    }
    // TODO: Attributes on Link should reactively read the values set on the
    // node itself rather than having to manually synchronize them.
    get url() {
        var _a;
        return (_a = this.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.get('href');
    }
    set url(url) {
        this.modifiers.get(Attributes_Attributes).set('href', url);
    }
    get target() {
        var _a;
        return ((_a = this.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.get('target')) || '';
    }
    set target(target) {
        if (target.length) {
            this.modifiers.get(Attributes_Attributes).set('target', target);
        }
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * @override
     */
    clone() {
        const clone = super.clone();
        clone.url = this.url;
        return clone;
    }
}

// CONCATENATED MODULE: ./packages/plugin-link/src/LinkXmlDomParser.ts




class LinkXmlDomParser_LinkXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'A';
        };
    }
    async parse(item) {
        const link = new LinkFormat_LinkFormat(item.getAttribute('href'));
        // TODO: Link should not have an `Attributes` modifier outside of XML.
        // In XML context we need to conserve the order of attributes.
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            link.modifiers.replace(Attributes_Attributes, attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(link, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-layout/src/Layout.ts

class Layout_Layout extends JWPlugin {
    constructor() {
        super(...arguments);
        this.engines = {};
        this.loaders = {
            layoutEngines: this.loadEngines,
            components: this.loadComponents,
            componentZones: this.loadComponentsZones,
        };
        this.commands = {
            show: {
                title: 'Show a layout component',
                handler: this.show.bind(this),
            },
            hide: {
                title: 'Hide a layout component',
                handler: this.hide.bind(this),
            },
        };
    }
    async start() {
        this.loadComponents(this.configuration.components || []);
        this.loadComponentsZones(this.configuration.componentZones || []);
    }
    /**
     * Prepend a Component in a zone.
     *
     * @param componentId
     * @param zoneId
     * @param props
     */
    async prepend(componentId, zoneId = 'default', props) {
        const engines = Object.values(this.engines);
        await Promise.all(engines.map(engine => engine.prepend(componentId, zoneId, props)));
    }
    /**
     * Append a Component in a zone.
     *
     * @param componentId
     * @param zoneId
     */
    async append(componentId, zoneId = 'default', props) {
        const engines = Object.values(this.engines);
        await Promise.all(engines.map(engine => engine.append(componentId, zoneId, props)));
    }
    /**
     * Clear a zone content.
     *
     * @param zoneId
     */
    async clear(zoneId) {
        const engines = Object.values(this.engines);
        await Promise.all(engines.map(engine => engine.clear(zoneId)));
    }
    /**
     * Remove a component (instance or clonse) from the zone.
     *
     * @param componentId
     * @param zoneId specifying a zone if it is necessary to remove the
     *      component from this zone only
     */
    async remove(componentId, zoneId) {
        const promises = [];
        for (const layoutEngine of Object.values(this.engines)) {
            promises.push(layoutEngine.remove(componentId, zoneId));
        }
        await Promise.all(promises);
    }
    /**
     * Show component (instance or clonse) inside the zone.
     *
     * @param params
     */
    async show(params) {
        const promises = [];
        for (const layoutEngine of Object.values(this.engines)) {
            promises.push(layoutEngine.show(params.componentId));
        }
        await Promise.all(promises);
    }
    /**
     * Hide component (instance or clonse) inside the zone.
     *
     * @param params
     */
    async hide(params) {
        const promises = [];
        for (const layoutEngine of Object.values(this.engines)) {
            promises.push(layoutEngine.hide(params.componentId));
        }
        await Promise.all(promises);
    }
    /**
     * Load layout engines.
     *
     * @param layoutEngines
     */
    loadEngines(layoutEngines) {
        for (const EngineClass of layoutEngines) {
            const engine = new EngineClass(this.editor);
            if (this.engines[engine.constructor.id]) {
                throw new Error(`Rendering engine ${EngineClass.name} already registered.`);
            }
            this.engines[engine.constructor.id] = engine;
        }
    }
    /**
     * Load components into all layout engines.
     *
     * @param Components
     */
    loadComponents(Components) {
        for (const Component of Components) {
            for (const layoutEngine of Object.values(this.engines)) {
                layoutEngine.loadComponent(Component);
            }
        }
    }
    /**
     * Load component zones into all layout engines.
     *
     * @param componentsZones
     */
    loadComponentsZones(componentsZones) {
        const zones = {};
        for (const [id, zone] of componentsZones) {
            zones[id] = zone;
        }
        for (const layoutEngine of Object.values(this.engines)) {
            layoutEngine.loadComponentZones(zones);
        }
    }
}

// EXTERNAL MODULE: ./packages/plugin-link/assets/LinkForm.xml
var LinkForm = __webpack_require__(3);
var LinkForm_default = /*#__PURE__*/__webpack_require__.n(LinkForm);

// CONCATENATED MODULE: ./packages/plugin-owl/src/OwlNode.ts


class OwlNode_OwlNode extends AtomicNode_AtomicNode {
    constructor(params) {
        super(params);
        markNotVersionable(params);
        this.params = params;
    }
    get name() {
        return super.name + ': ' + this.params.Component.name;
    }
}

// EXTERNAL MODULE: ./node_modules/@odoo/owl/dist/owl.js
var owl = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/plugin-owl/src/OwlComponent.ts


class OwlComponent_OwlComponent extends owl["Component"] {
    constructor() {
        super(...arguments);
        this._storageKeyPrefix = 'OwlUI' + this.constructor.name + ':';
        // State items which names are listed in the localStorage property will be
        // read from the localStorage during the willStart of the component, and
        // wrote back to the localStorage whenever the state changes.
        this.localStorage = [];
    }
    /**
     * Owl hook called exactly once before the initial rendering.
     */
    willStart() {
        if (this.state) {
            this._importStateFromStorage(localStorage, this.localStorage);
            this.state = Object(owl["useState"])(this.state);
        }
        return super.willStart();
    }
    /**
     * Called by the Owl state observer every time the state changes.
     *
     * @param force see Owl Component
     */
    render(force = false) {
        if (this.state) {
            this._exportStateToStorage(localStorage, this.localStorage);
        }
        return super.render(force);
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Read the given storable state items from the given `storage` and write
     * the items as the key of the `state` property.
     *
     * @param storage from which to read the state items
     * @param storableItems names of the state items to read from storage
     */
    _importStateFromStorage(storage, storableItems) {
        storableItems.forEach(itemName => {
            const storageKey = this._storageKeyPrefix + itemName;
            const value = storage.getItem(storageKey);
            // The value of items that were not yet set in storage is null.
            if (value !== null) {
                // Otherwise, the value was stored as a string in the storage.
                // Convert it to the type of the default value for the state.
                try {
                    this.state[itemName] = JSON.parse(value);
                }
                catch (e) {
                    // Stored item is not parseable. Keep the default value.
                    console.warn(`Storage: Ignoring state.${itemName} stored value.\n` +
                        `${e.name}: ${e.message}\n` +
                        `Stored value: ${value}`);
                }
            }
        });
    }
    /**
     * For every key in the property `state`, write it back to `storage`
     * Write the given storable state items to the given storage.
     *
     * @param storage to write the state items to
     * @param storableItems names of the state items to write to storage
     */
    _exportStateToStorage(storage, storableItems) {
        storableItems.forEach(itemName => {
            const storageKey = this._storageKeyPrefix + itemName;
            // Storage require items to be stored as strings.
            try {
                const serializedValue = JSON.stringify(this.state[itemName]);
                storage.setItem(storageKey, serializedValue);
            }
            catch (e) {
                // State item is not serializable. Skip storing it.
                console.warn(`Storage: Unserializable state.${itemName} value.\n` +
                    `${e.name}: ${e.message}`);
            }
        });
    }
}

// CONCATENATED MODULE: ./packages/plugin-link/src/components/LinkComponent.ts



class LinkComponent_LinkComponent extends OwlComponent_OwlComponent {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.state = Object(owl["useState"])({
            url: ((_a = this.props) === null || _a === void 0 ? void 0 : _a.url) || '',
            label: ((_b = this.props) === null || _b === void 0 ? void 0 : _b.label) || '',
        });
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    async saveLink() {
        await this.env.editor.execCommand(async (context) => {
            const params = {
                url: this.state.url,
                label: this.state.label,
            };
            await context.execCommand('link', params);
            this.env.editor.plugins.get(Layout_Layout).remove('link');
        });
        this.destroy();
    }
    async cancel() {
        await this.env.editor.execCommand(async () => {
            this.env.editor.plugins.get(Layout_Layout).remove('link');
        });
        this.destroy();
    }
}
LinkComponent_LinkComponent.components = {};
LinkComponent_LinkComponent.template = 'link';

// CONCATENATED MODULE: ./packages/plugin-link/src/Link.ts













class Link_Link extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            link: {
                handler: this.link,
            },
            unlink: {
                handler: this.unlink,
            },
        };
        this.loadables = {
            parsers: [LinkXmlDomParser_LinkXmlDomParser],
            shortcuts: [
                {
                    pattern: 'CTRL+K',
                    selector: [(node) => !Link_Link.isLink(node)],
                    commandId: 'link',
                },
                {
                    pattern: 'CTRL+K',
                    selector: [Link_Link.isLink],
                    commandId: 'unlink',
                },
            ],
            components: [
                {
                    id: 'link',
                    async render(editor, props) {
                        return [new OwlNode_OwlNode({ Component: LinkComponent_LinkComponent, props: props })];
                    },
                },
                {
                    id: 'LinkButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'link',
                            label: 'Insert link',
                            commandId: 'link',
                            selected: (editor) => {
                                const range = editor.selection.range;
                                const node = range.start.nextSibling() || range.start.previousSibling();
                                return (node &&
                                    node instanceof InlineNode_InlineNode &&
                                    !!node.modifiers.find(LinkFormat_LinkFormat));
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-link fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'UnlinkButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'unlink',
                            label: 'Remove italic',
                            commandId: 'unlink',
                            enabled: (editor) => {
                                const range = editor.selection.range;
                                const node = range.start.nextSibling() || range.start.previousSibling();
                                return (node &&
                                    node instanceof InlineNode_InlineNode &&
                                    !!node.modifiers.find(LinkFormat_LinkFormat));
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-unlink fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [
                ['link', ['float']],
                ['LinkButton', ['actionables']],
                ['UnlinkButton', ['actionables']],
            ],
            owlTemplates: [LinkForm_default.a],
        };
    }
    static isLink(link, node) {
        if (link instanceof AbstractNode_AbstractNode) {
            node = link;
        }
        const format = node instanceof InlineNode_InlineNode && node.modifiers.find(LinkFormat_LinkFormat);
        return link instanceof AbstractNode_AbstractNode ? !!format : link.isSameAs(format);
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    async link(params) {
        // If the url is undefined, ask the user to provide one.
        const range = params.context.range;
        const selectedInlines = range.selectedNodes(InlineNode_InlineNode);
        const label = params.label || selectedInlines.map(node => node.textContent).join('');
        if (!params.url) {
            const firstLink = selectedInlines.find(node => node.modifiers.find(LinkFormat_LinkFormat));
            const link = firstLink && firstLink.modifiers.find(LinkFormat_LinkFormat).clone();
            const url = (link === null || link === void 0 ? void 0 : link.url) || '';
            const layout = this.editor.plugins.get(Layout_Layout);
            await layout.remove('link');
            return layout.append('link', undefined, { label: label, url: url });
        }
        // Otherwise create a link and insert it.
        const link = new LinkFormat_LinkFormat(params.url);
        if (params.target) {
            link.modifiers.get(Attributes_Attributes).set('target', params.target);
        }
        return params.context.execCommand('insertText', {
            text: label || link.url,
            formats: new Modifiers_Modifiers(link),
            context: params.context,
        });
    }
    unlink(params) {
        const range = params.context.range;
        if (range.isCollapsed()) {
            // If no range is selected and we are in a Link : remove the complete link.
            const previousNode = range.start.previousSibling();
            const nextNode = range.start.nextSibling();
            const node = Link_Link.isLink(previousNode) ? previousNode : nextNode;
            if (!Link_Link.isLink(node))
                return;
            const link = node.modifiers.find(LinkFormat_LinkFormat);
            const sameLink = Link_Link.isLink.bind(Link_Link, link);
            this._removeLinkOnNodes([node, ...node.adjacents(sameLink)]);
        }
        else {
            // If a range is selected : remove any link on the selected range.
            const selectedNodes = range.selectedNodes(InlineNode_InlineNode);
            // Remove the format 'LinkFormat' for all nodes.
            this._removeLinkOnNodes(selectedNodes);
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Remove all link modifiers on the provided nodes.
     * This method is mainly use by the unlink function of the editor.
     */
    _removeLinkOnNodes(nodes) {
        for (const node of nodes) {
            node.modifiers.remove(LinkFormat_LinkFormat);
        }
    }
}
Link_Link.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-divider/src/DividerNode.ts

class DividerNode_DividerNode extends VElement_VElement {
    constructor() {
        super({ htmlTag: 'DIV' });
    }
}

// CONCATENATED MODULE: ./packages/plugin-divider/src/DividerXmlDomParser.ts




class DividerXmlDomParser_DividerXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'DIV';
        };
    }
    async parse(item) {
        const divider = new DividerNode_DividerNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            divider.modifiers.append(attributes);
        }
        const nodes = await this.engine.parse(...item.childNodes);
        divider.append(...nodes);
        return [divider];
    }
}
DividerXmlDomParser_DividerXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-divider/src/Divider.ts


class Divider_Divider extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [DividerXmlDomParser_DividerXmlDomParser],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-image/src/ImageNode.ts

class ImageNode_ImageNode extends InlineNode_InlineNode {
}
ImageNode_ImageNode.atomic = true;

// CONCATENATED MODULE: ./packages/plugin-image/src/ImageXmlDomParser.ts




class ImageXmlDomParser_ImageXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'IMG';
        };
    }
    async parse(item) {
        const image = new ImageNode_ImageNode();
        image.modifiers.append(this.engine.parseAttributes(item));
        return [image];
    }
}
ImageXmlDomParser_ImageXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-image/src/ImageDomObjectRenderer.ts



class ImageDomObjectRenderer_ImageDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ImageNode_ImageNode;
    }
    async render(node, worker) {
        const select = () => {
            this.engine.editor.execCommand(() => {
                this.engine.editor.selection.select(node, node);
            });
        };
        const image = {
            tag: 'IMG',
            attach: (el) => {
                el.addEventListener('click', select);
            },
            detach: (el) => {
                el.removeEventListener('click', select);
            },
        };
        const isSelected = this.engine.editor.selection.range.selectedNodes(selectedNode => selectedNode === node).length;
        if (isSelected) {
            image.attributes = { class: new Set(['jw_selected_image']) };
        }
        worker.locate([node], image);
        return image;
    }
}
ImageDomObjectRenderer_ImageDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-image/src/Image.ts



class Image_Image extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [ImageXmlDomParser_ImageXmlDomParser],
            renderers: [ImageDomObjectRenderer_ImageDomObjectRenderer],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-subscript/src/SubscriptFormat.ts

class SubscriptFormat_SubscriptFormat extends Format_Format {
    constructor() {
        super('SUB');
    }
}

// CONCATENATED MODULE: ./packages/plugin-subscript/src/SubscriptXmlDomParser.ts



class SubscriptXmlDomParser_SubscriptXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'SUB';
        };
    }
    /**
     * Parse a span node.
     *
     * @param item
     */
    async parse(item) {
        const subscript = new SubscriptFormat_SubscriptFormat();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            subscript.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(subscript, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-subscript/src/Subscript.ts



class Subscript_Subscript extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [SubscriptXmlDomParser_SubscriptXmlDomParser],
        };
    }
}
Subscript_Subscript.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-superscript/src/SuperscriptFormat.ts

class SuperscriptFormat_SuperscriptFormat extends Format_Format {
    constructor() {
        super('SUP');
    }
}

// CONCATENATED MODULE: ./packages/plugin-superscript/src/SuperscriptXmlDomParser.ts



class SuperscriptXmlDomParser_SuperscriptXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'SUP';
        };
    }
    /**
     * Parse a span node.
     *
     * @param item
     */
    async parse(item) {
        const superscript = new SuperscriptFormat_SuperscriptFormat();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            superscript.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(superscript, children);
        return children;
    }
}

// CONCATENATED MODULE: ./packages/plugin-superscript/src/Superscript.ts



class Superscript_Superscript extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [SuperscriptXmlDomParser_SuperscriptXmlDomParser],
        };
    }
}
Superscript_Superscript.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-blockquote/src/BlockquoteNode.ts

class BlockquoteNode_BlockquoteNode extends VElement_VElement {
    constructor() {
        super({ htmlTag: 'BLOCKQUOTE' });
    }
}

// CONCATENATED MODULE: ./packages/plugin-blockquote/src/BlockquoteXmlDomParser.ts




class BlockquoteXmlDomParser_BlockquoteXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'BLOCKQUOTE';
        };
    }
    async parse(item) {
        const blockquote = new BlockquoteNode_BlockquoteNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            blockquote.modifiers.append(attributes);
        }
        const nodes = await this.engine.parse(...item.childNodes);
        blockquote.append(...nodes);
        return [blockquote];
    }
}
BlockquoteXmlDomParser_BlockquoteXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-blockquote/src/Blockquote.ts


class Blockquote_Blockquote extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [BlockquoteXmlDomParser_BlockquoteXmlDomParser],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-youtube/src/YoutubeNode.ts

class YoutubeNode_YoutubeNode extends InlineNode_InlineNode {
}
YoutubeNode_YoutubeNode.atomic = true;

// CONCATENATED MODULE: ./packages/plugin-youtube/src/YoutubeXmlDomParser.ts




class YoutubeXmlDomParser_YoutubeXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            const isYoutubeVideo = item instanceof Element &&
                nodeName(item) === 'IFRAME' &&
                item.getAttribute('src').includes('youtu');
            return isYoutubeVideo;
        };
    }
    async parse(item) {
        const youtube = new YoutubeNode_YoutubeNode();
        youtube.modifiers.append(this.engine.parseAttributes(item));
        return [youtube];
    }
}
YoutubeXmlDomParser_YoutubeXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-youtube/src/YoutubeDomObjectRenderer.ts



class YoutubeDomObjectRenderer_YoutubeDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = YoutubeNode_YoutubeNode;
    }
    async render() {
        const youtube = {
            tag: 'IFRAME',
        };
        return youtube;
    }
}
YoutubeDomObjectRenderer_YoutubeDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-youtube/src/Youtube.ts



class Youtube_Youtube extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [YoutubeXmlDomParser_YoutubeXmlDomParser],
            renderers: [YoutubeDomObjectRenderer_YoutubeDomObjectRenderer],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-table/src/TableXmlDomParser.ts







class TableXmlDomParser_TableXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return nodeName(item) === 'TABLE';
        };
    }
    /**
     * Parse a table node.
     *
     * @param item
     */
    async parse(item) {
        // Parse the table itself and its attributes.
        const table = new TableNode_TableNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            table.modifiers.append(attributes);
        }
        // Parse the contents of the table.
        const children = await this.engine.parse(...item.childNodes);
        // Build the grid.
        const dimensions = this._getTableDimensions(item);
        const parsedRows = children.filter(row => row instanceof TableRowNode_TableRowNode);
        const grid = this._createTableGrid(dimensions, parsedRows);
        // Append the cells to the rows.
        const rows = new Array(dimensions[0]);
        for (let rowIndex = 0; rowIndex < grid.length; rowIndex += 1) {
            rows[rowIndex] = parsedRows[rowIndex];
            const cells = grid[rowIndex];
            let row = rows[rowIndex];
            if (!row) {
                row = new TableRowNode_TableRowNode();
            }
            row.append(...cells);
        }
        // Append the rows and other children to the table.
        let rowIndex = 0;
        for (let childIndex = 0; childIndex < children.length; childIndex += 1) {
            const child = children[childIndex];
            if (child instanceof TableRowNode_TableRowNode) {
                const row = rows[rowIndex];
                table.append(row);
                rowIndex += 1;
            }
            else {
                table.append(children[childIndex]);
            }
        }
        return [table];
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return a tuple with the row length and the column length of the given DOM
     * table element.
     *
     * @param domTable
     */
    _getTableDimensions(domTable) {
        const domRows = Array.from(domTable.querySelectorAll('tr'));
        const domTableRows = domRows.filter(row => row.closest('table') === domTable);
        let columnCount = 0;
        if (domTableRows.length) {
            const domCells = Array.from(domTableRows[0].querySelectorAll('td, th'));
            const domTableCells = domCells.filter(cell => cell.closest('table') === domTable);
            for (const domChild of domTableCells) {
                columnCount += parseInt(domChild.getAttribute('colSpan') || '1', 10);
            }
        }
        return [domTableRows.length, columnCount];
    }
    /**
     * Build and return the grid (2D array: rows of cells) that will be used to
     * create the table. We want all the rows to have the same number of cells,
     * and all the columns to have the same number of cells.
     *
     * @param dimensions
     * @param rows
     */
    _createTableGrid(dimensions, rows) {
        const [rowCount, columnCount] = dimensions;
        // Initialize the grid (2D array: rows of cells).
        const grid = Array.from(Array(rowCount), () => new Array(columnCount));
        // Move every parsed child row to its place in the grid, and create
        // placeholder cells where there aren't any, accounting for column spans
        // and row spans.
        for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
            const row = rows[rowIndex];
            const cells = row.children(TableCellNode_TableCellNode).slice();
            for (let domCellIndex = 0; domCellIndex < cells.length; domCellIndex += 1) {
                const cell = cells[domCellIndex];
                // If there is a cell at this grid position already, it means we
                // added it there when handling another cell, ie. it's a
                // placeholder cell, managed by a previously handled cell.
                // The current cell needs to be added at the next available slot
                // instead.
                let columnIndex = domCellIndex;
                while (grid[rowIndex][columnIndex]) {
                    columnIndex += 1;
                }
                // Check traversing colspan and rowspan to insert placeholder
                // cells where necessary. Consume these attributes as they will
                // be replaced with getters.
                const attributes = cell.modifiers.find(Attributes_Attributes);
                let colspan = 1;
                let rowspan = 1;
                if (attributes) {
                    colspan = parseInt(attributes.get('colspan'), 10) || 1;
                    rowspan = parseInt(attributes.get('rowspan'), 10) || 1;
                    attributes.remove('colspan');
                    attributes.remove('rowspan');
                }
                for (let i = rowIndex; i < rowIndex + rowspan; i += 1) {
                    for (let j = columnIndex; j < columnIndex + colspan; j += 1) {
                        if (i === rowIndex && j === columnIndex) {
                            // Add the current cell to the grid.
                            grid[i][j] = cell;
                        }
                        else {
                            // Add a placeholder cell to the grid.
                            const placeholderCell = new TableCellNode_TableCellNode();
                            placeholderCell.mergeWith(cell);
                            grid[i][j] = placeholderCell;
                        }
                    }
                }
            }
        }
        // Insert empty cells in every undefined element of the grid.
        return grid.map(row => Array.from(row, cell => cell || new TableCellNode_TableCellNode()));
    }
}
TableXmlDomParser_TableXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TableRowXmlDomParser.ts





class TableRowXmlDomParser_TableSectionAttributes extends Attributes_Attributes {
}
class TableRowXmlDomParser_TableRowXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            const name = nodeName(item);
            return name === 'THEAD' || name === 'TBODY' || name === 'TR';
        };
    }
    /**
     * Parse a row node or a table section node.
     *
     * @param item
     */
    async parse(item) {
        if (this._isTableSection(item)) {
            return this.parseTableSection(item);
        }
        else if (nodeName(item) === 'TR') {
            const row = new TableRowNode_TableRowNode();
            const attributes = this.engine.parseAttributes(item);
            if (attributes.length) {
                row.modifiers.append(attributes);
            }
            const cells = await this.engine.parse(...item.childNodes);
            row.append(...cells);
            return [row];
        }
    }
    /**
     * Parse a <tbody> or a <thead> into an array of table rows with their
     * `header` property set in function of whether they are contained in a
     * <tbody> or a <thead>.
     *
     * @param tableSection
     */
    async parseTableSection(tableSection) {
        const parsedNodes = [];
        // Parse the section's children.
        for (const child of tableSection.childNodes) {
            parsedNodes.push(...(await this.engine.parse(child)));
        }
        // Parse the <tbody> or <thead>'s modifiers.
        const attributes = this.engine.parseAttributes(tableSection);
        // Apply the attributes, style and `header` property of the container to
        // each row.
        const name = nodeName(tableSection);
        for (const parsedNode of parsedNodes) {
            if (parsedNode instanceof TableRowNode_TableRowNode) {
                parsedNode.header = name === 'THEAD';
                parsedNode.modifiers.replace(TableRowXmlDomParser_TableSectionAttributes, new TableRowXmlDomParser_TableSectionAttributes(attributes));
            }
        }
        return parsedNodes;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return true if the given item is a table section element.
     *
     * @param item
     */
    _isTableSection(item) {
        const name = nodeName(item);
        return name === 'THEAD' || name === 'TBODY';
    }
}
TableRowXmlDomParser_TableRowXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TableCellXmlDomParser.ts




class TableCellXmlDomParser_TableCellXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            const name = nodeName(item);
            return name === 'TD' || name === 'TH';
        };
    }
    /**
     * Parse a table cell node.
     *
     * @param item
     */
    async parse(item) {
        const cell = new TableCellNode_TableCellNode({ header: nodeName(item) === 'TH' });
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            cell.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        cell.append(...children);
        return [cell];
    }
}
TableCellXmlDomParser_TableCellXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TableDomObjectRenderer.ts





class TableDomObjectRenderer_TableDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = TableNode_TableNode;
    }
    /**
     * Render the TableNode along with its contents (TableRowNodes).
     */
    async render(table, worker) {
        const objectTable = {
            tag: 'TABLE',
            children: [],
        };
        const objectHead = {
            tag: 'THEAD',
            children: [],
        };
        let objectBody = {
            tag: 'TBODY',
            children: [],
        };
        for (const child of table.children()) {
            if (child instanceof TableRowNode_TableRowNode) {
                // If the child is a row, append it to its containing section.
                const tableSection = child.header ? objectHead : objectBody;
                tableSection.children.push(child);
                this.engine.renderAttributes(TableRowXmlDomParser_TableSectionAttributes, child, tableSection, worker);
                if (!objectTable.children.includes(tableSection)) {
                    objectTable.children.push(tableSection);
                }
            }
            else {
                objectTable.children.push(child);
                // Create a new <tbody> so the rest of the rows, if any, get
                // appended to it, after this element.
                objectBody = {
                    tag: 'TBODY',
                    children: [],
                };
            }
        }
        return objectTable;
    }
}
TableDomObjectRenderer_TableDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TableRowDomObjectRenderer.ts



class TableRowDomObjectRenderer_TableRowDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = TableRowNode_TableRowNode;
    }
    /**
     * Render the TableRowNode along with its contents.
     */
    async render(row) {
        const objectRow = {
            tag: 'TR',
            children: row.children(),
        };
        return objectRow;
    }
}
TableRowDomObjectRenderer_TableRowDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TableCellDomObjectRenderer.ts






class TableCellDomObjectRenderer_TableCellDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = TableCellNode_TableCellNode;
    }
    async render(cell) {
        // If the cell is not active, do not render it (it means it is
        // represented by its manager cell's colspan or rowspan: it was merged).
        // TODO: remove `TableNode` check: it's a temporary fix for the memory
        // system, which should not try to render the cell if it's not in the
        // VDocument.
        if (!cell.isActive() || !cell.ancestor(TableNode_TableNode))
            return { children: [] };
        // Render the cell and its contents.
        const domObject = {
            tag: cell.header ? 'TH' : 'TD',
            children: await this.engine.renderChildren(cell),
            attributes: {},
        };
        // Colspan and rowspan are handled differently from other attributes:
        // they are automatically calculated in function of the cell's managed
        // cells. Render them here. If their value is 1 or less, they are
        // insignificant so no need to render them.
        if (cell.colspan > 1) {
            domObject.attributes.colspan = cell.colspan.toString();
        }
        if (cell.rowspan > 1) {
            domObject.attributes.rowspan = cell.rowspan.toString();
        }
        // Add buttons.
        const table = this.engine.editor.plugins.get(Table_Table);
        if (table.inlineUI && this.engine.editor.selection.range.isIn(cell)) {
            // Add row below.
            const rowBelowObject = this._makeButton('addRowBelow', cell, 'fa-plus-square');
            domObject.children.push(rowBelowObject);
            // Delete row.
            const deleteRowObject = this._makeButton('deleteRow', cell, 'fa-minus-square');
            domObject.children.push(deleteRowObject);
            // Add row above.
            const rowAboveObject = this._makeButton('addRowAbove', cell, 'fa-plus-square');
            domObject.children.push(rowAboveObject);
            // Add column before.
            const columnBeforeObject = this._makeButton('addColumnBefore', cell, 'fa-plus-square');
            domObject.children.push(columnBeforeObject);
            // Delete column.
            const deleteColumnObject = this._makeButton('deleteColumn', cell, 'fa-minus-square');
            domObject.children.push(deleteColumnObject);
            // Add column after.
            const columnAfterObject = this._makeButton('addColumnAfter', cell, 'fa-plus-square');
            domObject.children.push(columnAfterObject);
            // Position the buttons.
            domObject.attach = (domNode) => {
                const box = domNode.getBoundingClientRect();
                const top = window.scrollY + box.top;
                const bottom = window.scrollY + box.top + box.height;
                const middleX = box.left + box.width / 2;
                this._positionButton(rowAboveObject, top, middleX - 9);
                this._positionButton(deleteRowObject, top, middleX + 9);
                this._positionButton(rowBelowObject, bottom, middleX);
                const middleY = window.scrollY + box.top + box.height / 2;
                const left = box.left;
                const right = box.left + box.width;
                this._positionButton(columnBeforeObject, middleY - 9, left);
                this._positionButton(deleteColumnObject, middleY + 9, left);
                this._positionButton(columnAfterObject, middleY, right);
            };
        }
        return domObject;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Create a DomObjectNative representing a button that executes the give
     * command with a range at the given reference cell. If `remove` is true,
     * make a "minus" button. Otherwise, make it a "plus" button.
     *
     * @param commandId
     * @param referenceCell
     * @param faClass
     */
    _makeButton(commandId, referenceCell, faClass) {
        const rowAboveButton = document.createElement('span');
        rowAboveButton.className = 'fa ' + faClass + ' fa-fw table-handler';
        const rowAboveObject = { dom: [rowAboveButton] };
        const callback = async () => this.engine.editor.execWithRange(VRange_VRange.at(referenceCell), commandId);
        rowAboveObject.attach = (...domNodes) => {
            for (const domNode of domNodes) {
                domNode.addEventListener('click', callback);
            }
        };
        rowAboveObject.detach = (...domNodes) => {
            for (const domNode of domNodes) {
                domNode.removeEventListener('click', callback);
            }
        };
        return rowAboveObject;
    }
    /**
     * Position the button represented by a DomObjectNative at the given top and
     * left coordinates, taking into account the dimensions of the button
     * itself.
     *
     * @param buttonObject
     * @param top
     * @param left
     */
    _positionButton(buttonObject, top, left) {
        const button = buttonObject.dom[0];
        const buttonBox = button.getBoundingClientRect();
        button.style.top = top - buttonBox.height / 2 + 'px';
        button.style.left = left - buttonBox.width / 2 + 'px';
    }
}
TableCellDomObjectRenderer_TableCellDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TableSectionAttributesDomObjectModifierRenderer.ts



class TableSectionAttributesDomObjectModifierRenderer_TableSectionAttributesDomObjectModifierRenderer extends ModifierRenderer {
    constructor() {
        super(...arguments);
        this.predicate = TableRowXmlDomParser_TableSectionAttributes;
    }
    /**
     * Rendering for TableSectionAttributes Modifier.
     *
     * @param format
     * @param contents
     */
    async render(format, contents) {
        return contents;
    }
}
TableSectionAttributesDomObjectModifierRenderer_TableSectionAttributesDomObjectModifierRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TablePickerNode.ts


class TablePickerNode_TablePickerNode extends TableNode_TableNode {
    constructor(params) {
        super(params);
        this.modifiers.get(Attributes_Attributes).classList.add('table-picker');
    }
}

// CONCATENATED MODULE: ./packages/plugin-table/src/TablePickerDomObjectRenderer.ts





class TablePickerDomObjectRenderer_TablePickerDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = TablePickerNode_TablePickerNode;
    }
    async render(tablePicker, worker) {
        const domObject = (await this.super.render(tablePicker, worker));
        const tablePlugin = this.engine.editor.plugins.get(Table_Table);
        const layout = this.engine.editor.plugins.get(Layout_Layout).engines.dom;
        let attach;
        const close = async () => {
            this.engine.editor.execCommand(async () => {
                this.engine.editor.memoryInfo.uiCommand = true;
                if (attach &&
                    tablePlugin.isTablePickerOpen &&
                    layout.components.TablePicker.length) {
                    await layout.remove('TablePicker');
                }
            });
        };
        domObject.attach = () => {
            attach = true;
            tablePlugin.isTablePickerOpen = true;
            window.addEventListener('click', close, true);
        };
        domObject.detach = () => {
            attach = false;
            tablePlugin.isTablePickerOpen = false;
            window.removeEventListener('click', close, true);
        };
        return domObject;
    }
}
TablePickerDomObjectRenderer_TablePickerDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-table/src/TablePickerCellDomObjectRenderer.ts







class TablePickerCellDomObjectRenderer_TablePickerCellDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = (node) => { var _a; return node instanceof TableCellNode_TableCellNode && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) instanceof TablePickerNode_TablePickerNode; };
    }
    async render(tablePickerCell, worker) {
        const domObject = (await this.super.render(tablePickerCell, worker));
        domObject.attributes = Object.assign(Object.assign({}, domObject.attributes), {
            'data-rowCount': '' + (tablePickerCell.rowIndex + 1),
            'data-columnCount': '' + (tablePickerCell.columnIndex + 1),
        });
        const tablePlugin = this.engine.editor.plugins.get(Table_Table);
        const minRowCount = tablePlugin.minRowCount;
        const minColumnCount = tablePlugin.minColumnCount;
        const onMouseOver = (ev) => {
            const table = ev.target.closest('table.table-picker');
            for (const cell of table.querySelectorAll('td')) {
                const rowIndex = +cell.getAttribute('data-rowCount') - 1;
                const columnIndex = +cell.getAttribute('data-columnCount') - 1;
                if (rowIndex <= tablePickerCell.rowIndex &&
                    columnIndex <= tablePickerCell.columnIndex) {
                    cell.classList.add('highlight');
                }
                else {
                    cell.classList.remove('highlight');
                }
            }
            const tablePicker = tablePickerCell.ancestor(TableNode_TableNode);
            if (tablePickerCell.rowIndex >= tablePicker.rowCount - 1 ||
                tablePicker.rowCount > minRowCount ||
                tablePickerCell.columnIndex >= tablePicker.columnCount - 1 ||
                tablePicker.columnCount > minColumnCount) {
                this.engine.editor.execCommand(() => {
                    this.engine.editor.memoryInfo.uiCommand = true;
                    const toRedraw = new Set();
                    // Add/remove rows.
                    if (tablePickerCell.rowIndex >= tablePicker.rowCount - 1) {
                        // Add.
                        const newRow = new TableRowNode_TableRowNode();
                        toRedraw.add(newRow);
                        tablePicker.append(newRow);
                        for (let cellIndex = 0; cellIndex < tablePicker.columnCount; cellIndex++) {
                            const newCell = new TableCellNode_TableCellNode();
                            newRow.append(newCell);
                            toRedraw.add(newCell);
                        }
                    }
                    else if (tablePicker.rowCount > minRowCount) {
                        // Remove.
                        const rows = tablePicker.children(child => child instanceof TableRowNode_TableRowNode &&
                            child.rowIndex >= minRowCount &&
                            child.rowIndex > tablePickerCell.rowIndex + 1);
                        for (const row of rows) {
                            for (const rowCell of row.children(TableCellNode_TableCellNode)) {
                                rowCell.remove();
                            }
                            row.remove();
                        }
                        if (rows.length)
                            toRedraw.add(tablePicker);
                    }
                    // Add/remove Columns.
                    if (tablePickerCell.columnIndex >= tablePicker.columnCount - 1) {
                        // Add.
                        for (const row of tablePicker.children(TableRowNode_TableRowNode)) {
                            const newCell = new TableCellNode_TableCellNode();
                            row.append(newCell);
                            toRedraw.add(newCell);
                        }
                    }
                    else if (tablePicker.columnCount > minColumnCount) {
                        // Remove.
                        const cellsToRemove = tablePicker.descendants(descendant => descendant instanceof TableCellNode_TableCellNode &&
                            descendant.columnIndex >= minColumnCount &&
                            descendant.columnIndex > tablePickerCell.columnIndex + 1);
                        for (const cellToRemove of cellsToRemove) {
                            toRedraw.add(cellToRemove.parent);
                            cellToRemove.remove();
                        }
                        if (cellsToRemove.length)
                            toRedraw.add(tablePicker);
                    }
                });
            }
        };
        const onClick = async (ev) => {
            const cell = ev.target;
            await this.engine.editor.execCommand('insertTable', {
                rowCount: cell.getAttribute('data-rowCount'),
                columnCount: cell.getAttribute('data-columnCount'),
            });
        };
        domObject.attach = (el) => {
            el.addEventListener('mouseover', onMouseOver);
            el.addEventListener('click', onClick);
        };
        domObject.detach = (el) => {
            el.removeEventListener('mouseover', onMouseOver);
            el.removeEventListener('click', onClick);
        };
        return domObject;
    }
}
TablePickerCellDomObjectRenderer_TablePickerCellDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// EXTERNAL MODULE: ./packages/plugin-table/assets/tableUI.css
var tableUI = __webpack_require__(9);

// CONCATENATED MODULE: ./packages/plugin-table/src/Table.ts




















class Table_Table extends JWPlugin {
    constructor(editor, config) {
        super(editor, config);
        this.editor = editor;
        this.config = config;
        this.loadables = {
            parsers: [TableXmlDomParser_TableXmlDomParser, TableRowXmlDomParser_TableRowXmlDomParser, TableCellXmlDomParser_TableCellXmlDomParser],
            renderers: [
                TablePickerDomObjectRenderer_TablePickerDomObjectRenderer,
                TablePickerCellDomObjectRenderer_TablePickerCellDomObjectRenderer,
                TableDomObjectRenderer_TableDomObjectRenderer,
                TableRowDomObjectRenderer_TableRowDomObjectRenderer,
                TableCellDomObjectRenderer_TableCellDomObjectRenderer,
                TableSectionAttributesDomObjectModifierRenderer_TableSectionAttributesDomObjectModifierRenderer,
            ],
            shortcuts: [
                {
                    pattern: 'CTRL+SHIFT+DELETE',
                    commandId: 'deleteRow',
                },
                {
                    pattern: 'CTRL+SHIFT+BACKSPACE',
                    commandId: 'deleteColumn',
                },
                {
                    pattern: 'CTRL+ALT+SHIFT+DELETE',
                    commandId: 'deleteTable',
                },
                {
                    pattern: 'CTRL+<Period>',
                    commandId: 'mergeCells',
                },
                {
                    pattern: 'CTRL+SHIFT+<Period>',
                    commandId: 'unmergeCells',
                },
            ],
            components: [
                {
                    id: 'TableButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'tableButton',
                            label: 'Pick the size of the table you want to insert',
                            commandId: 'insertTable',
                            selected: (editor) => editor.plugins.get(Table_Table).isTablePickerOpen,
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-table fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'TablePicker',
                    async render(editor) {
                        const tablePlugin = editor.plugins.get(Table_Table);
                        const table = new TablePickerNode_TablePickerNode({
                            rowCount: tablePlugin.minRowCount,
                            columnCount: tablePlugin.minColumnCount,
                        });
                        return [table];
                    },
                },
            ],
            componentZones: [['TableButton', ['actionables']]],
        };
        this.commands = {
            insertTable: {
                handler: this.insertTable.bind(this),
            },
            addRowAbove: {
                handler: this.addRowAbove.bind(this),
            },
            addRowBelow: {
                handler: this.addRowBelow.bind(this),
            },
            addColumnBefore: {
                handler: this.addColumnBefore.bind(this),
            },
            addColumnAfter: {
                handler: this.addColumnAfter.bind(this),
            },
            deleteRow: {
                handler: this.deleteRow.bind(this),
            },
            deleteColumn: {
                handler: this.deleteColumn.bind(this),
            },
            deleteTable: {
                handler: this.deleteTable.bind(this),
            },
            mergeCells: {
                handler: this.mergeCells.bind(this),
            },
            unmergeCells: {
                handler: this.unmergeCells.bind(this),
            },
        };
        this.isTablePickerOpen = false;
        /**
         * The minimum row count for the table picker (default: 5).
         */
        this.minRowCount = 5;
        /**
         * The minimum column count for the table picker (default: 5).
         */
        this.minColumnCount = 5;
        /**
         * If true, add UI buttons inline in the table on render to add/remove
         * columns/rows.
         */
        this.inlineUI = false;
        if (config.minRowCount) {
            this.minRowCount = config.minRowCount;
        }
        if (config.minColumnCount) {
            this.minColumnCount = config.minColumnCount;
        }
        this.inlineUI = !!config.inlineUI;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Insert a table at range. If no dimensions are given for the table, open
     * the table picker in order to ask the user for dimensions.
     *
     * @param params
     */
    async insertTable(params) {
        const layout = this.editor.plugins.get(Layout_Layout);
        if (this.isTablePickerOpen) {
            await layout.remove('TablePicker');
        }
        if (!params.rowCount || !params.columnCount) {
            this.editor.memoryInfo.uiCommand = true;
            if (!this.isTablePickerOpen) {
                await layout.append('TablePicker', 'TableButton');
            }
        }
        else {
            const range = params.context.range;
            if (range.start.parent) {
                range.start.before(new TableNode_TableNode(params));
            }
        }
    }
    /**
     * Add a row above the cell at given range start.
     *
     * @param params
     */
    addRowAbove(params) {
        const range = params.context.range;
        const cell = range.start.ancestor(TableCellNode_TableCellNode);
        if (!cell)
            return;
        cell.ancestor(TableNode_TableNode).addRowAbove(cell);
    }
    /**
     * Add a row below the cell at given range start.
     *
     * @param params
     */
    addRowBelow(params) {
        const range = params.context.range;
        const row = range.start.ancestor(TableCellNode_TableCellNode);
        if (!row)
            return;
        row.ancestor(TableNode_TableNode).addRowBelow(row);
    }
    /**
     * Add a column before the cell at given range start.
     *
     * @param params
     */
    addColumnBefore(params) {
        const range = params.context.range;
        const cell = range.start.ancestor(TableCellNode_TableCellNode);
        if (!cell)
            return;
        cell.ancestor(TableNode_TableNode).addColumnBefore(cell);
    }
    /**
     * Add a column after the cell at given range start.
     *
     * @param params
     */
    addColumnAfter(params) {
        const range = params.context.range;
        const cell = range.start.ancestor(TableCellNode_TableCellNode);
        if (!cell)
            return;
        cell.ancestor(TableNode_TableNode).addColumnAfter(cell);
    }
    /**
     * Delete the row at given range start.
     *
     * @param params
     */
    deleteRow(params) {
        const range = params.context.range;
        const cell = range.start.ancestor(TableCellNode_TableCellNode);
        if (!cell)
            return;
        const row = cell.ancestor(TableRowNode_TableRowNode);
        const nextRow = row.nextSibling(TableRowNode_TableRowNode) || row.previousSibling(TableRowNode_TableRowNode);
        const nextCell = nextRow && nextRow.children(TableCellNode_TableCellNode)[cell.columnIndex];
        if (nextCell) {
            const nextRowIndex = nextCell.rowIndex;
            // Handle rowspans.
            const cells = row.children(TableCellNode_TableCellNode);
            for (const cell of cells) {
                if (cell.rowspan > 1) {
                    // Cells managed by this cell will now be managed by the
                    // cell below (or above if there is none below) instead.
                    const belowCell = Array.from(cell.managedCells).find(managedCell => managedCell.rowIndex === nextRowIndex);
                    if (belowCell) {
                        belowCell.unmerge();
                        for (const managedCell of cell.managedCells) {
                            if (managedCell !== belowCell) {
                                managedCell.mergeWith(belowCell);
                            }
                        }
                    }
                }
                else if (!cell.isActive()) {
                    // If this cell is inactive, unmerge it so its manager
                    // doesn't believe it still manages it.
                    cell.unmerge();
                }
            }
            // Remove the row.
            row.remove();
            // The place where the range used to live was just demolished. Give
            // it shelter within the next active cell.
            const nextActiveCell = nextCell.managerCell || nextCell;
            range.setStart(nextActiveCell.firstLeaf(), RelativePosition.BEFORE);
            range.collapse();
        }
        else {
            // If there is no `nextCell`, we're trying to delete the only row in
            // this table so just remove the table.
            this.deleteTable(params);
        }
    }
    /**
     * Delete the column at given range start.
     *
     * @param params
     */
    deleteColumn(params) {
        const range = params.context.range;
        const cell = range.start.ancestor(TableCellNode_TableCellNode);
        if (!cell)
            return;
        const column = cell.column;
        const nextCell = cell.nextSibling(TableCellNode_TableCellNode) || cell.previousSibling(TableCellNode_TableCellNode);
        if (nextCell) {
            const nextColumnIndex = nextCell.columnIndex;
            // Handle colspans and cell removal.
            for (const cell of column) {
                if (cell.colspan > 1) {
                    // Cells managed by this cell will now be managed by the
                    // cell after (or before if there is none after) instead.
                    const afterCell = Array.from(cell.managedCells).find(managedCell => managedCell.columnIndex === nextColumnIndex);
                    if (afterCell) {
                        afterCell.unmerge();
                        for (const managedCell of cell.managedCells) {
                            if (managedCell !== afterCell) {
                                managedCell.mergeWith(afterCell);
                            }
                        }
                    }
                }
                else if (!cell.isActive()) {
                    // If this cell is inactive, unmerge it so its manager
                    // doesn't believe it still manages it.
                    cell.unmerge();
                }
                // Remove the cell.
                cell.remove();
                // The place where the range used to live was just demolished.
                // Give it shelter within the next active cell.
                const nextManagerCell = nextCell.managerCell || nextCell;
                range.setStart(nextManagerCell.firstLeaf(), RelativePosition.BEFORE);
                range.collapse();
            }
        }
        else {
            // If there is no `nextCell`, we're trying to delete the only column
            // in this table so just remove the table.
            this.deleteTable(params);
        }
    }
    /**
     * Delete the table at given range start.
     *
     * @param params
     */
    deleteTable(params) {
        const range = params.context.range;
        const table = range.start.ancestor(TableNode_TableNode);
        if (!table)
            return;
        const nextSibling = table.nextSibling();
        const previousSibling = table.previousSibling();
        if (nextSibling) {
            range.setStart(nextSibling.firstLeaf(), RelativePosition.BEFORE);
            range.collapse();
        }
        else if (previousSibling) {
            range.setStart(previousSibling.lastLeaf(), RelativePosition.AFTER);
            range.collapse();
        }
        table.remove();
    }
    /**
     * Merge the cells at given range into the first cell at given range.
     *
     * @param params
     */
    mergeCells(params) {
        const range = params.context.range;
        const cells = range.targetedNodes(TableCellNode_TableCellNode);
        if (this._isRectangle(cells)) {
            // Only merge the cells if they would not imply to merge
            // unrelated cells, ie. the selected cells form a rectangle.
            const managerCell = cells.shift();
            const Separator = this.editor.configuration.defaults.Separator;
            for (const cell of cells) {
                if (managerCell.hasChildren()) {
                    managerCell.append(new Separator());
                }
                cell.mergeWith(managerCell);
            }
        }
    }
    /**
     * Unmerge previously merged cells at given range.
     *
     * @param params
     */
    unmergeCells(params) {
        const range = params.context.range;
        const cells = range.targetedNodes(TableCellNode_TableCellNode);
        for (const cell of cells) {
            for (const managedCell of cell.managedCells) {
                managedCell.unmerge();
            }
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return true if the given array of cells forms a rectangle in the table
     * grid.
     *
     * @param cells
     */
    _isRectangle(cells) {
        cells = [...cells];
        // Add managed cells to the list.
        for (const cell of [...cells]) {
            if (cell.managedCells.size) {
                cells.push(...cell.managedCells);
            }
        }
        cells = distinct(cells);
        // Compute the row/column index extrema.
        const rowIndices = cells.map(cell => cell.rowIndex);
        const columnIndices = cells.map(cell => cell.columnIndex);
        const minRowIndex = Math.min(...rowIndices);
        const minColumnIndex = Math.min(...columnIndices);
        const maxRowIndex = Math.max(...rowIndices);
        const maxColumnIndex = Math.max(...columnIndices);
        // If a cell between the extrema cannot be found in the list, the
        // selected cells do not form a rectangle.
        for (let rowIndex = minRowIndex; rowIndex <= maxRowIndex; rowIndex++) {
            for (let columnIndex = minColumnIndex; columnIndex <= maxColumnIndex; columnIndex++) {
                const cell = cells.find(cell => {
                    return cell.rowIndex === rowIndex && cell.columnIndex === columnIndex;
                });
                if (!cell) {
                    return false;
                }
            }
        }
        return true;
    }
}

// CONCATENATED MODULE: ./packages/plugin-metadata/src/MetadataNode.ts

class MetadataNode_MetadataNode extends MarkerNode_MarkerNode {
    constructor(params) {
        super(params);
        this.contents = '';
        this.htmlTag = params.htmlTag;
    }
    get name() {
        return this.constructor.name + ': ' + this.htmlTag;
    }
}
MetadataNode_MetadataNode.atomic = true;

// CONCATENATED MODULE: ./packages/plugin-metadata/src/MetadataXmlDomParser.ts




// See https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Metadata_content
const METADATA_NODENAMES = [
    'BASE',
    'COMMAND',
    'LINK',
    'META',
    'NOSCRIPT',
    'SCRIPT',
    'STYLE',
    'TITLE',
];
class MetadataXmlDomParser_MetadataXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && METADATA_NODENAMES.includes(nodeName(item));
        };
    }
    async parse(item) {
        const technical = new MetadataNode_MetadataNode({ htmlTag: nodeName(item) });
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            technical.modifiers.append(attributes);
        }
        technical.contents = item.innerHTML;
        return [technical];
    }
}
MetadataXmlDomParser_MetadataXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-metadata/src/MetaDataDomObjectRenderer.ts



class MetaDataDomObjectRenderer_MetadataDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = MetadataNode_MetadataNode;
    }
    async render(node) {
        const meta = {
            tag: node.htmlTag,
            children: [{ text: node.contents }],
        };
        return meta;
    }
}
MetaDataDomObjectRenderer_MetadataDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-metadata/src/Metadata.ts



class Metadata_Metadata extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [MetadataXmlDomParser_MetadataXmlDomParser],
            renderers: [MetaDataDomObjectRenderer_MetadataDomObjectRenderer],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-align/src/Align.ts




var AlignType;
(function (AlignType) {
    AlignType["LEFT"] = "left";
    AlignType["CENTER"] = "center";
    AlignType["RIGHT"] = "right";
    AlignType["JUSTIFY"] = "justify";
})(AlignType || (AlignType = {}));
class Align_Align extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            align: {
                handler: this.align.bind(this),
            },
        };
        this.loadables = {
            shortcuts: [
                {
                    pattern: 'Ctrl+Shift+L',
                    commandId: 'align',
                    commandArgs: { type: AlignType.LEFT },
                },
                {
                    pattern: 'Ctrl+Shift+E',
                    commandId: 'align',
                    commandArgs: { type: AlignType.CENTER },
                },
                {
                    pattern: 'Ctrl+Shift+R',
                    commandId: 'align',
                    commandArgs: { type: AlignType.RIGHT },
                },
                {
                    pattern: 'Ctrl+Shift+J',
                    commandId: 'align',
                    commandArgs: { type: AlignType.JUSTIFY },
                },
            ],
            components: [
                {
                    id: 'AlignLeftButton',
                    async render() {
                        return [alignButton(AlignType.LEFT)];
                    },
                },
                {
                    id: 'AlignCenterButton',
                    async render() {
                        return [alignButton(AlignType.CENTER)];
                    },
                },
                {
                    id: 'AlignRightButton',
                    async render() {
                        return [alignButton(AlignType.RIGHT)];
                    },
                },
                {
                    id: 'AlignJustifyButton',
                    async render() {
                        return [alignButton(AlignType.JUSTIFY)];
                    },
                },
            ],
            componentZones: [
                ['AlignLeftButton', ['actionables']],
                ['AlignCenterButton', ['actionables']],
                ['AlignRightButton', ['actionables']],
                ['AlignJustifyButton', ['actionables']],
            ],
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return true if the given node has the given alignment style. If no type
     * is passed, return true if the given node has an alignment style at all.
     *
     * @param node
     * @param [type]
     */
    static isAligned(node, type) {
        var _a;
        const align = (_a = node.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.style.get('text-align');
        return type ? align === null || align === void 0 ? void 0 : align.includes(type) : !!align;
    }
    /**
     * Align text.
     */
    align(params) {
        var _a, _b;
        const range = params.context.range;
        const nodes = range.targetedNodes();
        const type = params.type;
        for (const node of nodes.filter(node => !nodes.includes(node.parent))) {
            const alignedAncestor = node.closest(Align_Align.isAligned);
            // Compute current alignment.
            const currentAlignment = (_b = (_a = alignedAncestor === null || alignedAncestor === void 0 ? void 0 : alignedAncestor.modifiers) === null || _a === void 0 ? void 0 : _a.find(Attributes_Attributes)) === null || _b === void 0 ? void 0 : _b.style.get('text-align');
            if (!alignedAncestor || currentAlignment !== type) {
                node.modifiers.get(Attributes_Attributes).style.set('text-align', type.toLowerCase());
            }
        }
    }
}
Align_Align.dependencies = [];
function alignButton(type) {
    function isAligned(node, type) {
        const alignedAncestor = node.closest(Align_Align.isAligned);
        return Align_Align.isAligned(alignedAncestor || node, type);
    }
    const button = new ActionableNode_ActionableNode({
        name: 'align' + type,
        label: 'Align ' + type,
        commandId: 'align',
        commandArgs: { type: type },
        selected: (editor) => {
            const range = editor.selection.range;
            const ancestor = range.start.closest(ContainerNode_ContainerNode);
            const startIsAligned = ancestor && isAligned(ancestor, type);
            if (!startIsAligned || range.isCollapsed()) {
                return startIsAligned;
            }
            else {
                const ancestor = range.end.closest(ContainerNode_ContainerNode);
                return ancestor && isAligned(ancestor, type);
            }
        },
    });
    button.modifiers.append(new Attributes_Attributes({
        class: 'fa fa-align-' + type + ' fa-fw',
    }));
    return button;
}

// CONCATENATED MODULE: ./packages/plugin-pre/src/PreNode.ts

class PreNode_PreNode extends ContainerNode_ContainerNode {
}

// CONCATENATED MODULE: ./packages/plugin-pre/src/PreXmlDomParser.ts




class PreXmlDomParser_PreXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'PRE';
        };
    }
    async parse(item) {
        const pre = new PreNode_PreNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            pre.modifiers.append(attributes);
        }
        const children = await this.engine.parse(...item.childNodes);
        pre.append(...children);
        return [pre];
    }
}
PreXmlDomParser_PreXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-pre/src/PreDomObjectRenderer.ts



class PreDomObjectRenderer_PreDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = PreNode_PreNode;
    }
    /**
     * Render the VNode to the given format.
     */
    async render(node) {
        const pre = {
            tag: 'PRE',
            children: await this.engine.renderChildren(node),
        };
        return pre;
    }
}
PreDomObjectRenderer_PreDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-pre/src/PreCharDomObjectRenderer.ts




class PreCharDomObjectRenderer_PreCharDomObjectRenderer extends CharDomObjectRenderer_CharDomObjectRenderer {
    constructor() {
        super(...arguments);
        this.predicate = (item) => item instanceof CharNode_CharNode && !!item.ancestor(PreNode_PreNode);
    }
    async render(charNode, worker) {
        const domObject = await super.render(charNode, worker);
        this._renderInPre([domObject]);
        return domObject;
    }
    /**
     * Render the CharNode and convert unbreakable spaces into normal spaces.
     */
    async renderBatch(charNodes, worker) {
        const domObjects = await super.renderBatch(charNodes, worker);
        this._renderInPre(domObjects);
        return domObjects;
    }
    _renderInPre(domObjects) {
        const stack = [...domObjects];
        for (const domObject of stack) {
            if ('text' in domObject) {
                domObject.text = domObject.text
                    .replace(/\u00A0/g, ' ')
                    .replace(/\u2003/g, '\u0009');
            }
            if ('children' in domObject) {
                for (const child of domObject.children) {
                    if (!(child instanceof AbstractNode_AbstractNode)) {
                        stack.push(child);
                    }
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-pre/src/PreSeparatorDomObjectRenderer.ts



class PreSeparatorDomObjectRenderer_PreSeparatorDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            const DefaultSeparator = this.engine.editor.configuration.defaults.Separator;
            return item instanceof DefaultSeparator && !!item.ancestor(PreNode_PreNode);
        };
    }
    /**
     * Render the VNode.
     */
    async render(node, worker) {
        const separator = (await this.super.render(node, worker));
        let rendering;
        if ('tag' in separator) {
            rendering = { text: '\n' };
        }
        else {
            rendering = { text: '\n\n' };
            worker.locate([node, node], rendering);
        }
        return rendering;
    }
}
PreSeparatorDomObjectRenderer_PreSeparatorDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-pre/src/Pre.ts









class Pre_Pre extends JWPlugin {
    constructor() {
        super(...arguments);
        this.commands = {
            applyPreStyle: {
                handler: this.applyPreStyle,
            },
        };
        this.loadables = {
            parsers: [PreXmlDomParser_PreXmlDomParser],
            renderers: [PreDomObjectRenderer_PreDomObjectRenderer, PreSeparatorDomObjectRenderer_PreSeparatorDomObjectRenderer, PreCharDomObjectRenderer_PreCharDomObjectRenderer],
            components: [
                {
                    id: 'PreButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'pre',
                            label: 'Pre',
                            commandId: 'applyPreStyle',
                            selected: (editor) => {
                                const range = editor.selection.range;
                                const startPre = !!range.start.closest(PreNode_PreNode);
                                if (!startPre || range.isCollapsed()) {
                                    return startPre;
                                }
                                else {
                                    return !!range.end.closest(PreNode_PreNode);
                                }
                            },
                            modifiers: [new Attributes_Attributes({ class: 'pre' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [['PreButton', ['actionables']]],
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Change the formatting of the nodes in given range to Pre.
     *
     * @param params
     */
    applyPreStyle(params) {
        for (const node of params.context.range.targetedNodes(ContainerNode_ContainerNode)) {
            const pre = new PreNode_PreNode();
            pre.modifiers = node.modifiers.clone();
            node.replaceWith(pre);
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-color/src/Color.ts







class Color_Color extends JWPlugin {
    hasColor(color, node) {
        var _a;
        if (color instanceof AbstractNode_AbstractNode) {
            node = color;
        }
        const nodeColor = (_a = node.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.style.get(this.styleName);
        if (color instanceof AbstractNode_AbstractNode) {
            return !!nodeColor;
        }
        else {
            return nodeColor === color;
        }
    }
    /**
     * Apply the given color to the range.
     *
     * @param params
     */
    color(params) {
        const color = params.color;
        if (params.context.range.isCollapsed()) {
            // Set the style cache.
            const inline = this.dependencies.get(Inline_Inline);
            const currentCache = inline.cache.style || {};
            inline.cache.style = new CssStyle_CssStyle(Object.assign(Object.assign({}, currentCache), { [this.styleName]: color }));
        }
        else {
            let selectedNodes = params.context.range.selectedNodes();
            selectedNodes = selectedNodes.filter(node => !selectedNodes.includes(node.parent));
            // Color the highest ancestor.
            for (const node of selectedNodes) {
                // Color the highest fully selected format if any.
                const fullySelectedFormats = this._newFormats(node).filter(format => {
                    // This format is started by this node. Now find out if we
                    // end it within the selection.
                    return selectedNodes.includes(this._lastNodeWithFormat(node, format));
                });
                if (fullySelectedFormats.length) {
                    const highestFullFormat = fullySelectedFormats.pop();
                    const pairs = selectedNodes.map(selectedNode => {
                        const format = this._findFormat(selectedNode, highestFullFormat);
                        if (format) {
                            return [this._inheritsColorFrom(selectedNode, color), format];
                        }
                    });
                    for (const pair of pairs) {
                        if (pair === null || pair === void 0 ? void 0 : pair[1]) {
                            // Color the formats.
                            if (pair[0]) {
                                // If the node inherited the color, remove the
                                // inherited color.
                                this._removeColor(pair[0]);
                            }
                            this._applyColor(pair[1], color);
                        }
                    }
                }
                else if (!this._inheritsColorFrom(node, color)) {
                    // Skip if the node already has the right color, through an
                    // ancestor or a format.
                    this._applyColor(node, color);
                }
            }
        }
    }
    /**
     * Remove the current color from the range. If the color was applied to
     * an ancestor, apply the default color to its relevant inline descendants.
     *
     * @param params
     */
    uncolor(params) {
        var _a, _b, _c, _d;
        const range = params.context.range;
        const defaultColor = this.configuration.defaultColor;
        const hasColor = this.hasColor.bind(this);
        if (range.isCollapsed()) {
            const inline = this.dependencies.get(Inline_Inline);
            if (range.start.ancestor(hasColor)) {
                // Set the color style cache to the default color.
                if (!inline.cache.style) {
                    inline.cache.style = new CssStyle_CssStyle();
                }
                inline.cache.style.set(this.styleName, defaultColor);
            }
            else if (inline.cache.style) {
                // Unset the color style cache.
                inline.cache.style.remove(this.styleName);
            }
        }
        else {
            for (const node of params.context.range.selectedNodes()) {
                const target = this._nodeOrFirstFormat(node);
                const currentColor = (_a = target.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.style.get(this.styleName);
                if (!currentColor || currentColor === defaultColor || node.ancestor(hasColor)) {
                    // Set the color to the default color.
                    target.modifiers.get(Attributes_Attributes).style.set(this.styleName, defaultColor);
                }
                else {
                    // Remove the color.
                    (_b = target.modifiers.find(Attributes_Attributes)) === null || _b === void 0 ? void 0 : _b.style.remove(this.styleName);
                }
                // Uncolor the children and their formats as well.
                for (const child of node.children()) {
                    (_c = child.modifiers.find(Attributes_Attributes)) === null || _c === void 0 ? void 0 : _c.style.remove(this.styleName);
                    if (child instanceof InlineNode_InlineNode) {
                        for (const format of child.modifiers.filter(Format_Format)) {
                            (_d = format.modifiers.find(Attributes_Attributes)) === null || _d === void 0 ? void 0 : _d.style.remove(this.styleName);
                        }
                    }
                }
            }
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return the node's first format if any, itself otherwise.
     *
     * @param node
     */
    _nodeOrFirstFormat(node) {
        return node.modifiers.filter(Format_Format)[0] || node;
    }
    /**
     * Return true if all the children of the given node have the given color.
     *
     * @param node
     * @param color
     */
    _isAllColored(node, color) {
        return node.children().every(child => this.hasColor(color, child));
    }
    /**
     * Return the first format that matches the given format, on the given node.
     *
     * @param node
     * @param format
     */
    _findFormat(node, format) {
        return node.modifiers.filter(Format_Format).find(nodeFormat => nodeFormat.isSameAs(format));
    }
    /**
     * Return the last consecutive node to have the given format (assumed to be
     * held by the given node too).
     *
     * @param node
     * @param format
     */
    _lastNodeWithFormat(node, format) {
        let current = node;
        let next = node.nextSibling();
        while (this._findFormat(next, format)) {
            current = next;
            next = current.nextSibling();
        }
        return current;
    }
    /**
     * Return all formats that are started by the given node.
     *
     * @param node
     */
    _newFormats(node) {
        const formats = node.modifiers.filter(Format_Format);
        const previous = node.previousSibling();
        // A new format is starting if the previous sibling doesn't have it.
        if (!previous)
            return formats;
        return formats.filter(format => !this._findFormat(previous, format));
    }
    /**
     * If the given node inherits the given color through an ancestor of a
     * format, or if it simply has it itself, return the node or format it
     * inherits it from.
     *
     * @param node
     * @param color
     */
    _inheritsColorFrom(node, color) {
        if (this.hasColor(color, node)) {
            return node;
        }
        const colorAncestor = node.ancestor(this.hasColor.bind(this));
        if (colorAncestor && this.hasColor(color, colorAncestor)) {
            return colorAncestor;
        }
        for (const format of node.modifiers.filter(Format_Format)) {
            if (this.hasColor(color, format)) {
                return format;
            }
        }
    }
    _applyColor(node, color) {
        node.modifiers.get(Attributes_Attributes).style.set(this.styleName, color);
    }
    _removeColor(node) {
        node.modifiers.get(Attributes_Attributes).style.remove(this.styleName);
    }
}
Color_Color.dependencies = [Inline_Inline];

// CONCATENATED MODULE: ./packages/plugin-textcolor/src/TextColor.ts

class TextColor_TextColor extends Color_Color {
    constructor() {
        super(...arguments);
        this.styleName = 'color';
        this.configuration = Object.assign({ defaultColor: 'black' }, this.configuration);
        this.commands = {
            colorText: {
                handler: this.color,
            },
            uncolorText: {
                handler: this.uncolor,
            },
        };
        this.loadables = {
            shortcuts: [
                {
                    pattern: 'CTRL+G',
                    commandId: 'colorText',
                    // TODO: use dialog to get params
                    commandArgs: {
                        color: 'red',
                    },
                },
                {
                    pattern: 'CTRL+SHIFT+G',
                    commandId: 'uncolorText',
                },
            ],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-backgroundcolor/src/BackgroundColor.ts

class BackgroundColor_BackgroundColor extends Color_Color {
    constructor() {
        super(...arguments);
        this.styleName = 'background-color';
        this.configuration = Object.assign({ defaultColor: 'white' }, this.configuration);
        this.commands = {
            colorBackground: {
                handler: this.color,
            },
            uncolorBackground: {
                handler: this.uncolor,
            },
        };
        this.loadables = {
            shortcuts: [
                {
                    pattern: 'CTRL+H',
                    commandId: 'colorBackground',
                    // TODO: use dialog to get params
                    commandArgs: {
                        color: 'yellow',
                    },
                },
                {
                    pattern: 'CTRL+SHIFT+H',
                    commandId: 'uncolorBackground',
                },
            ],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-layout/src/ZoneNode.ts


class ZoneNode_ZoneNode extends ContainerNode_ContainerNode {
    constructor(params) {
        super(params);
        this.editable = false;
        this.breakable = false;
        this.managedZones = makeVersionable(params.managedZones);
    }
    get name() {
        return super.name + ': ' + this.managedZones.join();
    }
    hide(child) {
        if (!this.hidden) {
            this.hidden = makeVersionable({});
        }
        this.hidden[child.id] = true;
        return;
    }
    show(child) {
        var _a;
        const id = child.id;
        if ((_a = this.hidden) === null || _a === void 0 ? void 0 : _a[id]) {
            this.hidden[id] = false;
        }
        const parentZone = this.ancestor(ZoneNode_ZoneNode);
        if (parentZone) {
            parentZone.show(this);
        }
    }
    _removeAtIndex(index) {
        const child = this.childVNodes[index];
        super._removeAtIndex(index);
        if (this.hidden) {
            delete this.hidden[child.id];
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-layout/src/LayoutEngine.ts



class LayoutEngine_LayoutEngine {
    constructor(editor) {
        this.editor = editor;
        this.componentDefinitions = {};
        this.componentZones = {};
        this.root = new ZoneNode_ZoneNode({ managedZones: ['root'] });
        this.components = new VersionableObject();
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    /**
     * Automatically intanciate the components in available zones.
     */
    async start() {
        let allZones = [this.root, ...this.root.descendants(ZoneNode_ZoneNode)];
        await this.fillZones(allZones);
        allZones = [this.root, ...this.root.descendants(ZoneNode_ZoneNode)];
        if (!allZones.find(zone => zone.managedZones.includes('default'))) {
            // Add into the default zone if no valid zone could be found.
            throw new Error('Please define a "default" zone in your template.');
        }
        this.editor.memory.attach(this.root);
        this.editor.memory.attach(this.components);
    }
    /**
     * Hide all components.
     */
    async stop() {
        for (const id in this.components) {
            for (const node of this.components[id]) {
                const zone = node.ancestor(ZoneNode_ZoneNode);
                if (zone) {
                    zone.hide(node);
                }
            }
        }
        this.componentDefinitions = {};
        this.componentZones = {};
        this.components = {};
        this.root.empty();
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Load the given Component in this layout engine.
     *
     * @param componentDefinition
     */
    loadComponent(componentDefinition) {
        this.componentDefinitions[componentDefinition.id] = componentDefinition;
    }
    /**
     * Load component zones in this layout engine.
     *
     * @param componentZones
     */
    loadComponentZones(componentZones) {
        Object.assign(this.componentZones, componentZones);
    }
    /**
     * Prepend the given node in the given zone if it exists. Otherwise, add it in
     * the default zone.
     * Return every created instance
     *
     * @param componentId
     * @param zoneId
     * @param props
     */
    async prepend(componentId, zoneId, props) {
        const allZones = [this.root, ...this.root.descendants(ZoneNode_ZoneNode)];
        let matchingZones = allZones.filter(node => node.managedZones.includes(zoneId));
        if (!matchingZones.length) {
            matchingZones = allZones.filter(zone => zone.managedZones.includes('default'));
        }
        const componentDefinition = this.componentDefinitions[componentId];
        const newComponents = await this._instantiateComponent(componentDefinition, matchingZones, props, true);
        return this.fillZones(newComponents);
    }
    /**
     * Append the given node in the given zone if it exists. Otherwise, add it in
     * the default zone.
     * Return every created instance
     *
     * @param componentDefinition
     * @param zoneId
     */
    async append(componentId, zoneId, props) {
        const allZones = [this.root, ...this.root.descendants(ZoneNode_ZoneNode)];
        let matchingZones = allZones.filter(node => node.managedZones.includes(zoneId));
        if (!matchingZones.length) {
            matchingZones = allZones.filter(zone => zone.managedZones.includes('default'));
        }
        const componentDefinition = this.componentDefinitions[componentId];
        const newComponents = await this._instantiateComponent(componentDefinition, matchingZones, props);
        return this.fillZones(newComponents);
    }
    /**
     *
     * Remove the component identified by the given reference from all zones.
     *
     * @param componentId
     * @param zoneId specifying a zone if it is necessary to remove the
     *      component from this zone only
     */
    async remove(componentId, zoneId) {
        const components = [...(this.components[componentId] || [])];
        const zones = [];
        let component;
        while ((component = components.pop())) {
            // filter by zone if needed
            if (!zoneId ||
                component.ancestor(ancestor => ancestor instanceof ZoneNode_ZoneNode && ancestor.managedZones.includes(zoneId))) {
                // Remove all instances in the zone children.
                this._clear(component);
                // Remove the instance.
                const zone = component.ancestor(ZoneNode_ZoneNode);
                if (zone && !zones.includes(zone)) {
                    zones.push(zone);
                }
                component.remove();
            }
        }
        return zones;
    }
    async clear(zoneId) {
        const zones = this.root
            .descendants(ZoneNode_ZoneNode)
            .filter(zone => zone.managedZones.includes(zoneId));
        for (const zone of zones) {
            this._clear(zone);
        }
        return zones;
    }
    /**
     *
     * Show the components corresponding to given ref. Return the updated zones.
     *
     * @param componentId
     */
    async show(componentId) {
        const components = this.components[componentId];
        if (!(components === null || components === void 0 ? void 0 : components.length)) {
            console.warn('No component to show. Prepend or append it in a zone first.');
        }
        else {
            for (const component of components) {
                const zone = component.ancestor(ZoneNode_ZoneNode);
                zone.show(component);
            }
        }
        return components || [];
    }
    /**
     *
     * Hide the components corresponding to given ref. Return the updated zones.
     *
     * @param componentId
     */
    async hide(componentId) {
        const components = this.components[componentId];
        if (!(components === null || components === void 0 ? void 0 : components.length)) {
            console.warn('No component to hide. Prepend or append it in a zone first.');
        }
        else {
            for (const component of components) {
                const zone = component.ancestor(ZoneNode_ZoneNode);
                zone.hide(component);
            }
        }
        return components || [];
    }
    /**
     * Check if the string is a zone id where at leat one component will be
     * automatically added.
     *
     * @param zoneId
     */
    hasConfiguredComponents(zoneId) {
        var _a;
        // Check the zone list.
        for (const componentId in this.componentZones) {
            if ((_a = this.componentZones[componentId]) === null || _a === void 0 ? void 0 : _a.includes(zoneId)) {
                return true;
            }
        }
        // The components all have at least one zone equal to their id.
        return !!this.componentDefinitions[zoneId];
    }
    /**
     * Search into this new nodes if they are some ZoneNode and automatically
     * fill it by the components which match with this zones.
     *
     * @param nodes
     */
    async fillZones(nodes) {
        const newComponents = [];
        const stack = [...nodes];
        while (stack.length) {
            const node = stack.pop();
            const zones = node.descendants(ZoneNode_ZoneNode);
            if (node instanceof ZoneNode_ZoneNode) {
                zones.push(node);
            }
            for (const componentId in this.componentDefinitions) {
                const zoneIds = this.componentZones[componentId];
                const layoutComponent = this.componentDefinitions[componentId];
                // Filter the zones corresponding to the given identifier.
                let matchingZones = zones.filter(zone => (zoneIds && zone.managedZones.find(zoneId => zoneIds.includes(zoneId))) ||
                    zone.managedZones.includes(componentId));
                const components = this.components[componentId];
                if (components) {
                    // Excluding the ones that are contained within the given node.
                    // Avoid loop with child in itself.
                    matchingZones = matchingZones.filter(zone => !zone.closest(ancestor => components.includes(ancestor)));
                }
                if (matchingZones.length) {
                    stack.push(...(await this._instantiateComponent(layoutComponent, matchingZones)));
                }
            }
            newComponents.push(node);
        }
        return newComponents;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    async _instantiateComponent(componentDefinition, zones, props, prepend = false) {
        let components = this.components[componentDefinition.id];
        if (!components) {
            // Set the local reference.
            components = new VersionableArray();
            this.components[componentDefinition.id] = components;
        }
        // Add into the container.
        const newComponents = [];
        for (const zone of zones) {
            const nodes = await componentDefinition.render(this.editor, props);
            components.push(...nodes);
            newComponents.push(...nodes);
            if (prepend) {
                zone.prepend(...nodes);
            }
            else {
                zone.append(...nodes);
            }
        }
        // Return the components that were newly created.
        return newComponents;
    }
    _clear(component) {
        const zones = component.descendants(ZoneNode_ZoneNode);
        if (component instanceof ZoneNode_ZoneNode) {
            zones.push(component);
        }
        for (const zone of zones) {
            for (const child of zone.children()) {
                zone.removeChild(child);
                for (const id in this.components) {
                    const nodes = this.components[id];
                    if (nodes.includes(child)) {
                        nodes.splice(nodes.indexOf(child), 1);
                        break;
                    }
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./packages/utils/src/Dom.ts
/**
 * Return the deepest child of a given container at a given offset, and its
 * adapted offset.
 *
 * @param container
 * @param offset
 */
function targetDeepest(container, offset) {
    while (container.hasChildNodes()) {
        let childNodes;
        if (container instanceof Element && container.shadowRoot) {
            childNodes = container.shadowRoot.childNodes;
        }
        else {
            childNodes = container.childNodes;
        }
        if (offset >= childNodes.length) {
            container = container.lastChild;
            // The new container might be a text node, so considering only
            // the `childNodes` property would be wrong.
            offset = Dom_nodeLength(container);
        }
        else {
            container = childNodes[offset];
            offset = 0;
        }
    }
    return [container, offset];
}
/**
 * Return the length of a DOM Node.
 *
 * @param node
 */
function Dom_nodeLength(node) {
    if (node.nodeType === Node.TEXT_NODE) {
        return node.nodeValue.length;
    }
    else if (node instanceof Element && node.shadowRoot) {
        return node.shadowRoot.childNodes.length;
    }
    else {
        return node.childNodes.length;
    }
}
/**
 * Return if the node is a text node. Don't use instance of to allow iframe
 * uses.
 *
 * @param node
 */
function Dom_isTextNode(node) {
    return node.nodeName === '#text';
}

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/DomReconciliationEngine.ts





let diffObjectId = 0;
/**
 * Set the style of an element keeping the "!important" css modifier in the value
 */
function setStyle(element, name, value) {
    if (value.includes('!important')) {
        element.style.setProperty(name, value.replace('!important', ''), 'important');
    }
    else {
        element.style.setProperty(name, value);
    }
}
class DomReconciliationEngine_DomReconciliationEngine {
    constructor() {
        this._objects = {};
        this._objectIds = new Map();
        this._fromItem = new Map();
        this._fromDom = new Map();
        this._renderedNodes = new Map();
        this._renderedIds = new Set();
        this._locations = new Map();
        this._items = new Map();
        // The diff is filled in update when we compare the new domObject with the
        // old one, and the diff are consumed when we redraw the node.
        this._diff = {};
        this._rendererTreated = new Set();
        this._domUpdated = new Set();
    }
    update(updatedNodes, renderings, locations, from, domNodesToRedraw = new Set()) {
        var _a;
        const renderedSet = new Set();
        for (const node of updatedNodes) {
            const rendering = renderings.get(node);
            if (rendering) {
                renderedSet.add(rendering);
            }
        }
        const rendered = [...renderedSet];
        // Found the potential old values (they could become children of the current node).
        // In old values the renderer are may be merge some object, we want to found the
        // children object in old value to campare it with the newest.
        const mapOldIds = new Map();
        const domObjects = [];
        for (const domObject of rendered) {
            if (this._rendererTreated.has(domObject)) {
                continue;
            }
            domObjects.push(domObject);
            let oldObjects = mapOldIds.get(domObject);
            if (!oldObjects) {
                this._addLocations(domObject, locations, from);
                oldObjects = new Set();
                mapOldIds.set(domObject, oldObjects);
            }
            const nodes = this._items.get(domObject);
            for (const linkedNode of nodes) {
                const ids = this._renderedNodes.get(linkedNode);
                if (ids) {
                    for (const id of ids) {
                        if (!oldObjects.has(id)) {
                            const object = this._objects[id].object;
                            this._rendererTreated.delete(object);
                            this._objectIds.delete(object);
                            this._renderedIds.delete(id);
                            oldObjects.add(id);
                        }
                    }
                }
            }
            this._rendererTreated.delete(domObject);
            this._objectIds.delete(domObject);
        }
        // Make diff.
        for (const domObject of domObjects) {
            if (!this._objectIds.has(domObject)) {
                const items = this._items.get(domObject);
                const node = items.find(node => node instanceof AbstractNode_AbstractNode);
                const oldRefId = this._fromItem.get(node);
                const oldIds = mapOldIds.get(domObject);
                const id = this._diffObject(renderings, domObject, items, mapOldIds);
                this._renderedIds.add(id);
                const parentObject = (_a = this._objects[this._objects[id].parent]) === null || _a === void 0 ? void 0 : _a.object;
                if (oldRefId !== id ||
                    !parentObject ||
                    !this._rendererTreated.has(parentObject) ||
                    oldIds.size > 1) {
                    // If the rendering change, we must check if we redraw the parent.
                    const ancestorWithRendering = node.ancestor(ancestor => !!this._fromItem.get(ancestor));
                    if (!updatedNodes.includes(ancestorWithRendering)) {
                        const ancestorObjectId = this._fromItem.get(ancestorWithRendering);
                        if (ancestorObjectId && !this._diff[ancestorObjectId]) {
                            const parentObject = this._objects[ancestorObjectId];
                            const nodes = this._items.get(parentObject.object);
                            mapOldIds.set(parentObject.object, new Set([ancestorObjectId]));
                            this._rendererTreated.delete(parentObject.object);
                            this._diffObject(renderings, parentObject.object, nodes, mapOldIds);
                        }
                    }
                }
            }
        }
        const diffs = Object.values(this._diff);
        // Prepare path for fragment insertion in the dom.
        const objectsPath = {};
        for (const diff of diffs) {
            const object = this._objects[diff.id];
            const nodes = diff.dom.length ? diff.dom : this._getchildrenDomNodes(diff.id);
            const path = [];
            let parent = this._objects[object.parent];
            while (parent && !parent.object.tag) {
                parent = this._objects[parent.parent];
            }
            if (!parent) {
                let domNode = nodes[0];
                while (domNode && domNode.parentElement && domNode !== document.body) {
                    path.push([
                        domNode.parentElement,
                        [].indexOf.call(domNode.parentElement.childNodes, domNode),
                    ]);
                    domNode = domNode.parentElement;
                }
            }
            objectsPath[diff.id] = path;
        }
        // Select removed objects.
        const removeObjects = [];
        for (const diff of diffs) {
            for (const id of diff.removedChildren) {
                const object = this._objects[id];
                if (!object.parent) {
                    removeObjects.push(id);
                }
            }
        }
        for (const id of removeObjects) {
            const object = this._objects[id];
            if (!object.parent && removeObjects.includes(id)) {
                object.parent = null;
                for (const childId of object.children) {
                    const child = this._objects[childId];
                    if ((!child.parent || child.parent === id) &&
                        !removeObjects.includes(childId)) {
                        removeObjects.push(childId);
                    }
                }
            }
        }
        // Remove referencies to removed objects.
        const allOldDomNodes = [];
        for (const id of removeObjects) {
            const old = this._objects[id];
            if (typeof old.object.detach === 'function') {
                old.object.detach(...old.dom);
            }
            for (const node of this._locations.get(old.object) || []) {
                if (this._fromItem.get(node) === id) {
                    this._fromItem.delete(node);
                }
            }
            for (const node of this._items.get(old.object) || []) {
                const ids = this._renderedNodes.get(node);
                if (ids && ids.has(id)) {
                    this._renderedNodes.delete(node);
                }
            }
            if (old.dom) {
                for (const domNode of old.dom) {
                    if (this._fromDom.get(domNode) === id) {
                        this._fromDom.delete(domNode);
                        if (domNode instanceof Element) {
                            domNode.remove();
                        }
                        else {
                            allOldDomNodes.push(domNode);
                        }
                    }
                }
            }
            delete this._diff[id];
            delete this._objects[id];
            this._renderedIds.delete(id);
            this._items.delete(old.object);
            this._locations.delete(old.object);
            this._rendererTreated.delete(old.object);
            const i = diffs.findIndex(diff => diff.id === id);
            if (i !== -1) {
                diffs.splice(i, 1);
            }
        }
        // Unvalidate object linked to domNodesToRedraw;
        for (const domNode of domNodesToRedraw) {
            const id = this._fromDom.get(domNode);
            if (id) {
                if (this._diff[id]) {
                    this._diff[id].askCompleteRedrawing = true;
                }
                else if (this._objects[id]) {
                    const object = this._objects[id];
                    const domObject = object.object;
                    if (typeof domObject.detach === 'function') {
                        domObject.detach(...object.dom);
                    }
                    this._diff[id] = {
                        id: id,
                        attributes: {},
                        style: {},
                        classList: {},
                        dom: object.dom,
                        parentDomNode: object.parentDomNode,
                        removedChildren: [],
                        askCompleteRedrawing: true,
                    };
                    diffs.push(this._diff[id]);
                }
            }
            allOldDomNodes.push(domNode);
            allOldDomNodes.push(...domNode.childNodes);
        }
        // Select all dom nodes.
        for (const diff of diffs) {
            allOldDomNodes.push(...diff.dom);
        }
        // Sort the diff by ancestors.
        diffs.sort((da, db) => {
            let aLen = 0;
            let a = this._objects[da.id];
            while (a === null || a === void 0 ? void 0 : a.parent) {
                aLen++;
                a = this._objects[a.parent];
            }
            let bLen = 0;
            let b = this._objects[db.id];
            while (b === null || b === void 0 ? void 0 : b.parent) {
                bLen++;
                b = this._objects[b.parent];
            }
            return aLen - bLen;
        });
        // Redraw all objects.
        const objectToInsert = [];
        for (const diff of diffs) {
            if (this._updateDom(diff.id)) {
                objectToInsert.push(diff.id);
            }
        }
        // Insert object dom nodes which don't have direct object with nodeName
        // and not added by the updateDom because his parent have no diff.
        for (const id of objectToInsert) {
            const path = objectsPath[id] || [];
            const item = this._objects[id];
            let parent = this._objects[item.parent] || item;
            while (!parent.object.tag && parent.parent) {
                parent = this._objects[parent.parent];
            }
            const parentDomNode = parent.dom[0];
            const domNodes = [];
            for (const childId of parent.children) {
                domNodes.push(...this._getDomChild(childId, parentDomNode));
            }
            if (domNodes.length) {
                if (parent !== item && parent.object.tag) {
                    this._insertDomChildren(domNodes, parentDomNode, parentDomNode.firstChild);
                }
                else {
                    let parentDomNode;
                    let firstDomNode;
                    while (!parentDomNode && path.length) {
                        const pathItem = path.shift();
                        const isAvailableParent = pathItem[0].ownerDocument.contains(pathItem[0]) &&
                            !domNodes.find(domNode => pathItem[0] === domNode || domNode.contains(pathItem[0]));
                        if (isAvailableParent) {
                            parentDomNode = pathItem[0];
                            firstDomNode = parentDomNode.childNodes[pathItem[1]];
                        }
                    }
                    if (parentDomNode) {
                        this._insertDomChildren(domNodes, parentDomNode, firstDomNode);
                    }
                }
            }
        }
        // Clean/remove unused dom nodes.
        for (const domNode of allOldDomNodes) {
            if (!this._fromDom.get(domNode) && domNode.parentNode) {
                domNode.parentNode.removeChild(domNode);
            }
        }
        // Call attach methods for the changed domNodes.
        for (const id of this._domUpdated) {
            const object = this._objects[id];
            if (typeof (object === null || object === void 0 ? void 0 : object.object.attach) === 'function') {
                object.object.attach(...object.dom);
            }
        }
        this._domUpdated.clear();
    }
    /**
     * Return the VNodes linked in renderng to the given VNode.
     *
     * @param node
     */
    getRenderedWith(node) {
        const id = this._fromItem.get(node);
        if (id) {
            const object = this._objects[id];
            const locations = this._locations.get(object.object);
            return [...(locations.length ? locations : this._items.get(object.object))];
        }
        return [];
    }
    /**
     * Return the VNode(s) corresponding to the given DOM Node.
     *
     * @param domNode
     */
    fromDom(domNode) {
        let object;
        const nodes = [];
        while (!object && domNode) {
            object = this._objects[this._fromDom.get(domNode)];
            const locations = object && this._locations.get(object.object);
            const items = object && (locations.length ? locations : this._items.get(object.object));
            if (items === null || items === void 0 ? void 0 : items.length) {
                for (const item of items) {
                    if (item instanceof AbstractNode_AbstractNode) {
                        nodes.push(item);
                    }
                }
            }
            else {
                if (domNode.previousSibling) {
                    domNode = domNode.previousSibling;
                }
                else {
                    domNode = domNode.parentNode;
                }
            }
        }
        return nodes;
    }
    /**
     * Return the DOM Node corresponding to the given VNode.
     *
     * @param node
     */
    toDom(node) {
        const id = this._fromItem.get(node);
        const object = this._objects[id];
        if (!object) {
            return [];
        }
        else if (object.dom.length) {
            return [...object.dom];
        }
        else {
            return this._getchildrenDomNodes(id);
        }
    }
    /**
     * Return a position in the VNodes as a tuple containing a reference
     * node and a relative position with respect to this node ('BEFORE' or
     * 'AFTER'). The position is always given on the leaf.
     *
     * @param container
     * @param offset
     */
    locate(domNode, domOffset) {
        let forceAfter = false;
        let forcePrepend = false;
        let container = domNode;
        let offset = domOffset;
        // When targetting the end of a node, the DOM gives an offset that is
        // equal to the length of the container. In order to retrieve the last
        // descendent, we need to make sure we target an existing node, ie. an
        // existing index.
        if (!Dom_isTextNode(domNode) && offset >= nodeLength(container)) {
            forceAfter = true;
            offset = container.childNodes.length - 1;
            while (container.childNodes.length) {
                container = container.childNodes[offset];
                offset = container.childNodes.length - 1;
            }
        }
        // We targetting the deepest.
        while (container.childNodes[offset]) {
            if (forceAfter) {
                container = container.childNodes[nodeLength(container) - 1];
                offset = nodeLength(container) - 1;
            }
            else {
                container = container.childNodes[offset];
                offset = 0;
            }
        }
        // Search to domObject coresponding to the dom element.
        let object;
        while (!object) {
            const id = this._fromDom.get(container);
            if (id) {
                object = this._objects[id];
            }
            else if (container.previousSibling) {
                forceAfter = true;
                container = container.previousSibling;
                offset = nodeLength(container) - 1;
            }
            else {
                forcePrepend = true;
                offset = [].indexOf.call(container.parentNode.childNodes, container);
                container = container.parentNode;
            }
        }
        while (object.children[offset]) {
            const childId = object.children[offset];
            object = this._objects[childId];
            if (forceAfter && this._locations.get(object.object).length) {
                offset = this._locations.get(object.object).length - 1;
            }
            else {
                offset = 0;
            }
        }
        // For domObjectText, add the previous text length as offset.
        if (object.object.text && Dom_isTextNode(domNode)) {
            const texts = object.dom;
            let index = texts.indexOf(domNode);
            while (index > 0) {
                index--;
                offset += texts[index].textContent.length;
            }
        }
        let objectChild = object;
        while (!this._locations.get(object.object).length) {
            const parent = this._objects[object.parent];
            const index = parent.children.indexOf(object.id);
            if (index > 0) {
                object = this._objects[parent.children[index - 1]];
                offset = object.children.length - 1;
                const locations = this._locations.get(object.object);
                if (locations.length) {
                    return [locations[locations.length - 1], RelativePosition.AFTER];
                }
            }
            else {
                offset = parent.children.indexOf(objectChild.id);
                object = parent;
                objectChild = object;
                forcePrepend = true;
                const locations = this._locations.get(parent.object);
                if (locations.length === 1) {
                    offset = 0;
                    if (offset > parent.children.length / 2) {
                        forceAfter = true;
                    }
                }
            }
        }
        const locations = this._locations.get(object.object);
        if (!locations[offset]) {
            return [locations[locations.length - 1], RelativePosition.AFTER];
        }
        else if (forcePrepend && locations[offset] instanceof ContainerNode_ContainerNode) {
            return [locations[offset], RelativePosition.INSIDE];
        }
        else if (forceAfter) {
            return [locations[offset], RelativePosition.AFTER];
        }
        else {
            return [locations[offset], RelativePosition.BEFORE];
        }
    }
    /**
     * Clear the map of all correspondances.
     *
     */
    clear() {
        for (const objectMap of Object.values(this._objects)) {
            if (typeof objectMap.object.detach === 'function') {
                objectMap.object.detach(...objectMap.dom);
            }
        }
        for (const fromDom of this._fromDom) {
            const domNode = fromDom[0];
            if (domNode.parentNode) {
                domNode.parentNode.removeChild(domNode);
            }
        }
        this._objects = {};
        this._fromItem.clear();
        this._fromDom.clear();
        this._renderedNodes.clear();
        this._renderedIds.clear();
        this._objectIds.clear();
        this._locations.clear();
        this._items.clear();
        this._rendererTreated.clear();
        this._domUpdated.clear();
    }
    /**
     * Return the location in the DOM corresponding to the location in the
     * VDocument of the given VNode. The location in the DOM is expressed as a
     * tuple containing a reference Node and a relative position with respect to
     * the reference Node.
     *
     * @param node
     */
    getLocations(node) {
        let reference = node.previousSibling();
        let position = RelativePosition.AFTER;
        if (reference) {
            reference = reference.lastLeaf();
        }
        else {
            reference = node.nextSibling();
            position = RelativePosition.BEFORE;
            if (reference) {
                reference = reference.firstLeaf();
            }
        }
        if (!reference) {
            reference = node.parent;
            position = RelativePosition.INSIDE;
            if (!reference) {
                return;
            }
        }
        let object;
        let locations;
        // use the location
        let domNodes;
        const alreadyCheck = new Set();
        while (!domNodes && reference) {
            alreadyCheck.add(reference);
            const ids = this._renderedNodes.get(reference);
            if (ids) {
                for (let id of ids) {
                    object = this._objects[id];
                    locations = this._locations.get(object.object);
                    if (!locations.includes(reference)) {
                        let hasLocate;
                        const ids = [id];
                        while (ids.length && (!hasLocate || position === RelativePosition.AFTER)) {
                            const id = ids.pop();
                            const child = this._objects[id];
                            if (this._locations.get(child.object).includes(reference)) {
                                hasLocate = id;
                            }
                            if (child.children) {
                                ids.push(...[...child.children].reverse());
                            }
                        }
                        id = hasLocate;
                        object = this._objects[id];
                        locations = this._locations.get(object.object);
                    }
                    if (object.dom.length) {
                        if (!domNodes)
                            domNodes = [];
                        domNodes.push(...object.dom);
                    }
                    else {
                        if (!domNodes)
                            domNodes = [];
                        domNodes.push(...this._getchildrenDomNodes(id));
                    }
                }
            }
            if (!(domNodes === null || domNodes === void 0 ? void 0 : domNodes.length) || !domNodes[0].parentNode) {
                const next = reference.nextLeaf();
                if (next && !alreadyCheck.has(next)) {
                    position = RelativePosition.BEFORE;
                    reference = next;
                }
                else {
                    position = RelativePosition.INSIDE;
                    reference = reference.parent;
                }
                domNodes = null;
            }
        }
        let domNode;
        let offset = locations.lastIndexOf(reference);
        if (domNodes[0].nodeType === Node.TEXT_NODE) {
            let index = 0;
            while (offset >= domNodes[index].textContent.length) {
                offset -= domNodes[index].textContent.length;
                index++;
            }
            domNode = domNodes[index];
        }
        else {
            domNode = domNodes[offset];
            if (position === RelativePosition.INSIDE) {
                offset = 0;
            }
            else {
                // Char nodes have their offset in the corresponding text nodes
                // registered in the map via `set` but void nodes don't. Their
                // location need to be computed with respect to their parents.
                const container = domNode.parentNode;
                offset = Array.prototype.indexOf.call(container.childNodes, domNode);
                domNode = container;
            }
        }
        if (position === RelativePosition.AFTER) {
            // Increment the offset to be positioned after the reference node.
            offset += 1;
        }
        return [domNode, offset];
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    // eslint-disable-next-line max-params
    _diffObject(nodeToDomObject, domObject, fromNodes, mapOldIds, childrenMapping) {
        let oldIds = mapOldIds.get(domObject);
        const items = this._items.get(domObject);
        if (!oldIds) {
            oldIds = new Set();
            if (items) {
                for (const item of items) {
                    const ids = this._renderedNodes.get(item);
                    if (ids) {
                        for (const id of ids) {
                            if (!this._diff[id]) {
                                oldIds.add(id);
                            }
                        }
                    }
                }
            }
        }
        let hasChanged = false;
        if (oldIds.size) {
            for (const id of [...oldIds]) {
                const old = this._objects[id];
                if (!old || this._rendererTreated.has(old.object)) {
                    oldIds.delete(id);
                }
            }
            if (!childrenMapping) {
                childrenMapping = this._diffObjectAssociateChildrenMap(domObject, oldIds);
            }
            hasChanged = oldIds.size !== 1;
        }
        let id = childrenMapping === null || childrenMapping === void 0 ? void 0 : childrenMapping.get(domObject);
        if (id) {
            oldIds.add(id);
        }
        let old = this._objects[id];
        if (old && !this._rendererTreated.has(old.object)) {
            childrenMapping.delete(domObject);
            this._rendererTreated.add(old.object);
        }
        else {
            old = null;
            hasChanged = true;
            diffObjectId++;
            id = diffObjectId;
        }
        this._rendererTreated.add(domObject);
        this._objectIds.set(domObject, id);
        const removedChildren = [];
        const diffAttributes = {};
        const diffStyle = {};
        const diffClassList = {};
        const nodes = this._locations.get(domObject) || [];
        const attributes = {};
        const children = [];
        let domNodes = [];
        let allDomNodes = [];
        let domNodesChildren;
        let domNodesChildrenProcess;
        const oldChildren = (old === null || old === void 0 ? void 0 : old.children) || [];
        const newChildren = domObject.children || [];
        if (domObject.dom) {
            hasChanged = true;
            domNodes = domObject.dom;
            domNodesChildrenProcess = [];
            const placeholders = {};
            let havePlaceholder = false;
            for (const domNode of domNodes) {
                if (domNode instanceof Element) {
                    if (nodeName(domNode) === 'JW-DOMOBJECT-VNODE') {
                        havePlaceholder = true;
                        placeholders[domNode.id] = domNode;
                    }
                    else {
                        const childNodes = domNode.shadowRoot
                            ? domNode.shadowRoot.querySelectorAll('jw-domobject-vnode')
                            : domNode.querySelectorAll('jw-domobject-vnode');
                        for (const dom of childNodes) {
                            havePlaceholder = true;
                            placeholders[dom.id] = dom;
                        }
                    }
                }
            }
            if (havePlaceholder) {
                const placeholderVNodes = [];
                const allNodes = fromNodes.filter(item => item instanceof AbstractNode_AbstractNode);
                for (const node of allNodes) {
                    allNodes.push(...node.childVNodes);
                }
                for (const node of allNodes) {
                    const placeholder = placeholders[node.id];
                    if (placeholder) {
                        placeholderVNodes.push([placeholder, node]);
                    }
                }
                placeholderVNodes.reverse();
                for (const [placeholder, node] of placeholderVNodes) {
                    let child;
                    let index = domNodes.indexOf(placeholder);
                    if (index !== -1) {
                        if (index !== domNodes.length - 1) {
                            // Eg: [PLACEHOLDER, PLACEHOLDER, <div></div>]
                            child = [domNodes[index + 1], RelativePosition.BEFORE, [node]];
                        }
                        else {
                            // Eg: [<div></div>, PLACEHOLDER, PLACEHOLDER]
                            while (!child && index > 0) {
                                index--;
                                if (nodeName(domNodes[index]) !== 'JW-DOMOBJECT-VNODE') {
                                    child = [domNodes[index], RelativePosition.AFTER, [node]];
                                }
                            }
                        }
                        domNodes.splice(domNodes.indexOf(placeholder), 1);
                    }
                    else if (placeholder.nextSibling) {
                        // Eg: [<div>PLACEHOLDER<i></i></div>]
                        child = [placeholder.nextSibling, RelativePosition.BEFORE, [node]];
                    }
                    else if (placeholder.parentNode) {
                        // Eg: [<div><i></i>PLACEHOLDER</div>]
                        child = [placeholder.parentNode, RelativePosition.INSIDE, [node]];
                    }
                    if (child) {
                        const next = domNodesChildrenProcess.find(next => next[0] === child[0] && next[1] === child[1]);
                        if (next) {
                            next[2].unshift(node);
                        }
                        else {
                            domNodesChildrenProcess.push(child);
                        }
                    }
                    newChildren.push(node);
                    placeholder.remove();
                }
                if (!domNodesChildrenProcess.length) {
                    // Every domNodes are placeholder. It's like children only.
                    domNodesChildrenProcess = null;
                }
            }
            // Add all nodes as mapping to avoid association by children.
            allDomNodes = [];
            const allNodes = [...domNodes];
            while (allNodes.length) {
                const domNode = allNodes.pop();
                allDomNodes.push(domNode);
                if (domNode instanceof Element) {
                    allNodes.push(...domNode.childNodes);
                }
            }
        }
        for (const child of newChildren) {
            let childId;
            if (child instanceof AbstractNode_AbstractNode) {
                const domObject = nodeToDomObject.get(child);
                let oldChildId = this._objectIds.get(domObject) || this._fromItem.get(child);
                if (!oldChildId) {
                    const oldChildIds = this._renderedNodes.get(child);
                    if (oldChildIds === null || oldChildIds === void 0 ? void 0 : oldChildIds.size) {
                        oldChildId = [...oldChildIds][0];
                    }
                }
                const nodes = this._items.get(domObject);
                if (this._rendererTreated.has(domObject)) {
                    childId = oldChildId;
                }
                else if (!domObject) {
                    if (oldChildId) {
                        childId = oldChildId;
                    }
                    else {
                        console.error('No rendering for the node(' + child.id + '): ' + child.name);
                    }
                }
                else {
                    childId = this._diffObject(nodeToDomObject, domObject, nodes, mapOldIds);
                    this._renderedIds.add(childId);
                }
            }
            else if (this._rendererTreated.has(child)) {
                childId = this._objectIds.get(child);
            }
            else {
                childId = this._diffObject(nodeToDomObject, child, nodes, mapOldIds, childrenMapping);
            }
            if (childId) {
                this._objects[childId].parent = id;
                if (!children.includes(childId)) {
                    children.push(childId);
                }
            }
        }
        if (children.join() !== oldChildren.join()) {
            hasChanged = true;
            for (const childId of oldChildren) {
                if (!children.includes(childId)) {
                    if (this._objects[childId].parent === id) {
                        this._objects[childId].parent = null;
                    }
                    removedChildren.push(childId);
                }
            }
        }
        if (domNodesChildrenProcess) {
            domNodesChildren = [];
            for (const [ref, position, nodes] of domNodesChildrenProcess) {
                const nodeIds = nodes
                    .map(node => this._fromItem.get(node))
                    .filter(id => id);
                domNodesChildren.push([ref, position, nodeIds]);
            }
        }
        if (!domNodes.length && domObject.tag) {
            if (!old || domObject.tag !== old.object.tag) {
                hasChanged = true;
            }
            // Update attributes.
            const newAttributes = domObject.attributes || {};
            const oldAttributes = (old === null || old === void 0 ? void 0 : old.object.attributes) || {};
            for (const name in oldAttributes) {
                if (!newAttributes[name]) {
                    hasChanged = true;
                    if (name === 'style') {
                        for (const key in oldAttributes[name]) {
                            diffStyle[key] = null;
                        }
                    }
                    else if (name === 'class') {
                        for (const className of oldAttributes[name]) {
                            diffClassList[className] = false;
                        }
                    }
                    else {
                        diffAttributes[name] = null;
                    }
                }
            }
            for (const name in newAttributes) {
                if (name === 'style') {
                    const newStyle = newAttributes[name];
                    const oldStyle = oldAttributes[name];
                    if (oldStyle) {
                        for (const key in oldStyle) {
                            if (!newStyle[key]) {
                                hasChanged = true;
                                diffStyle[key] = null;
                            }
                        }
                    }
                    for (const key in newStyle) {
                        if (newStyle[key] !== (oldStyle === null || oldStyle === void 0 ? void 0 : oldStyle[key])) {
                            hasChanged = true;
                            diffStyle[key] = newStyle[key];
                        }
                    }
                }
                else if (name === 'class') {
                    const newClassNames = newAttributes[name];
                    const oldClassNames = oldAttributes[name];
                    if (oldClassNames) {
                        for (const className of oldClassNames) {
                            if (className && !newClassNames.has(className)) {
                                hasChanged = true;
                                diffClassList[className] = false;
                            }
                        }
                    }
                    for (const className of newClassNames) {
                        if (className && !(oldClassNames === null || oldClassNames === void 0 ? void 0 : oldClassNames.has(className))) {
                            hasChanged = true;
                            diffClassList[className] = true;
                        }
                    }
                }
                else {
                    const value = newAttributes[name];
                    if (value !== oldAttributes[name]) {
                        hasChanged = true;
                        diffAttributes[name] = value;
                    }
                }
                attributes[name] = newAttributes[name];
            }
        }
        else if (!domNodes.length && domObject.text) {
            if (!old || domObject.text !== old.object.text) {
                hasChanged = true;
            }
        }
        else if (!domNodes.length && (old === null || old === void 0 ? void 0 : old.dom.length)) {
            hasChanged = true;
        }
        // remove old referencies
        const oldIdsToRelease = [];
        if (items && oldIds.size) {
            oldIdsToRelease.push(...oldIds);
        }
        if (old) {
            oldIdsToRelease.push(old.id);
            if (typeof old.object.detach === 'function') {
                old.object.detach(...old.dom);
            }
        }
        for (const id of oldIdsToRelease) {
            const old = this._objects[id];
            for (const item of this._items.get(old.object)) {
                const ids = this._renderedNodes.get(item);
                if (ids && ids.has(id)) {
                    this._renderedNodes.delete(item);
                }
            }
        }
        // Add new referencies.
        for (const node of nodes) {
            this._fromItem.set(node, id);
        }
        if (items) {
            for (const item of [...items, ...this._items.get(domObject)]) {
                let ids = this._renderedNodes.get(item);
                if (!ids) {
                    ids = new Set();
                    this._renderedNodes.set(item, ids);
                }
                ids.add(id);
            }
        }
        if (!this._locations.get(domObject)) {
            this._locations.set(domObject, []);
        }
        this._objects[id] = {
            id: id,
            object: domObject,
            parent: old === null || old === void 0 ? void 0 : old.parent,
            children: children,
            dom: domNodes,
            domNodes: allDomNodes,
            domNodesChildren: domNodesChildren,
            parentDomNode: old === null || old === void 0 ? void 0 : old.parentDomNode,
        };
        if (hasChanged) {
            const oldDomNodes = (old === null || old === void 0 ? void 0 : old.dom) ? [...old.dom] : [];
            if (oldIds) {
                for (const id of oldIds) {
                    for (const domNode of this._objects[id].dom) {
                        if (!oldDomNodes.includes(domNode)) {
                            oldDomNodes.push(domNode);
                        }
                    }
                }
            }
            this._diff[id] = {
                id: id,
                attributes: diffAttributes,
                style: diffStyle,
                classList: diffClassList,
                dom: oldDomNodes,
                parentDomNode: old === null || old === void 0 ? void 0 : old.parentDomNode,
                removedChildren: removedChildren,
            };
        }
        else {
            this._objects[id].dom = old.dom;
            if (typeof domObject.attach === 'function') {
                domObject.attach(...old.dom);
            }
        }
        return id;
    }
    _diffObjectAssociateChildrenMap(objectA, objectIdsB) {
        const map = new Map();
        if (!objectIdsB.size) {
            return map;
        }
        const allChildrenA = [objectA];
        for (const domObject of allChildrenA) {
            if (domObject.children) {
                for (const child of domObject.children) {
                    if (!(child instanceof AbstractNode_AbstractNode)) {
                        allChildrenA.push(child);
                    }
                }
            }
        }
        const allChildrenB = [...objectIdsB];
        for (const id of allChildrenB) {
            const objB = this._objects[id];
            this._rendererTreated.delete(objB.object);
            if (objB === null || objB === void 0 ? void 0 : objB.children) {
                for (const id of objB.children) {
                    if (this._objects[id] && !this._renderedIds.has(id)) {
                        allChildrenB.push(id);
                    }
                }
            }
        }
        const mapRatios = this._diffObjectAssociateChildren(allChildrenA, allChildrenB);
        mapRatios.sort((a, b) => b[0] - a[0]);
        const used = new Set();
        for (const [, childRef, id] of mapRatios) {
            if (!map.get(childRef) && !used.has(id)) {
                map.set(childRef, id);
                used.add(id);
            }
        }
        return map;
    }
    _diffObjectAssociateChildren(arrayA, arrayB) {
        const mapRatios = [];
        for (const objectA of arrayA) {
            for (const idB of arrayB) {
                const itemB = this._objects[idB];
                const objectB = itemB.object;
                let currentRatio = 0;
                if (objectA.tag) {
                    if (objectA.tag === objectB.tag) {
                        const attrA = objectA.attributes || {};
                        const attrB = objectB.attributes;
                        // add some points for attributes matching
                        let max = 0;
                        let same = 0;
                        for (const name in attrA) {
                            if (name === 'style') {
                                const styleA = attrA[name];
                                const styleB = attrB === null || attrB === void 0 ? void 0 : attrB[name];
                                if (styleA) {
                                    for (const key in styleA) {
                                        max++;
                                        if (styleA[key] === (styleB === null || styleB === void 0 ? void 0 : styleB[key])) {
                                            same++;
                                        }
                                    }
                                }
                            }
                            else if (name === 'class') {
                                const classA = attrA[name];
                                const classB = attrB === null || attrB === void 0 ? void 0 : attrB[name];
                                if (classA) {
                                    for (const c of classA) {
                                        max++;
                                        if (classB === null || classB === void 0 ? void 0 : classB.has(c)) {
                                            same++;
                                        }
                                    }
                                }
                            }
                            else {
                                max++;
                                if (attrA[name] === (attrB === null || attrB === void 0 ? void 0 : attrB[name])) {
                                    same++;
                                }
                            }
                        }
                        for (const name in attrB) {
                            if (name === 'style') {
                                const styleA = attrA === null || attrA === void 0 ? void 0 : attrA[name];
                                const styleB = attrB[name];
                                if (styleB) {
                                    for (const key in styleB) {
                                        if (!styleA || !(key in styleA)) {
                                            max++;
                                        }
                                    }
                                }
                            }
                            else if (name === 'class') {
                                const classA = attrA === null || attrA === void 0 ? void 0 : attrA[name];
                                const classB = attrB[name];
                                if (classB) {
                                    for (const c of classB) {
                                        if (!(classA === null || classA === void 0 ? void 0 : classA.has(c))) {
                                            max++;
                                        }
                                    }
                                }
                            }
                            else if (!attrA || !(name in attrA)) {
                                max++;
                            }
                        }
                        currentRatio = 1 + same / (max || 1);
                    }
                }
                else if (objectA.text) {
                    if (objectB.text) {
                        currentRatio = 1;
                    }
                }
                else if (objectA.dom) {
                    if (itemB.dom.length && !objectB.tag && !objectB.text) {
                        currentRatio = 1;
                    }
                }
                else if (objectA.children) {
                    if (itemB.children && !objectB.text && !objectB.tag) {
                        currentRatio = 1;
                    }
                }
                if (currentRatio >= 1) {
                    // The best have at leat on node in common or the twice does not have node.
                    const itemsA = this._items.get(objectA);
                    const itemsB = this._items.get(objectB);
                    // Some points for children nodes.
                    let matchNode = 0;
                    let maxNode = 0;
                    for (const node of itemsA) {
                        if (node instanceof AbstractNode_AbstractNode) {
                            maxNode++;
                            if (itemsB.includes(node)) {
                                matchNode++;
                            }
                        }
                    }
                    for (const node of itemsB) {
                        if (node instanceof AbstractNode_AbstractNode) {
                            if (!itemsB.includes(node)) {
                                maxNode++;
                            }
                        }
                    }
                    const nodeRatio = maxNode ? matchNode / maxNode : 1;
                    if (nodeRatio > 0) {
                        currentRatio += nodeRatio;
                        // The best candidate must have the most common located nodes.
                        const locA = this._locations.get(objectA);
                        const locB = this._locations.get(objectB);
                        let match = 0;
                        let max = 0;
                        for (const node of locA) {
                            max++;
                            if (locB.includes(node)) {
                                match++;
                            }
                        }
                        for (const node of locB) {
                            if (!locA.includes(node)) {
                                max++;
                            }
                        }
                        currentRatio += max ? match / max : 0;
                        // The best candidate must have the most common modifiers.
                        let matchModifier = 0;
                        let maxModifier = 0;
                        for (const node of itemsA) {
                            if (!(node instanceof AbstractNode_AbstractNode)) {
                                maxModifier++;
                                if (itemsB.includes(node)) {
                                    matchModifier++;
                                }
                            }
                        }
                        for (const node of itemsB) {
                            if (!(node instanceof AbstractNode_AbstractNode)) {
                                if (!itemsB.includes(node)) {
                                    maxModifier++;
                                }
                            }
                        }
                        currentRatio += (maxModifier ? matchModifier / maxModifier : 0) / 10;
                        mapRatios.push([currentRatio, objectA, idB]);
                    }
                }
            }
        }
        return mapRatios;
    }
    _addLocations(domObject, locations, from) {
        const allItems = [];
        const items = from.get(domObject);
        if (items) {
            for (const item of items) {
                if (!allItems.includes(item)) {
                    allItems.push(item);
                }
            }
        }
        const nodes = locations.get(domObject);
        if (nodes) {
            this._locations.set(domObject, nodes ? Array.from(nodes) : []);
            for (const node of nodes) {
                if (!allItems.includes(node)) {
                    allItems.push(node);
                }
            }
        }
        else {
            this._locations.set(domObject, []);
        }
        if (domObject.children) {
            for (const index in domObject.children) {
                const child = domObject.children[index];
                if (!(child instanceof AbstractNode_AbstractNode)) {
                    for (const node of this._addLocations(child, locations, from)) {
                        allItems.push(node);
                    }
                }
            }
        }
        this._items.set(domObject, allItems);
        return allItems;
    }
    _updateDom(id) {
        var _a;
        const diff = this._diff[id];
        if (!diff) {
            return;
        }
        const object = this._objects[id];
        const domObject = object.object;
        let newNode = false;
        if (domObject.tag) {
            let domNode = this._getAvailableElement(id);
            if (domNode && !domObject.shadowRoot !== !domNode.shadowRoot) {
                domNode = null;
            }
            let attributes;
            if (domNode) {
                if (diff.askCompleteRedrawing) {
                    for (const attr of domNode.attributes) {
                        const value = domObject.attributes[attr.name];
                        if (typeof value === 'undefined') {
                            domNode.removeAttribute(attr.name);
                        }
                    }
                    attributes = domObject.attributes;
                }
                else {
                    attributes = diff.attributes;
                }
                if (!diff.askCompleteRedrawing) {
                    for (const name in diff.style) {
                        setStyle(domNode, name, diff.style[name] || '');
                    }
                    for (const name in diff.classList) {
                        if (diff.classList[name]) {
                            domNode.classList.add(name);
                        }
                        else {
                            domNode.classList.remove(name);
                        }
                    }
                }
            }
            else {
                domNode = document.createElement(domObject.tag);
                attributes = domObject.attributes;
                if (domObject.shadowRoot) {
                    domNode.attachShadow({ mode: 'open' });
                }
            }
            for (const name in attributes) {
                if (name === 'style') {
                    const style = attributes[name];
                    for (const name in style) {
                        setStyle(domNode, name, style[name]);
                    }
                    // Now we set the attribute again to keep order.
                    const styleInline = domNode.getAttribute('style');
                    if (styleInline) {
                        domNode.setAttribute('style', styleInline);
                    }
                }
                else if (name === 'class') {
                    const classList = attributes[name];
                    for (const className of classList) {
                        domNode.classList.add(className);
                    }
                    // Now we set the attribute again to keep order.
                    const classInline = domNode.getAttribute('class');
                    if (classInline) {
                        domNode.setAttribute('class', classInline);
                    }
                }
                else {
                    const value = attributes[name];
                    if (typeof value === 'string') {
                        domNode.setAttribute(name, value);
                    }
                    else if (!value) {
                        domNode.removeAttribute(name);
                    }
                }
            }
            if (domNode.getAttribute('class') === '') {
                domNode.removeAttribute('class');
            }
            if (domNode.getAttribute('style') === '') {
                domNode.removeAttribute('style');
            }
            object.dom = [domNode];
        }
        else if (domObject.text) {
            object.dom = this._redrawAndAssociateText(id);
        }
        else if (object.domNodesChildren && object.dom.length) {
            for (const domNode of object.dom) {
                if (this._fromDom.get(domNode) !== id) {
                    this._fromDom.set(domNode, id);
                    newNode = true;
                }
            }
            // Add all nodes as mapping to avoid association by children.
            for (const domNode of object.domNodes) {
                this._fromDom.set(domNode, id);
            }
            // Insert children in the dom which locate with the placeholder.
            for (const [ref, position, childIds] of object.domNodesChildren) {
                if (position === RelativePosition.INSIDE) {
                    const childDomNodes = flat(childIds.map(childId => this._getDomChild(childId, ref)));
                    for (const domNode of childDomNodes) {
                        ref.appendChild(domNode);
                    }
                }
                else {
                    const childDomNodes = flat(childIds.map(childId => this._getDomChild(childId, ref.parentElement)));
                    if (position === RelativePosition.BEFORE) {
                        for (const domNode of childDomNodes) {
                            ref.parentElement.insertBefore(domNode, ref);
                        }
                    }
                    else if (ref.nextSibling) {
                        const next = ref.nextSibling;
                        for (const domNode of childDomNodes) {
                            ref.parentElement.insertBefore(domNode, next);
                        }
                    }
                    else {
                        ref.parentElement.append(...childDomNodes);
                    }
                }
            }
            // Remove protected mapping.
            for (const domNode of object.domNodes) {
                this._fromDom.delete(domNode);
            }
            for (const domNode of object.dom) {
                this._fromDom.set(domNode, id);
            }
            // TODO remove ?
            let item = (_a = diff.dom) === null || _a === void 0 ? void 0 : _a[0];
            const parent = item === null || item === void 0 ? void 0 : item.parentNode;
            if (parent) {
                for (const domNode of object.dom) {
                    if (!item) {
                        parent.appendChild(domNode);
                    }
                    else if (domNode !== item) {
                        parent.insertBefore(domNode, item);
                    }
                    else {
                        item = domNode.nextSibling;
                    }
                }
            }
        }
        for (const domNode of diff.dom) {
            if (this._fromDom.get(domNode) === id && !object.dom.includes(domNode)) {
                this._fromDom.delete(domNode);
            }
        }
        for (const domNode of object.dom) {
            if (this._fromDom.get(domNode) !== id || !domNode.parentNode) {
                this._fromDom.set(domNode, id);
                newNode = true;
            }
        }
        if (!object.domNodesChildren && object.children.length) {
            let parentDomNode = object.parentDomNode;
            if (domObject.tag) {
                parentDomNode = object.dom[0];
                if (domObject.shadowRoot) {
                    parentDomNode = parentDomNode.shadowRoot;
                }
            }
            const domNodes = [];
            for (const childId of object.children) {
                domNodes.push(...this._getDomChild(childId, parentDomNode));
            }
            if (domNodes.length) {
                if (domObject.tag) {
                    this._insertDomChildren(domNodes, parentDomNode, parentDomNode.firstChild);
                }
                else {
                    newNode = true;
                }
            }
        }
        delete this._diff[id];
        this._domUpdated.add(id);
        return newNode;
    }
    _getDomChild(id, parentDomNode) {
        // Apply diff for descendents if needed.
        const descendents = [id];
        for (const id of descendents) {
            const descendent = this._objects[id];
            descendent.parentDomNode = parentDomNode;
            if (this._diff[id]) {
                this._updateDom(id);
            }
            else if (!('tag' in descendent.object) && descendent.children) {
                // Get children if it's a fragment.
                descendents.push(...descendent.children);
            }
        }
        // Get the dom representing this child.
        let domNodes = [];
        const child = this._objects[id];
        if (child.dom.length) {
            domNodes = child.dom;
        }
        else {
            domNodes = this._getchildrenDomNodes(id);
        }
        return domNodes;
    }
    _redrawAndAssociateText(id) {
        var _a;
        const domObject = this._objects[id].object;
        const textContent = domObject.text;
        let textNodes = this._getAvailableTextNodes(id);
        if (textNodes) {
            const chars = [];
            for (const textNode of textNodes) {
                const split = textNode.textContent.split('');
                for (let i = 0; i < split.length; i++) {
                    chars.push([split[i], textNode, i]);
                }
            }
            const len = textContent.length;
            const charLen = chars.length;
            const maxLen = Math.max(len, charLen);
            let index = 0;
            let indexFirstChange = null; // index from begin
            let indexLastChange = null; // index from end
            while ((indexFirstChange === null || indexLastChange === null) && index < maxLen) {
                if (indexFirstChange === null) {
                    const char = textContent[index];
                    const old = chars[index];
                    if (!old || char !== old[0]) {
                        indexFirstChange = index;
                    }
                }
                if (indexLastChange === null) {
                    const char = textContent[len - 1 - index];
                    const old = chars[charLen - 1 - index];
                    if (!old || char !== old[0]) {
                        indexLastChange = index;
                    }
                }
                index++;
            }
            if (indexFirstChange !== null) {
                let textBegin;
                let textEnd;
                let first;
                let center;
                let last;
                const charBegin = chars[indexFirstChange];
                if (charBegin) {
                    textBegin = textEnd = charBegin[1];
                    first = textBegin.textContent.slice(0, charBegin[2]);
                    const charEnd = chars[charLen - indexLastChange];
                    if (indexFirstChange >= len - indexLastChange || !charEnd) {
                        // The indexes of the destination text cross, it is that
                        // the end and the beginning are just. Certain
                        // characters should be removed and replce by the and
                        // of the needed textContent. If there is no ending
                        // change, every ending chars are false and will be
                        // removed and replace by the new ending text.
                        // Please note that you must keep the existing text
                        // nodes. And therefore remove the character in the
                        // text nodes present in the dom.
                        const charEnd = chars[charLen - indexLastChange + 1] || chars[charLen - 1];
                        indexLastChange = charLen;
                        textEnd = charEnd[1];
                        center = '';
                        last = textContent.slice(indexFirstChange);
                    }
                    else {
                        // The indexes, do not cross, so we will add the
                        // missing piece and remove the erroneous characters.
                        textEnd = charEnd[1];
                        last = textEnd.textContent.slice(charEnd[2]);
                        center = textContent.slice(indexFirstChange, len - indexLastChange);
                    }
                }
                else {
                    // If there is no start of change, this implies that only
                    // characters must be added.
                    const char = chars[indexFirstChange - 1];
                    textBegin = textEnd = char[1];
                    first = textBegin.textContent;
                    center = textContent.slice(indexFirstChange);
                    last = '';
                }
                // Search every text nodes between the begin and end of the
                // changes. This text nodes will be removed.
                const textsBetweenStartEnd = [];
                for (let index = indexFirstChange; index < indexLastChange; index++) {
                    const text = (_a = chars[index]) === null || _a === void 0 ? void 0 : _a[1];
                    if (text &&
                        text !== textBegin &&
                        text !== textEnd &&
                        !textsBetweenStartEnd.includes(text)) {
                        textsBetweenStartEnd.push(text);
                    }
                }
                // Update the dom with the minimum of mutations.
                if (textBegin === textEnd) {
                    if (first === '' && center === '' && last === '') {
                        textsBetweenStartEnd.push(textBegin);
                    }
                    else if (textBegin.textContent !== first + center + last) {
                        textBegin.textContent = first + center + last;
                    }
                }
                else {
                    if (first === '' && center === '') {
                        textsBetweenStartEnd.push(textBegin);
                    }
                    else if (textBegin.textContent !== first + center) {
                        textBegin.textContent = first + center;
                    }
                    if (last === '') {
                        textsBetweenStartEnd.push(textEnd);
                    }
                    else if (textEnd.textContent !== last) {
                        textEnd.textContent = last;
                    }
                }
                // Removes text nodes between the begin and end, and may be
                // remove an other text node, if it's replace by an empty string.
                for (const domNode of textsBetweenStartEnd) {
                    textNodes.splice(textNodes.indexOf(domNode), 1);
                    domNode.parentNode.removeChild(domNode);
                }
            }
        }
        else {
            textNodes = [document.createTextNode(textContent)];
        }
        return textNodes;
    }
    /**
     * Insert missing domNodes in this element.
     */
    _insertDomChildren(domNodes, parentNode, insertBefore) {
        for (const domNode of domNodes) {
            if (insertBefore) {
                if (insertBefore === domNode) {
                    insertBefore = insertBefore.nextSibling;
                }
                else {
                    parentNode.insertBefore(domNode, insertBefore);
                }
            }
            else {
                parentNode.appendChild(domNode);
            }
        }
    }
    _getAvailableElement(id) {
        const object = this._objects[id];
        const domObject = object.object;
        const tagName = domObject.tag.toUpperCase();
        const diff = this._diff[id];
        if (object.parentDomNode) {
            for (const domNode of object.parentDomNode.childNodes) {
                if (tagName === nodeName(domNode) && this.isAvailableNode(id, domNode)) {
                    return domNode;
                }
            }
        }
        if (diff) {
            for (const domNode of diff.dom) {
                if (tagName === nodeName(domNode) && this.isAvailableNode(id, domNode)) {
                    return domNode;
                }
            }
        }
    }
    _getAvailableTextNodes(id) {
        const object = this._objects[id];
        const diff = this._diff[id];
        let textNode;
        if (object.parentDomNode) {
            for (const domNode of object.parentDomNode.childNodes) {
                if (Dom_isTextNode(domNode) && this.isAvailableNode(id, domNode)) {
                    textNode = domNode;
                }
            }
        }
        if (!textNode && diff) {
            for (const domNode of diff.dom) {
                if (Dom_isTextNode(domNode) && this.isAvailableNode(id, domNode)) {
                    textNode = domNode;
                }
            }
        }
        if (textNode) {
            // Get all free text nodes.
            const textNodes = [textNode];
            let text = textNode;
            while (text.previousSibling &&
                Dom_isTextNode(text.previousSibling) &&
                this.isAvailableNode(id, text.previousSibling)) {
                text = text.previousSibling;
                textNodes.unshift(text);
            }
            text = textNode;
            while (text.nextSibling &&
                Dom_isTextNode(text.nextSibling) &&
                this.isAvailableNode(id, text.nextSibling)) {
                text = text.nextSibling;
                textNodes.push(text);
            }
            return textNodes;
        }
    }
    /**
     * Check if the domNode are already associate to an other domObject and
     * this object don't need to be redrawed. The additional checking for the
     * diff is't use to associate the domNodecreate by a split from the browser.
     * The browser can add the new domNode after or before the split.
     */
    isAvailableNode(id, domNode) {
        var _a;
        const linkedId = this._fromDom.get(domNode);
        if (!linkedId || linkedId === id) {
            return true;
        }
        if ((_a = this._diff[linkedId]) === null || _a === void 0 ? void 0 : _a.askCompleteRedrawing) {
            // The browser can add the new domNode after or before the split.
            // In this case, there is a change in both elements. In the case of
            // text it is important to keep the dom intact in order to guarantee
            // the operation of the spell checkers. It is also important to keep
            // order for the parents of these texts, but by doing this, we are
            // forced to reset the content, animations may be lost.
            this._diff[id].askCompleteRedrawing = true;
            return true;
        }
    }
    _getchildrenDomNodes(id) {
        const object = this._objects[id];
        const domNodes = [];
        const treatedObject = [];
        if (object.children) {
            for (const childId of object.children) {
                const child = this._objects[childId];
                if (child && !treatedObject.includes(childId)) {
                    treatedObject.push(childId);
                    let childDomNodes;
                    if (child.dom.length) {
                        childDomNodes = child.dom;
                    }
                    else {
                        childDomNodes = this._getchildrenDomNodes(childId);
                    }
                    for (const node of childDomNodes) {
                        if (!domNodes.includes(node)) {
                            domNodes.push(node);
                        }
                    }
                }
            }
        }
        return domNodes;
    }
}

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/LayoutContainerNode.ts

class LayoutContainerNode_LayoutContainer extends ContainerNode_ContainerNode {
    constructor() {
        super(...arguments);
        this.editable = false;
        this.breakable = false;
    }
}

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/DomLayoutEngine.ts










class DomLayoutEngine_DomLayoutEngine extends LayoutEngine_LayoutEngine {
    constructor() {
        super(...arguments);
        this._domReconciliationEngine = new DomReconciliationEngine_DomReconciliationEngine();
        // used only to develop and avoid wrong promise from commands
        this._currentlyRedrawing = false;
        this.renderingMap = {};
        this._markedForRedraw = new Set();
        this.locations = {};
        this.defaultRootComponent = {
            id: 'editor',
            async render() {
                const editor = new VElement_VElement({ htmlTag: 'JW-EDITOR' });
                editor.append(new ZoneNode_ZoneNode({ managedZones: ['main'] }));
                editor.append(new ZoneNode_ZoneNode({ managedZones: ['default'] }));
                return [editor];
            },
        };
    }
    //--------------------------------------------------------------------------
    // Lifecycle
    //--------------------------------------------------------------------------
    async start() {
        for (const componentId in this.locations) {
            this.renderingMap[componentId] = [];
            this.componentZones[componentId] = ['root'];
            if (!this.componentDefinitions[componentId]) {
                throw new Error('Layout component "' + componentId + '" not found.');
            }
        }
        if (!flat(Object.values(this.componentZones)).includes('root')) {
            this.componentDefinitions.editor = this.defaultRootComponent;
            this.componentZones.editor = ['root'];
        }
        for (const componentId in this.componentDefinitions) {
            this._prepareLayoutContainerAndLocation(this.componentDefinitions[componentId]);
        }
        await super.start();
    }
    async stop() {
        for (const componentId in this.componentDefinitions) {
            const location = this.locations[componentId];
            if (location) {
                const nodes = this.components[componentId];
                for (const node of nodes) {
                    const domNodes = this._domReconciliationEngine.toDom(node);
                    if (location[1] === 'replace') {
                        // Undo the replace that was done by the layout engine.
                        let first = domNodes && domNodes[0];
                        if (!first) {
                            first = this.renderingMap[componentId][0];
                        }
                        if (first && first.parentNode) {
                            first.parentNode.insertBefore(location[0], first);
                        }
                    }
                }
            }
        }
        this.renderingMap = {};
        this._markedForRedraw = new Set();
        this.location = null;
        this.locations = {};
        this._rendererCache = null;
        this._domReconciliationEngine.clear();
        return super.stop();
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return the VNode(s) corresponding to the given DOM Node.
     *
     * @param Node
     */
    getNodes(domNode) {
        return this._domReconciliationEngine.fromDom(domNode);
    }
    /**
     * Return the DOM Node(s) corresponding to the given VNode.
     *
     * @param node
     */
    getDomNodes(node) {
        return this._domReconciliationEngine.toDom(node);
    }
    async redraw(params) {
        if (this._currentlyRedrawing) {
            throw new Error('Double redraw detected');
        }
        this._currentlyRedrawing = true;
        return this._redraw(params)
            .then(() => {
            this._currentlyRedrawing = false;
        })
            .catch(error => {
            this._currentlyRedrawing = false;
            throw error;
        });
    }
    /**
     * Parse the dom selection into the description of a VSelection.
     *
     * @param selection
     * @param [direction]
     */
    parseSelection(selection) {
        const start = this._domReconciliationEngine.locate(selection.anchorNode, selection.anchorOffset);
        const end = this._domReconciliationEngine.locate(selection.focusNode, selection.focusOffset);
        const [startVNode, startPosition] = start;
        const [endVNode, endPosition] = end;
        let direction;
        if (selection instanceof Selection) {
            const domRange = selection.rangeCount && selection.getRangeAt(0);
            if (domRange.startContainer === selection.anchorNode &&
                domRange.startOffset === selection.anchorOffset) {
                direction = Direction.FORWARD;
            }
            else {
                direction = Direction.BACKWARD;
            }
        }
        else {
            direction = selection.direction;
        }
        return {
            anchorNode: startVNode,
            anchorPosition: startPosition,
            focusNode: endVNode,
            focusPosition: endPosition,
            direction: direction,
        };
    }
    markForRedraw(domNodes) {
        for (const domNode of domNodes) {
            this._markedForRedraw.add(domNode);
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    async _redraw(params) {
        const updatedNodes = [...this._getInvalidNodes(params)];
        const layout = this.editor.plugins.get(Renderer_Renderer);
        const engine = layout.engines['dom/object'];
        const cache = (this._rendererCache = await engine.render(updatedNodes, this._rendererCache));
        this._domReconciliationEngine.update(updatedNodes, cache.renderings, cache.locations, cache.renderingDependent, this._markedForRedraw);
        this._markedForRedraw = new Set();
        // Append in dom if needed.
        for (const componentId in this.locations) {
            const nodes = this.components[componentId];
            const needInsert = nodes.find(node => {
                const domNodes = this._domReconciliationEngine.toDom(node);
                return !domNodes.length || domNodes.some(node => !node.parentNode);
            });
            if (needInsert) {
                this._appendComponentInDom(componentId);
            }
        }
        this._renderSelection();
    }
    /**
     * Get the invalidated nodes in the rendering.
     * Clear the renderer in cache for this node or modifier. The cache
     * renderer is added only for performance at redrawing time. The
     * invalidation are automatically made from memory changes.
     */
    _getInvalidNodes(diff) {
        const cache = this._rendererCache;
        const remove = new Set();
        const update = new Set();
        const updatedModifiers = new Set();
        const updatedSiblings = new Set();
        const add = new Set();
        // Add new nodes for redrawing it.
        for (const object of diff.add) {
            if (object instanceof AbstractNode_AbstractNode) {
                add.add(object);
            }
            else if (object instanceof Modifier_Modifier) {
                updatedModifiers.add(object);
            }
        }
        for (const node of add) {
            if (!node.parent) {
                add.delete(node);
                remove.add(node);
                if (node.childVNodes) {
                    for (const child of node.descendants()) {
                        add.delete(node);
                        remove.add(child);
                    }
                }
            }
        }
        if (cache) {
            // Select the removed VNode and Modifiers.
            const allRemove = new Set(diff.remove);
            for (const object of diff.remove) {
                if (object instanceof AbstractNode_AbstractNode) {
                    remove.add(object);
                }
                else {
                    if (object instanceof Modifier_Modifier) {
                        updatedModifiers.add(object);
                    }
                    for (const [parent] of this.editor.memory.getParents(object)) {
                        if (parent instanceof AbstractNode_AbstractNode) {
                            update.add(parent);
                        }
                        else if (parent instanceof Modifier_Modifier) {
                            updatedModifiers.add(parent);
                        }
                    }
                }
            }
            const filterd = this._filterInRoot([...remove]);
            for (const node of filterd.remove) {
                update.delete(node);
                remove.add(node);
                if (node.childVNodes) {
                    for (const child of node.descendants()) {
                        remove.add(child);
                    }
                }
            }
            for (const node of filterd.keep) {
                update.add(node); // TODO: memory change to have real add and not add + move.
            }
            const needSiblings = new Set();
            // Filter to keep only update not added or removed nodes.
            const paramsUpdate = [];
            diff.update.filter(up => {
                const object = up[0];
                if (up[1] &&
                    object instanceof AbstractNode_AbstractNode &&
                    up[1].includes('parent') &&
                    (!object.parent || !object.id)) {
                    remove.add(object);
                    for (const child of object.descendants()) {
                        remove.add(child);
                    }
                }
                else if (!remove.has(object)) {
                    paramsUpdate.push(up);
                }
            });
            // Select the updated VNode and Modifiers and the VNode siblings.
            // From the parent, select the removed VNode siblings.
            for (const [object, changes] of paramsUpdate) {
                if (allRemove.has(object) ||
                    update.has(object) ||
                    updatedModifiers.has(object)) {
                    continue;
                }
                if (object instanceof AbstractNode_AbstractNode) {
                    update.add(object);
                    needSiblings.add(object);
                }
                else {
                    if (object instanceof Modifier_Modifier) {
                        updatedModifiers.add(object);
                    }
                    for (const [parent, parentProp] of this.editor.memory.getParents(object)) {
                        if (parent instanceof AbstractNode_AbstractNode) {
                            update.add(parent);
                            if (changes &&
                                parentProp[0][0] === 'childVNodes' &&
                                typeof changes[0] === 'number') {
                                // If change a children (add or remove) redraw the node and
                                // siblings.
                                const childVNodes = parent.childVNodes;
                                for (let i = 0; i < changes.length; i++) {
                                    const index = changes[i];
                                    const child = childVNodes[index];
                                    if (child) {
                                        if (!add.has(child)) {
                                            update.add(child);
                                        }
                                        if (changes[i - 1] !== index - 1) {
                                            const previous = child.previousSibling();
                                            if (previous &&
                                                !add.has(previous) &&
                                                !update.has(previous)) {
                                                updatedSiblings.add(previous);
                                            }
                                        }
                                        if (changes[i + 1] !== index + 1) {
                                            const next = child.nextSibling();
                                            if (next && !add.has(next) && !update.has(next)) {
                                                if (next)
                                                    updatedSiblings.add(next);
                                            }
                                        }
                                    }
                                    else {
                                        const children = parent.children();
                                        if (children.length) {
                                            const last = children[children.length - 1];
                                            if (last && !add.has(last) && !update.has(last)) {
                                                updatedSiblings.add(last);
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                needSiblings.add(parent);
                            }
                        }
                        else if (parent instanceof Modifier_Modifier) {
                            updatedModifiers.add(parent);
                        }
                    }
                }
            }
            // If any change invalidate the siblings.
            for (const node of needSiblings) {
                const next = node.nextSibling();
                if (next)
                    updatedSiblings.add(next);
                const previous = node.previousSibling();
                if (previous)
                    updatedSiblings.add(previous);
            }
            // Invalidate compatible renderer cache.
            for (const node of update) {
                cache.cachedCompatibleRenderer.delete(node);
            }
            for (const node of remove) {
                cache.cachedCompatibleRenderer.delete(node);
            }
            // Add removed nodes modifiers for invalidation.
            for (const node of remove) {
                if (node.modifiers) {
                    // If the node is created after this memory slice (undo),
                    // the node has no values, no id, no modifiers... But the
                    // modifiers is inside the list of removed objects.
                    node.modifiers.map(modifier => updatedModifiers.add(modifier));
                }
            }
            // Invalidate compatible renderer cache and modifier compare cache.
            for (const modifier of updatedModifiers) {
                cache.cachedCompatibleModifierRenderer.delete(modifier);
                const id = cache.cachedModifierId.get(modifier);
                if (id) {
                    const keys = cache.cachedIsSameAsModifierIds[id];
                    if (keys) {
                        for (const key in keys) {
                            delete cache.cachedIsSameAsModifier[key];
                        }
                        delete cache.cachedIsSameAsModifierIds[id];
                    }
                }
            }
            // Add the siblings to invalidate the sibling groups.
            for (const sibling of updatedSiblings) {
                update.add(sibling);
            }
            // Get all linked and dependent VNodes and Modifiers to invalidate cache.
            const treated = new Set();
            const nodesOrModifiers = [...update, ...remove, ...updatedModifiers];
            const treatedItem = new Set(nodesOrModifiers);
            for (const nodeOrModifier of nodesOrModifiers) {
                const linkedRenderings = cache.nodeDependent.get(nodeOrModifier);
                if (linkedRenderings) {
                    for (const link of linkedRenderings) {
                        if (!treated.has(link)) {
                            treated.add(link);
                            const from = cache.renderingDependent.get(link);
                            if (from) {
                                for (const n of from) {
                                    if (!treatedItem.has(n)) {
                                        // Add to invalid domObject origin nodes or modifiers.
                                        nodesOrModifiers.push(n);
                                        treatedItem.add(n);
                                    }
                                }
                            }
                        }
                    }
                }
                const linkedNodes = cache.linkedNodes.get(nodeOrModifier);
                if (linkedNodes) {
                    for (const node of linkedNodes) {
                        if (!treatedItem.has(node)) {
                            // Add to invalid linked nodes of linkes nodes.
                            nodesOrModifiers.push(node);
                            treatedItem.add(node);
                        }
                    }
                }
                if (nodeOrModifier instanceof AbstractNode_AbstractNode) {
                    update.add(nodeOrModifier);
                }
                else {
                    updatedModifiers.add(nodeOrModifier);
                }
            }
            // Remove all removed children from node to update.
            for (const node of remove) {
                update.delete(node);
            }
            // Invalidate VNode cache origin, location and linked.
            for (const node of [...update, ...remove]) {
                cache.renderingPromises.delete(node);
                const item = cache.renderings.get(node);
                if (item) {
                    const items = [item];
                    for (const item of items) {
                        cache.renderingDependent.delete(item);
                        cache.locations.delete(item);
                        if ('children' in item) {
                            for (const child of item.children) {
                                if (!(child instanceof AbstractNode_AbstractNode)) {
                                    items.push(child);
                                }
                            }
                        }
                    }
                }
                cache.renderings.delete(node);
                cache.nodeDependent.delete(node);
                cache.linkedNodes.delete(node);
            }
            // Invalidate Modifiers cache linked.
            for (const modifier of updatedModifiers) {
                cache.nodeDependent.delete(modifier);
            }
        }
        for (const node of add) {
            update.add(node);
        }
        // Render nodes.
        return update;
    }
    _filterInRoot(nodes) {
        const inRoot = new Set();
        const notRoot = new Set();
        const nodesInRoot = new Set();
        const nodesInNotRoot = new Set();
        for (const node of nodes) {
            const parents = [];
            let ancestor = node;
            while (ancestor && !notRoot.has(ancestor)) {
                if (ancestor === this.root || inRoot.has(ancestor)) {
                    // The VNode is in the domLayout.
                    nodesInRoot.add(node);
                    for (const parent of parents) {
                        inRoot.add(parent);
                    }
                    break;
                }
                parents.push(ancestor);
                ancestor = ancestor.parent;
                if (!ancestor || !ancestor.id) {
                    // A VNode without an id does not exist yet/anymore in the
                    // current memory slice.
                    // The VNode is not in the domLayout.
                    nodesInNotRoot.add(node);
                    for (const parent of parents) {
                        notRoot.add(parent);
                    }
                }
            }
        }
        return { keep: nodesInRoot, remove: nodesInNotRoot };
    }
    /**
     * Render the given VSelection as a DOM selection in the given target.
     *
     * @param selection
     * @param target
     */
    _renderSelection() {
        const selection = this.editor.selection;
        const domNodes = this._domReconciliationEngine.toDom(selection.anchor.parent);
        if (!domNodes.length) {
            document.getSelection().removeAllRanges();
            return;
        }
        if (selection.anchor.ancestors().pop() !== this.root ||
            selection.focus.ancestors().pop() !== this.root) {
            console.warn('Cannot render a selection that is outside the Layout.');
            document.getSelection().removeAllRanges();
        }
        const anchor = this._domReconciliationEngine.getLocations(selection.anchor);
        const focus = this._domReconciliationEngine.getLocations(selection.focus);
        const doc = anchor[0].ownerDocument;
        const domSelection = doc.getSelection();
        if (domSelection.anchorNode === anchor[0] &&
            domSelection.anchorOffset === anchor[1] &&
            domSelection.focusNode === focus[0] &&
            domSelection.focusOffset === focus[1]) {
            return;
        }
        const domRange = doc.createRange();
        if (selection.direction === Direction.FORWARD) {
            domRange.setStart(anchor[0], anchor[1]);
            domRange.collapse(true);
        }
        else {
            domRange.setEnd(anchor[0], anchor[1]);
            domRange.collapse(false);
        }
        domSelection.removeAllRanges();
        domSelection.addRange(domRange);
        domSelection.extend(focus[0], focus[1]);
    }
    _appendComponentInDom(id) {
        var _a;
        let [target, position] = this.locations[id];
        const nodes = this.renderingMap[id];
        const first = nodes.find(node => node.parentNode && node.ownerDocument.body.contains(node));
        if (first === null || first === void 0 ? void 0 : first.previousSibling) {
            target = first.previousSibling;
            position = 'after';
        }
        else if ((_a = first === null || first === void 0 ? void 0 : first.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode) {
            target = first.parentNode;
            position = 'prepend';
        }
        else {
            let previous = id;
            while ((previous = this._getPreviousComponentId(previous))) {
                const last = this.renderingMap[previous][this.renderingMap[previous].length - 1];
                if (last && last.ownerDocument.body.contains(last)) {
                    target = last;
                    position = 'after';
                }
            }
        }
        if (position === 'after' && !target.parentNode) {
            throw new Error('Impossible to render a component after an element with no parent.');
        }
        if (position === 'replace' && !target.parentNode) {
            throw new Error('Impossible to replace an element without any parent.');
        }
        const domNodes = [];
        for (const node of this.components[id]) {
            domNodes.push(...this._domReconciliationEngine.toDom(node));
        }
        if (!domNodes.length && this.locations[id][1] === 'replace') {
            throw new Error('Impossible to replace a element with an empty template.');
        }
        if (position === 'after') {
            if (target.nextSibling) {
                for (const domNode of domNodes) {
                    target.parentNode.insertBefore(domNode, target.nextSibling);
                }
            }
            else {
                for (const domNode of domNodes) {
                    target.parentNode.appendChild(domNode);
                }
            }
        }
        else if (position === 'prepend') {
            let item = target.firstChild;
            for (const domNode of domNodes) {
                if (!item) {
                    target.appendChild(domNode);
                }
                else if (domNode !== item) {
                    target.insertBefore(domNode, item);
                }
                else {
                    item = domNode.nextSibling;
                }
            }
        }
        else if (position === 'replace') {
            for (const domNode of domNodes) {
                target.parentNode.insertBefore(domNode, target);
            }
            target.parentNode.removeChild(target);
        }
        else {
            for (const domNode of domNodes) {
                target.appendChild(domNode);
            }
        }
        for (const node of this.renderingMap[id]) {
            if (node.parentNode && !domNodes.includes(node)) {
                node.parentNode.removeChild(node);
            }
        }
        this.renderingMap[id] = domNodes;
    }
    _getPreviousComponentId(id) {
        const [target, position] = this.locations[id];
        const locations = Object.values(this.locations);
        const componentIds = Object.keys(this.locations);
        const index = componentIds.indexOf(id);
        if (position === 'after') {
            for (let u = index - 1; u >= 0; u--) {
                const [otherTarget, otherPosition] = locations[u];
                if (target === otherTarget &&
                    (otherPosition === 'after' || otherPosition === 'replace')) {
                    return componentIds[u];
                }
            }
            for (let u = locations.length - 1; u > index; u--) {
                const [otherTarget, otherPosition] = locations[u];
                if (target === otherTarget && otherPosition === 'replace') {
                    return componentIds[u];
                }
            }
        }
        else if (position === 'replace') {
            for (let u = index - 1; u >= 0; u--) {
                const [otherTarget, otherPosition] = locations[u];
                if (target === otherTarget && otherPosition === 'replace') {
                    return componentIds[u];
                }
            }
        }
    }
    _prepareLayoutContainerAndLocation(componentDefinition) {
        const zone = this.componentZones[componentDefinition.id];
        if (zone === null || zone === void 0 ? void 0 : zone.includes('root')) {
            // automatically wrap the child into a layoutContainer to keep location of all nodes
            // when update the template and redraw
            this.componentDefinitions[componentDefinition.id] = {
                id: componentDefinition.id,
                async render(editor) {
                    const nodes = await componentDefinition.render(editor);
                    const layoutContainer = new LayoutContainerNode_LayoutContainer();
                    layoutContainer.append(...nodes);
                    return [layoutContainer];
                },
            };
            if (this.location) {
                if (!this.locations[componentDefinition.id]) {
                    this.locations[componentDefinition.id] = this.location;
                    this.renderingMap[componentDefinition.id] = [];
                }
            }
        }
    }
}
DomLayoutEngine_DomLayoutEngine.id = 'dom';

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/ZoneDomObjectRenderer.ts



class ZoneDomObjectRenderer_ZoneDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ZoneNode_ZoneNode;
    }
    async render(node, worker) {
        var _a;
        const children = node.children();
        const domObject = { children: [] };
        for (let index = 0, len = children.length; index < len; index++) {
            const child = children[index];
            if (!((_a = node.hidden) === null || _a === void 0 ? void 0 : _a[child.id])) {
                domObject.children.push(child);
            }
            worker.depends(child, node);
        }
        return domObject;
    }
}
ZoneDomObjectRenderer_ZoneDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/ZoneXmlDomParser.ts




class ZoneXmlDomParser_ZoneXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'T' && !!item.getAttribute('t-zone');
        };
    }
    async parse(item) {
        return [new ZoneNode_ZoneNode({ managedZones: [item.getAttribute('t-zone')] })];
    }
}
ZoneXmlDomParser_ZoneXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/LayoutContainerDomObjectRenderer.ts



class LayoutContainerDomObjectRenderer_LayoutContainerDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = LayoutContainerNode_LayoutContainer;
    }
    async render(node) {
        return {
            children: [...node.childVNodes],
        };
    }
}
LayoutContainerDomObjectRenderer_LayoutContainerDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/ActionableDomObjectRenderer.ts





class ActionableDomObjectRenderer_ActionableDomObjectRenderer extends NodeRenderer {
    constructor(engine) {
        super(engine);
        this.predicate = ActionableNode_ActionableNode;
        this.actionableNodes = new Map();
        this.engine.editor.dispatcher.registerCommandHook('@commit', this._updateActionables.bind(this));
    }
    async render(button, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    worker) {
        let clickHandler;
        let mousedownHandler;
        const objectButton = {
            tag: 'JW-BUTTON',
            attributes: {
                name: button.actionName,
            },
            handler: () => {
                if (button.commandId) {
                    this.engine.editor.execCommand(button.commandId, button.commandArgs);
                }
            },
            attach: (el) => {
                clickHandler = (ev) => {
                    ev.stopImmediatePropagation();
                    ev.stopPropagation();
                    ev.preventDefault();
                    objectButton.handler();
                };
                mousedownHandler = (ev) => {
                    ev.stopImmediatePropagation();
                    ev.stopPropagation();
                    ev.preventDefault();
                };
                el.addEventListener('click', clickHandler);
                el.addEventListener('mousedown', mousedownHandler);
                this.actionableNodes.set(button, el);
            },
            detach: (el) => {
                el.removeEventListener('click', clickHandler);
                el.removeEventListener('mousedown', mousedownHandler);
                this.actionableNodes.delete(button);
            },
        };
        const attributes = button.modifiers.find(Attributes_Attributes);
        const className = attributes === null || attributes === void 0 ? void 0 : attributes.get('class');
        if (className === null || className === void 0 ? void 0 : className.includes(' fa-')) {
            if (!attributes.get('title')) {
                objectButton.attributes.title = button.label;
            }
        }
        else {
            objectButton.children = [{ text: button.label }];
        }
        return objectButton;
    }
    /**
     * Update button rendering after the command if the value of selected or
     * enabled change.
     */
    _updateActionables() {
        const pluginConfig = this.engine.editor.plugins.get(DomLayout_DomLayout).configuration;
        const pressedActionablesClassName = pluginConfig.pressedActionablesClassName
            ? pluginConfig.pressedActionablesClassName
            : 'pressed';
        for (const [actionable, element] of this.actionableNodes) {
            const editor = this.engine.editor;
            const select = !!actionable.selected(editor);
            const enable = !!actionable.enabled(editor);
            const visible = !!actionable.visible(editor);
            const attrSelected = element.getAttribute('aria-pressed');
            if (select.toString() !== attrSelected) {
                element.setAttribute('aria-pressed', select.toString());
                if (select) {
                    element.classList.add(pressedActionablesClassName);
                }
                else {
                    element.classList.remove(pressedActionablesClassName);
                }
            }
            const domEnable = !element.getAttribute('disabled');
            if (enable !== domEnable) {
                if (enable) {
                    element.removeAttribute('disabled');
                }
                else {
                    element.setAttribute('disabled', 'true');
                }
            }
            const domVisible = element.style.display !== 'none';
            if (visible !== domVisible) {
                if (visible) {
                    element.style.display = 'inline-block';
                }
                else {
                    element.style.display = 'none';
                }
            }
        }
    }
}
ActionableDomObjectRenderer_ActionableDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-layout/src/ActionableGroupNode.ts

class ActionableGroupNode_ActionableGroupNode extends ContainerNode_ContainerNode {
    constructor(params) {
        super(params);
        this.groupName = params === null || params === void 0 ? void 0 : params.name;
    }
}

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/ActionableGroupDomObjectRenderer.ts



class ActionableGroupDomObjectRenderer_ActionableGroupDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ActionableGroupNode_ActionableGroupNode;
    }
    async render(group) {
        if (!group.descendants(node => !(node instanceof ActionableGroupNode_ActionableGroupNode) && node.tangible)
            .length) {
            return { children: [] };
        }
        else if (group.ancestor(ActionableGroupNode_ActionableGroupNode)) {
            return this._renderSelect(group);
        }
        else {
            return this._renderGroup(group);
        }
    }
    _renderSelect(group) {
        const objectSelect = {
            tag: 'SELECT',
            children: [{ tag: 'OPTION' }, ...group.children()],
        };
        return objectSelect;
    }
    _renderGroup(group) {
        const objectGroup = {
            tag: 'JW-GROUP',
            children: group.children(),
        };
        return objectGroup;
    }
}
ActionableGroupDomObjectRenderer_ActionableGroupDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-layout/src/LabelNode.ts

class LabelNode_LabelNode extends AtomicNode_AtomicNode {
    constructor(params) {
        super();
        this.label = params.label;
    }
}

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/ActionableGroupSelectItemDomObjectRenderer.ts








class ActionableGroupSelectItemDomObjectRenderer_ActionableGroupSelectItemDomObjectRenderer extends NodeRenderer {
    constructor(engine) {
        super(engine);
        this.predicate = (node) => node.ancestors(ActionableGroupNode_ActionableGroupNode).length >= 2;
        this.actionableNodes = new Map();
        this.engine.editor.dispatcher.registerCommandHook('@commit', this._updateActionables.bind(this));
    }
    async render(item, worker) {
        var _a;
        let domObject;
        if (item instanceof ActionableNode_ActionableNode) {
            let handler;
            const domObjectActionable = {
                tag: 'OPTION',
                attributes: {
                    value: item.actionName,
                },
                children: item.label ? [{ text: item.label }] : [],
                handler: () => {
                    if (item.commandId) {
                        this.engine.editor.execCommand(item.commandId, item.commandArgs);
                    }
                },
                attach: (el) => {
                    const select = el.closest('select') || el.parentElement;
                    handler = (ev) => {
                        const option = select.querySelector('option:checked');
                        if (option === el) {
                            ev.stopImmediatePropagation();
                            domObjectActionable.handler();
                        }
                    };
                    select.addEventListener('change', handler);
                    this.actionableNodes.set(item, el);
                },
                detach: (el) => {
                    const select = el.closest('select') || el.parentElement;
                    select.removeEventListener('change', handler);
                    this.actionableNodes.delete(item);
                },
            };
            domObject = domObjectActionable;
        }
        else if (item instanceof ActionableGroupNode_ActionableGroupNode) {
            if (item.ancestors(ActionableGroupNode_ActionableGroupNode).length <= 2) {
                const title = (_a = item.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.get('title');
                domObject = {
                    tag: 'OPTGROUP',
                    attributes: {
                        name: item.groupName || null,
                        label: title || null,
                    },
                    children: item.children(),
                };
            }
            else {
                domObject = {
                    children: item.children(),
                };
            }
        }
        else if (item instanceof SeparatorNode_SeparatorNode) {
            domObject = {
                tag: 'OPTION',
                attributes: {
                    role: 'separator',
                    disabled: 'true',
                },
            };
        }
        else if (item instanceof LabelNode_LabelNode) {
            domObject = {
                tag: 'OPTION',
                attributes: {
                    class: new Set(['label']),
                    disabled: 'true',
                },
                children: [{ text: item.label }],
            };
        }
        else if (item instanceof ZoneNode_ZoneNode) {
            domObject = await this.super.render(item, worker);
            if (!('tag' in domObject) || domObject.tag.toUpperCase() !== 'OPTION') {
                domObject = { children: item.children() };
            }
        }
        else {
            domObject = {
                tag: 'OPTION',
                children: [{ text: item.textContent }],
            };
        }
        return domObject;
    }
    /**
     * Update option rendering after the command if the value of selected or
     * enabled change.
     *
     * @param aactionable
     * @param element
     */
    _updateActionables() {
        for (const [aactionable, element] of this.actionableNodes) {
            const editor = this.engine.editor;
            const select = aactionable.selected(editor);
            const enable = aactionable.enabled(editor);
            const attrSelected = element.getAttribute('selected');
            if (select.toString() !== attrSelected) {
                if (select) {
                    element.setAttribute('selected', 'true');
                    element.closest('select').value = element.getAttribute('value');
                }
                else {
                    element.removeAttribute('selected');
                }
            }
            const domEnable = !element.getAttribute('disabled');
            if (enable !== domEnable) {
                if (enable) {
                    element.removeAttribute('disabled');
                }
                else {
                    element.setAttribute('disabled', 'true');
                }
            }
        }
    }
}
ActionableGroupSelectItemDomObjectRenderer_ActionableGroupSelectItemDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/LabelDomObjectRenderer.ts



class LabelDomObjectRenderer_LabelDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = LabelNode_LabelNode;
    }
    async render(label) {
        const objectLabel = {
            tag: 'SPAN',
            attributes: { class: new Set(['label']) },
            children: [{ text: label.label }],
        };
        return objectLabel;
    }
}
LabelDomObjectRenderer_LabelDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-toolbar/src/ToolbarNode.ts

class ToolbarNode_ToolbarNode extends ContainerNode_ContainerNode {
}

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/SeparatorDomObjectRenderer.ts




class SeparatorDomObjectRenderer_SeparatorDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = (node) => node instanceof SeparatorNode_SeparatorNode && !!node.ancestor(ToolbarNode_ToolbarNode);
    }
    async render() {
        const objectSeparator = {
            tag: 'JW-SEPARATOR',
            attributes: { role: 'separator' },
        };
        return objectSeparator;
    }
}
SeparatorDomObjectRenderer_SeparatorDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dom-layout/src/DomLayout.ts


















class DomLayout_DomLayout extends JWPlugin {
    constructor(editor, configuration) {
        super(editor, configuration);
        this.loadables = {
            renderers: [
                ZoneDomObjectRenderer_ZoneDomObjectRenderer,
                LayoutContainerDomObjectRenderer_LayoutContainerDomObjectRenderer,
                ActionableGroupSelectItemDomObjectRenderer_ActionableGroupSelectItemDomObjectRenderer,
                ActionableGroupDomObjectRenderer_ActionableGroupDomObjectRenderer,
                ActionableDomObjectRenderer_ActionableDomObjectRenderer,
                LabelDomObjectRenderer_LabelDomObjectRenderer,
                SeparatorDomObjectRenderer_SeparatorDomObjectRenderer,
            ],
            parsers: [ZoneXmlDomParser_ZoneXmlDomParser],
            layoutEngines: [],
            components: [],
        };
        this.loaders = {
            domLocations: this._loadComponentLocations,
        };
        this.commandHooks = {
            '@commit': this._redraw,
        };
        this.loadables.layoutEngines.push(DomLayoutEngine_DomLayoutEngine);
        this.processKeydown = this.processKeydown.bind(this);
    }
    async start() {
        const layout = this.dependencies.get(Layout_Layout);
        const domLayoutEngine = layout.engines.dom;
        for (const component of this.configuration.components || []) {
            domLayoutEngine.loadComponent(component);
        }
        const zones = {};
        for (const [id, zone] of this.configuration.componentZones || []) {
            zones[id] = zone;
        }
        domLayoutEngine.loadComponentZones(zones);
        this._loadComponentLocations(this.configuration.locations || []);
        domLayoutEngine.location = this.configuration.location;
        await domLayoutEngine.start();
        window.addEventListener('keydown', this.processKeydown, true);
    }
    async stop() {
        window.removeEventListener('keydown', this.processKeydown, true);
        const layout = this.dependencies.get(Layout_Layout);
        const domLayoutEngine = layout.engines.dom;
        await domLayoutEngine.stop();
        return super.stop();
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * KeyboardEvent listener to be added to the DOM that calls `execCommand` if
     * the keys pressed match one of the shortcut registered in the keymap.
     *
     * @param event
     */
    async processKeydown(event) {
        // If target == null we bypass the editable zone check.
        // This should only occurs when we receive an inferredKeydownEvent
        // created from an InputEvent send by a mobile device.
        if (event.target && !this.isInEditable(event.target)) {
            // Don't process keydown if the user is outside the current editor editable Zone.
            return;
        }
        const keymap = this.dependencies.get(Keymap_Keymap);
        const commands = keymap.match(event);
        const [command, context] = this.editor.contextManager.match(commands);
        if (command && command.commandId) {
            const params = Object.assign({ context }, command.commandArgs);
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            await this.editor.execCommand(command.commandId, params);
            return command.commandId;
        }
    }
    /**
     * Return true if the target node is inside Jabberwock's main editable Zone.
     *
     * @param target: Node
     */
    isInEditable(target) {
        const layout = this.dependencies.get(Layout_Layout);
        const domLayoutEngine = layout.engines.dom;
        target = this._getDeepestTarget(target);
        let nodes = domLayoutEngine.getNodes(target);
        while (!nodes.length && target) {
            if (target.previousSibling) {
                target = target.previousSibling;
            }
            else {
                target = target.parentNode;
            }
            nodes = domLayoutEngine.getNodes(target);
        }
        const node = nodes === null || nodes === void 0 ? void 0 : nodes.pop();
        // We cannot always expect a 'contentEditable' attribute on the main
        // ancestor. So we expect to find the main editor ZoneNode if we are in
        // the editable part of Jabberwock.
        return (node &&
            (isContentEditable(node) || this.editor.mode.is(node, RuleProperty.EDITABLE)) &&
            !!node.ancestor(node => node instanceof ZoneNode_ZoneNode && node.managedZones.includes('main')));
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    _loadComponentLocations(locations) {
        const layout = this.dependencies.get(Layout_Layout);
        const domLayoutEngine = layout.engines.dom;
        for (const [id, location] of locations) {
            domLayoutEngine.locations[id] = location;
        }
    }
    /**
     * Return the deepest target, based on the given target and the current
     * selection. The selection can be used only if it is indeed contained
     * within the target.
     *
     * @param target
     */
    _getDeepestTarget(target) {
        var _a;
        const selection = (_a = target.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection();
        const anchorNode = selection === null || selection === void 0 ? void 0 : selection.anchorNode;
        let node = anchorNode;
        let isAnchorDescendantOfTarget = false;
        while (node) {
            if (node === target) {
                isAnchorDescendantOfTarget = true;
                break;
            }
            node = node.parentElement;
        }
        return isAnchorDescendantOfTarget ? anchorNode : target;
    }
    async _redraw(params) {
        const layout = this.dependencies.get(Layout_Layout);
        const domLayoutEngine = layout.engines.dom;
        await domLayoutEngine.redraw(params.changesLocations);
    }
}
DomLayout_DomLayout.dependencies = [DomObjectRenderer_DomObjectRenderer, Parser_Parser, Renderer_Renderer, Layout_Layout, Keymap_Keymap];

// CONCATENATED MODULE: ./packages/plugin-dom-editable/src/MutationNormalizer.ts

class MutationNormalizer_MutationNormalizer {
    constructor(el = document.body) {
        this._observer = new MutationObserver(this._onMutation.bind(this));
        this._observer.observe(el, {
            characterDataOldValue: true,
            characterData: true,
            childList: true,
            subtree: true,
        });
    }
    start() {
        this._listen = true;
        this._mutations = [];
    }
    /**
     * Extract a mapping of the separate characters, their corresponding text
     * nodes and their offsets in said nodes from the given node's subtree.
     *
     * @private
     * @param charMutations
     * @returns { previous, current }
     */
    getCharactersMapping() {
        const before = new Set();
        const add = new Set();
        const current = new Set();
        const textMutations = [];
        // Gather all modified nodes to notify the listener.
        function getSelfAndAllChildren(target) {
            const texts = [target];
            target.childNodes.forEach(target => {
                texts.push(...getSelfAndAllChildren(target));
            });
            return texts;
        }
        function isTextNode(target) {
            return target.nodeType === Node.TEXT_NODE || nodeName(target) === 'BR';
        }
        this._mutations.forEach(record => {
            const targetMutation = record.target;
            const targetIsAdded = add.has(targetMutation);
            if (!targetIsAdded) {
                before.add(targetMutation);
            }
            if (record.type === 'characterData') {
                current.add(targetMutation);
                textMutations.push({
                    target: targetMutation,
                    old: record.oldValue.replace(/\u00A0/g, ' '),
                    current: targetMutation.textContent.replace(/\u00A0/g, ' '),
                });
            }
            else {
                record.addedNodes.forEach(node => {
                    getSelfAndAllChildren(node).forEach(child => {
                        if (!before.has(child)) {
                            add.add(child);
                        }
                        current.add(child);
                        if (!isTextNode(child)) {
                            return;
                        }
                        textMutations.push({
                            target: child,
                            old: '',
                            current: child.nodeType === Node.TEXT_NODE
                                ? child.textContent.replace(/\u00A0/g, ' ')
                                : '\n',
                        });
                    });
                });
                record.removedNodes.forEach(node => {
                    getSelfAndAllChildren(node).forEach(child => {
                        if (current.has(child)) {
                            current.delete(child);
                        }
                        if (targetIsAdded) {
                            add.add(child);
                        }
                        if (!add.has(child)) {
                            before.add(child);
                        }
                        if (!isTextNode(child)) {
                            return;
                        }
                        textMutations.push({
                            target: child,
                            old: child.nodeType === Node.TEXT_NODE
                                ? child.textContent.replace(/\u00A0/g, ' ')
                                : '\n',
                            current: '',
                        });
                    });
                });
            }
        });
        const already = new Map();
        const charMutations = [];
        textMutations.forEach(textMutation => {
            const target = textMutation.target;
            let mutation = already.get(target);
            if (mutation) {
                if (current.has(target) && !mutation.current.length) {
                    mutation.current = textMutation.current;
                }
                return;
            }
            if (current.has(target)) {
                mutation = {
                    target: target,
                    old: before.has(target) ? textMutation.old : '',
                    current: textMutation.current,
                };
                charMutations.push(mutation);
            }
            else if (before.has(target)) {
                mutation = {
                    target: target,
                    old: textMutation.old,
                    current: '',
                };
                charMutations.push(mutation);
            }
            already.set(target, mutation);
        });
        const currentLinked = this._getCharLinked(charMutations, 'current');
        const previousLinked = this._getCharLinked(charMutations, 'old');
        const oldText = previousLinked.chars;
        const currentText = currentLinked.chars;
        if (oldText === currentText) {
            return {
                index: -1,
                insert: '',
                remove: '',
                previous: previousLinked,
                current: currentLinked,
            };
        }
        const changePosition = this._changedOffset(oldText, currentText);
        const minLength = Math.min(oldText.length, currentText.length);
        let insertByChange;
        const unknownPosition = changePosition.left > minLength - changePosition.right;
        if (unknownPosition) {
            const maxLength = Math.max(oldText.length, currentText.length);
            const len = maxLength - minLength;
            insertByChange = currentText.slice(currentText.length - changePosition.right);
            for (let k = 0; k + len < minLength; k++) {
                if (insertByChange[k - 1] === ' ') {
                    insertByChange = insertByChange.slice(k);
                    break;
                }
            }
            insertByChange = insertByChange.slice(0, len);
            const removeByChange = oldText.slice(oldText.length - changePosition.right - len, oldText.length - changePosition.right);
            return {
                index: -1,
                insert: insertByChange,
                remove: removeByChange,
                previous: previousLinked,
                current: currentLinked,
            };
        }
        else {
            insertByChange = currentText.slice(changePosition.left, currentText.length - changePosition.right);
        }
        let fineChangePosition;
        let insertedWordAnalysed;
        if (textMutations.length > 1) {
            let alreadyFound = false;
            for (let k = textMutations.length - 1; k >= 0; k--) {
                const charMutation = textMutations[k];
                if (charMutation.old.length >= charMutation.current.length) {
                    continue;
                }
                let currentChange;
                if (charMutation.old !== '') {
                    if (alreadyFound) {
                        continue;
                    }
                    const oldTextMutation = charMutation.old;
                    const currentTextMutation = charMutation.current;
                    const resMutation = this._changedOffset(oldTextMutation, currentTextMutation);
                    currentChange = currentTextMutation.slice(resMutation.left, currentTextMutation.length - resMutation.right);
                }
                else if (charMutation.current === currentText) {
                    continue;
                }
                else {
                    currentChange = charMutation.current;
                }
                const changeIndex = currentChange.indexOf(insertByChange);
                if (changeIndex === -1) {
                    continue;
                }
                const indexStart = currentText.indexOf(currentChange);
                const indexEnd = indexStart + currentChange.length;
                const rangeChangeStart = changePosition.left - changeIndex;
                const rangeChangeEnd = currentText.length - changePosition.right;
                if ((rangeChangeStart >= indexStart && rangeChangeStart < indexEnd) ||
                    (rangeChangeEnd > indexStart && rangeChangeEnd <= indexEnd) ||
                    (rangeChangeEnd >= indexEnd && rangeChangeStart <= indexStart)) {
                    fineChangePosition = {
                        left: indexStart,
                        right: currentText.length - indexEnd,
                    };
                    insertedWordAnalysed = currentChange;
                    alreadyFound = true;
                    if (charMutation.old === '') {
                        break;
                    }
                }
            }
        }
        if (typeof insertedWordAnalysed === 'undefined') {
            insertedWordAnalysed = insertByChange;
            let beforeIndex = insertedWordAnalysed.indexOf(insertByChange);
            if (insertByChange === '') {
                beforeIndex = insertedWordAnalysed.length;
            }
            else {
                beforeIndex = 0;
            }
            fineChangePosition = {
                left: changePosition.left - beforeIndex,
                right: changePosition.right,
            };
        }
        const removedWordAnalysed = oldText.slice(fineChangePosition.left, oldText.length - fineChangePosition.right);
        return {
            index: fineChangePosition.left,
            insert: insertedWordAnalysed,
            remove: removedWordAnalysed,
            previous: previousLinked,
            current: currentLinked,
        };
    }
    getMutatedElements() {
        const elements = new Set();
        this._mutations.forEach(MutationRecord => {
            if (MutationRecord.type === 'characterData') {
                elements.add(MutationRecord.target);
            }
            else {
                MutationRecord.addedNodes.forEach(target => elements.add(target));
                MutationRecord.removedNodes.forEach(target => elements.add(target));
            }
        });
        return elements;
    }
    stop() {
        this._listen = false;
    }
    /**
     * Called when destroy the mutation normalizer.
     * Remove all added handlers.
     *
     */
    destroy() {
        this._observer.disconnect();
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    _getCharLinked(charMutations, type) {
        const mapNodeValue = new WeakMap();
        const obj = {
            chars: '',
            nodes: [],
            offsets: [],
        };
        charMutations.forEach(charMutation => {
            mapNodeValue.set(charMutation.target, charMutation[type]);
            const len = charMutation[type].length;
            if (obj.nodes.length) {
                const charParented = new Set();
                let node = charMutation.target;
                while (node &&
                    (!(node instanceof Element) || !node.getAttribute('contentEditable'))) {
                    charParented.add(node);
                    node = node.parentNode;
                }
                let first = obj.nodes[0];
                while (first &&
                    (!(first instanceof Element) || !first.getAttribute('contentEditable'))) {
                    if (charParented.has(first.previousSibling)) {
                        obj.chars = charMutation[type] + obj.chars;
                        obj.nodes.unshift(...new Array(len).fill(charMutation.target));
                        obj.offsets.unshift(...Array(len).keys());
                        return;
                    }
                    first = first.parentNode;
                }
            }
            obj.chars += charMutation[type];
            obj.nodes.push(...new Array(len).fill(charMutation.target));
            obj.offsets.push(...Array(len).keys());
        });
        obj.chars = obj.chars.replace(/\u00A0/g, ' ');
        return obj;
    }
    _changedOffset(old, current) {
        // In the optimal case where both the range is correctly placed and the
        // data property of the composition event is correctly set, the above
        // analysis is capable of finding the precise text that was inserted.
        // However, if any of these two conditions are not met, the results
        // might be spectacularly wrong. For example, spell checking suggestions
        // on MacOS are displayed while hovering the mispelled word, regardless
        // of the current position of the range, and the correction does not
        // trigger an update of the range position either after correcting.
        // Example (`|` represents the text cursor):
        //   Previous content: 'My friend Christofe was here.|'
        //   Current content:  'My friend Christophe Matthieu was here.|'
        //   Actual text inserted by the keyboard: 'Christophe Matthieu'
        //   Result if data is set to 'Christophe' (length: 10): 'e was here'
        //   Result if data is not set (regardless of the range): ''
        //
        // Because the first analysis might not be enough in some cases, a
        // second analysis must be performed. This analysis aims at precisely
        // identifying the offset of the actual change in the text by comparing
        // the previous content with the current one from left to right to find
        // the start of the change and from right to left to find its end.
        // Example (`|` represents the text cursor):
        //   Previous content: 'My friend Christofe| was here.'
        //   Current content:  'My friend Christophe Matthieu| was here.'
        //   Observed change:  'My friend Christo[fe => phe Matthieu] was here.'
        //   Change offsets in the current content: {left: 17, right: 29}
        const oldText = old;
        const currentText = current;
        const maxLength = Math.max(oldText.length, currentText.length);
        let left = 0;
        for (; left < maxLength; left++) {
            if (oldText[left] !== currentText[left]) {
                break;
            }
        }
        let right = 0;
        for (; right < maxLength; right++) {
            if (oldText[oldText.length - 1 - right] !== currentText[currentText.length - 1 - right]) {
                break;
            }
        }
        return { left, right };
    }
    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
    _onMutation(mutationsList) {
        if (this._listen) {
            // we push the mutation because some browser (e.g. safari) separate mutations with
            // microtask.
            this._mutations.push(...mutationsList);
        }
    }
}

// CONCATENATED MODULE: ./packages/utils/src/polyfill.ts


function elementFromPoint(x, y, root = document) {
    let element = root.elementFromPoint(x, y);
    if (element) {
        root = element.ownerDocument;
        while (element.shadowRoot) {
            root = element.shadowRoot;
            element = root.elementFromPoint(x, y);
            if (element.shadowRoot === root) {
                if (root.firstElementChild) {
                    element = root.lastElementChild;
                    if (element.getBoundingClientRect().x > x) {
                        element = root.firstElementChild;
                    }
                }
                else {
                    break;
                }
            }
        }
        return element;
    }
}
function caretPositionFromPoint(x, y, root = document) {
    if ((!x && x !== 0) || (!y && y !== 0))
        return;
    // There is no cross-browser function for this, but the three functions below
    // cover all modern browsers as well as the shadow DOM.
    let caretPosition;
    const element = elementFromPoint(x, y, root);
    if (!element) {
        return;
    }
    root = getDocument(element);
    if (root.caretPositionFromPoint) {
        caretPosition = root.caretPositionFromPoint(x, y);
    }
    else if (root instanceof ShadowRoot) {
        // Find the nearest node leaf or char in leaf.
        const position = caretPositionFromPointInShadowDom(x, y, element);
        if (position) {
            caretPosition = {
                offsetNode: position.node,
                offset: position.offset,
            };
        }
    }
    else {
        const caretRange = root.caretRangeFromPoint(x, y);
        caretPosition = caretRange && {
            offsetNode: caretRange.startContainer,
            offset: caretRange.startOffset,
        };
    }
    if (caretPosition) {
        const [offsetNode, offset] = targetDeepest(caretPosition.offsetNode, caretPosition.offset);
        return { offsetNode, offset };
    }
}
function caretPositionFromPointInShadowDom(x, y, element) {
    const range = document.createRange();
    let distX = Infinity;
    let distY = Infinity;
    let node;
    let offset;
    const leafs = [];
    const elements = [element];
    while (elements.length) {
        const element = elements.shift();
        if (element.childNodes.length) {
            elements.push(...element.childNodes);
        }
        else {
            leafs.push(element);
        }
    }
    // Find the nearest node leaf.
    for (const leaf of leafs) {
        let box;
        if (leaf instanceof Element) {
            box = leaf.getBoundingClientRect();
        }
        else {
            range.setStart(leaf, 0);
            range.setEnd(leaf, leaf.textContent.length);
            box = range.getBoundingClientRect();
        }
        if (box.y + box.height < y) {
            continue;
        }
        let currentOffset = 0;
        let newDistY;
        if (box.y <= y && box.y + box.height >= y) {
            newDistY = 0;
            if (leaf.nodeType === Node.TEXT_NODE) {
                currentOffset = getNearestCharOffset(x, y, leaf);
                range.setStart(leaf, currentOffset);
                range.setEnd(leaf, currentOffset);
                box = range.getBoundingClientRect();
            }
        }
        else {
            newDistY = Math.abs(box.y + box.height / 2 - y);
        }
        let newDistX;
        if (box.x <= x && box.x + box.width >= x) {
            newDistX = 0;
        }
        else {
            newDistX = Math.abs(box.x + box.width / 2 - x);
        }
        if (newDistY < distY) {
            distY = newDistY;
            distX = newDistX;
            node = leaf;
            offset = currentOffset;
        }
        else if (newDistY === distY &&
            ((newDistY === 0 && newDistX <= distX) || (newDistY !== 0 && newDistX > distX))) {
            distY = newDistY;
            distX = newDistX;
            node = leaf;
            offset = currentOffset;
        }
        if (distX === 0 && distY === 0) {
            break;
        }
    }
    return node && { node, offset };
}
function getNearestCharOffset(x, y, text) {
    // Search with a pseudo dichotomic for performance.
    const range = document.createRange();
    const posToTest = [[0, text.textContent.length]];
    const verticalMatches = [];
    while (posToTest.length) {
        const pos = posToTest.pop();
        range.setStart(text, pos[0]);
        range.setEnd(text, pos[1]);
        const box = range.getBoundingClientRect();
        if (box.y <= y && box.y + box.height >= y) {
            if (box.x <= x && box.x + box.width >= x) {
                if (pos[1] - pos[0] <= 1) {
                    return box.x + box.width / 2 <= x ? pos[1] : pos[0];
                }
                const alf = Math.floor((pos[0] + pos[1]) / 2);
                posToTest.push([pos[0], alf], [alf, pos[1]]);
            }
            else {
                verticalMatches.push(pos);
            }
        }
    }
    // Did not found the char, eg: user click on left above the container like
    // the browser we get the nearest char at the same cursor of the pointer.
    let dist = Infinity;
    let offset = 0;
    for (const pos of verticalMatches.reverse()) {
        for (let i = pos[0]; i < pos[1]; i++) {
            range.setStart(text, i);
            range.setEnd(text, i + 1);
            const box = range.getBoundingClientRect();
            const dx = box.x + box.width / 2;
            const dy = box.y + box.height / 2;
            const delta = Math.pow(dx - x, 2) + Math.pow(dy - y, 4);
            if (delta <= dist) {
                dist = delta;
                offset = i + (dx < x ? 1 : 0);
            }
        }
    }
    return offset;
}

// CONCATENATED MODULE: ./packages/plugin-dom-editable/src/EventNormalizer.ts





const navigationKey = new Set([
    'ArrowUp',
    'ArrowDown',
    'ArrowLeft',
    'ArrowRight',
    'PageUp',
    'PageDown',
    'End',
    'Home',
]);
const inputTypeCommands = new Set([
    'historyUndo',
    'historyRedo',
    'formatBold',
    'formatItalic',
    'formatUnderline',
    'formatStrikeThrough',
    'formatSuperscript',
    'formatSubscript',
    'formatJustifyFull',
    'formatJustifyCenter',
    'formatJustifyRight',
    'formatJustifyLeft',
    'formatIndent',
    'formatOutdent',
    'formatRemove',
    'formatSetBlockTextDirection',
    'formatSetInlineTextDirection',
    'formatBackColor',
    'formatFontColor',
    'formatFontName',
]);
/*
 * Regexp to test if a character is within an alphabet known by us.
 *
 * Note: Not all alphabets are taken into consideration and this RegExp is subject to be completed
 *       as more alphabets will be covered.
 *
 * Unicode range source:
 * - wikipedia
 * - google translate
 * - https://jrgraphix.net/r/Unicode/
 *
 * Tool to generate RegExp range:
 * - https://apps.timwhitlock.info/js/regex
 *
 * The strategy is to separate any word by selecting subsequent characters of a common alphabet.
 */
const alphabetsContainingSpaces = new RegExp('(' +
    [
        '[а-яА-ЯЀ-ӿԀ-ԯ]+',
        '[Ͱ-Ͼἀ-῾]+',
        '[\u0530-\u058F]+',
        '[\u0600-۾ݐ-ݾ\u08a0-\u08fe]+',
        '[\u0900-\u0DFF]+',
        '[a-zA-Z]+',
        '[a-zA-ZÀ-ÿ]+',
        '[a-zA-ZĀ-ſ]+',
        '[a-zA-Zƀ-ɏ]+',
    ].join('|') +
    ')$');
/**
 * These javascript event types might, in case of safari or spell-checking
 * keyboard, trigger dom events in multiple javascript stacks. They will require
 * to observe events during two ticks rather than after a single tick.
 */
const MultiStackEventTypes = ['input', 'compositionend', 'selectAll'];
/**
 * Create a promise that resolve once a timeout finish or when calling
 * `executeAndClear`.
 */
class Timeout {
    constructor(fn, interval = 0) {
        this.fn = fn;
        this.pending = true;
        this.promise = new Promise((resolve) => {
            this._resolve = resolve;
            this.id = window.setTimeout(() => {
                this.pending = false;
                resolve(fn());
            }, interval);
        });
    }
    fire(result) {
        clearTimeout(this.id);
        this.pending = false;
        if (result) {
            this._resolve(result);
        }
        else {
            this._resolve(this.fn());
        }
    }
}
/**
 * ## The problems the normalizer solve
 * Browser and virtual keyboards on mobile does not implement properly the w3c
 * contenteditable specification and are inconsistent.
 *
 * ## Goal of the normalizer
 * 1. Hook any change that happend in an element called the `editable`.
 * 2. Trigger the same event for the same action accross all browsers and
 *    devices.
 *
 * ## Strategy
 * Hook all javascript events that modify the `editable` element. Then, trigger
 * normalized events.
 *
 * ## How to use this normalizer?
 * 1. Javascript Events occurs
 * 2. Normalize javascript one or more `Event` to one or more
 *    `NormalizedAction`.
 * 3. Update our `VDocument` in regard of triggered normalized actions.
 * 4. Render what changed in the `VDocument` HTML in the `editable`.
 *
 * The normalizer does not preventDefault most of the change in the editable
 * happen (the exception for "paste" and "drop" javascript event).
 *
 *
 * ## Handeling javascript events
 * A javascript event is almost never prevented and almost always alter the
 * editable in the DOM.
 *
 * The reason that we do not prevent default is because we need more
 * informations. The information modified in the dom (by observing observing
 * mutations).
 *
 * There is an exception for the event 'paste' and 'drop'.
 *
 * The reason to preventDefault 'paste' is because most of the time, browsers
 * paste content that need to be cleaned. For that reason we prevent it from
 * being inserted in the editable element but the informations can be found in
 * the triggered normalized events actions.
 *
 * The reason to preventDefault 'drop' is because some browsers change page when
 * dropping an image or an url that comes from the address bar (e.g. chrome).
 *
 * ## Supported browser and virtual keyboard
 * - Mac
 *   - Chrome
 *   - Firefox
 *   - Edge
 *   - Safari
 * - Windows
 *   - Chrome
 *   - Firefox
 *   - Edge
 *   - Safari
 * - Linux
 *   - Chrome
 *   - Firefox
 * - Android
 *   - Chrome
 *   - Firefox
 *   - Google keyboard
 *   - Swift keyboard
 * - IOS
 *   - Safari
 *   - Chrome
 *   - Firefox
 */
class EventNormalizer_EventNormalizer {
    /**
     *
     * @param _isInEditable Callback to check if the node is in editable.
     * @param _triggerEventBatch Callback to trigger for each user action.
     */
    constructor(_isInEditable, _triggerEventBatch, root = document) {
        this._isInEditable = _isInEditable;
        this._triggerEventBatch = _triggerEventBatch;
        this.root = root;
        /**
         * Event listeners that are bound in the DOM by the normalizer on creation
         * and unbound on destroy.
         */
        this._eventListeners = [];
        /**
         * Cache the state of modifiers keys on each keystrokes.
         */
        this._modifierKeys = {
            ctrlKey: false,
            altKey: false,
            metaKey: false,
            shiftKey: false,
        };
        /**
         * Map of the shadow dom event normalizer.
         * If an event is triggered inside a shadow dom, we instanciate a new
         * EventNormalizer in the shadow dom.
         */
        this._shadowNormalizers = new Map();
        this._shadowNormalizers.set(root, this);
        this.initNextObservation();
        this._bindEventInEditable(root, 'compositionstart', this._registerEvent);
        this._bindEventInEditable(root, 'compositionupdate', this._registerEvent);
        this._bindEventInEditable(root, 'compositionend', this._registerEvent);
        this._bindEventInEditable(root, 'beforeinput', this._registerEvent);
        this._bindEventInEditable(root, 'input', this._registerEvent);
        this._bindEvent(root.ownerDocument || root, 'selectionchange', this._onSelectionChange);
        this._bindEventInEditable(root, 'contextmenu', this._onContextMenu);
        this._bindEvent(root, 'mousedown', this._onPointerDown);
        this._bindEvent(root, 'touchstart', this._onPointerDown);
        this._bindEvent(root, 'load-iframe', this._onEventEnableNormalizer);
        this._bindEvent(root, 'mousedown', this._onEventEnableNormalizer);
        this._bindEvent(root, 'touchstart', this._onEventEnableNormalizer);
        this._bindEvent(root, 'mouseup', this._onPointerUp);
        this._bindEvent(root, 'touchend', this._onPointerUp);
        this._bindEventInEditable(root, 'keydown', this._onKeyDownOrKeyPress);
        this._bindEventInEditable(root, 'keypress', this._onKeyDownOrKeyPress);
        this._bindEvent(root, 'onkeyup', this._updateModifiersKeys);
        this._bindEventInEditable(root, 'cut', this._onClipboard);
        this._bindEventInEditable(root, 'paste', this._onClipboard);
        this._bindEventInEditable(root, 'dragstart', this._onDragStart);
        this._bindEventInEditable(root, 'drop', this._onDrop);
        this._mutationNormalizer = new MutationNormalizer_MutationNormalizer(root instanceof Document ? root.body : root.lastElementChild);
        // Create EventNormalizer for all already loaded iframes.
        for (const iframe of root.querySelectorAll('iframe')) {
            this._enableNormalizer(iframe);
        }
    }
    /**
     * Called when destroy the event normalizer.
     * Remove all added handlers.
     *
     */
    destroy() {
        this._mutationNormalizer.destroy();
        this._unbindEvents();
        this._shadowNormalizers.forEach(eventNormalizer => eventNormalizer !== this && eventNormalizer.destroy());
        this._triggerEventBatch = null;
        this._isInEditable = null;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Bind the occurence of given even type on the given target element to the
     * given listener function. See _unbindEvents to unbind all events bound by
     * calling this function.
     *
     * @param target element on which to listen for events
     * @param type of the event to listen
     * @param listener to call when the even occurs on the target
     */
    _bindEvent(target, type, listener) {
        const boundListener = (ev) => {
            if ('target' in ev) {
                const doc = ev.target.ownerDocument;
                if (doc !== this.root && doc !== this.root.ownerDocument) {
                    return;
                }
            }
            listener.call(this, ev);
        };
        this._eventListeners.push({
            target: target,
            type: type,
            listener: boundListener,
        });
        target.addEventListener(type, boundListener, true);
    }
    /**
     * Filter event from editable.
     *
     * @see _bindEvent
     *
     * @param target element on which to listen for events
     * @param type of the event to listen
     * @param listener to call when the even occurs on the target
     */
    _bindEventInEditable(target, type, listener) {
        const boundListener = (ev) => {
            let eventTarget = 'target' in ev && ev.target;
            if (eventTarget instanceof Element &&
                (eventTarget.shadowRoot || nodeName(eventTarget) === 'IFRAME')) {
                this._enableNormalizer(eventTarget);
            }
            else {
                if (eventTarget && ev.constructor.name === 'MouseEvent') {
                    eventTarget = this._getEventTarget(ev);
                }
                else if (eventTarget && ev.constructor.name === 'TouchEvent') {
                    eventTarget = this._getEventTarget(ev);
                }
                else {
                    eventTarget = eventTarget === null || eventTarget === void 0 ? void 0 : eventTarget.ownerDocument.getSelection().focusNode;
                }
                if (eventTarget && this._isInEditable(eventTarget)) {
                    listener.call(this, ev);
                }
            }
        };
        this._bindEvent(target, type, boundListener);
    }
    /**
     * Unbind all events bound by calls to _bindEvent.
     *
     */
    _unbindEvents() {
        this._eventListeners.forEach(({ target, type, listener }) => {
            target.removeEventListener(type, listener, true);
        });
    }
    /**
     * Register given event on the this.currentStackObservation._events queue.
     * If the queue is not yet initialized or has been cleared prior to this
     * call, re-initialize it. After a tick (setTimeout 0ms) the
     * '_processEvents' method is called. All events that happened during the
     * tick are read from the queue and the analysis tries to extract the
     * actions desired by the user such as insert, delete, backspace, spell
     * checking, special characters, etc.
     *
     * @see _processEvents
     */
    _registerEvent(ev) {
        var _a, _b, _c;
        // See comment on `_keyboardSelectionTimeout`.
        if ((_a = this._keyboardSelectionTimeout) === null || _a === void 0 ? void 0 : _a.pending) {
            this._keyboardSelectionTimeout.fire();
        }
        // See comment on `_pointerSelectionTimeout`.
        if ((_b = this._pointerSelectionTimeout) === null || _b === void 0 ? void 0 : _b.pending) {
            this._pointerSelectionTimeout.fire();
        }
        const isNavigationEvent = ev instanceof KeyboardEvent && ev.type === 'keydown' && navigationKey.has(ev.key);
        if (isNavigationEvent) {
            // Manually triggering the processing of the current stack at this
            // point forces the rendering in the DOM of the result of the
            // observed events. This ensures that the new selection that is
            // eventually going to be set by the browser actually targets nodes
            // that are properly recognized in our abstration, which would not
            // be the case otherwise. See comment on `_stackTimeout`.
            if ((_c = this._stackTimeout) === null || _c === void 0 ? void 0 : _c.pending) {
                this._stackTimeout.fire();
            }
            // TODO: no rendering in editable can happen before the analysis of
            // the selection. There should be a mechanism here that can be used
            // by the normalizer to block the rendering until this resolves.
            const currentDomSelection = this._getSelection();
            this._keyboardSelectionTimeout = new Timeout(async () => {
                const newDomSelection = this._getSelection();
                const collapsed = newDomSelection.anchorNode === newDomSelection.focusNode &&
                    newDomSelection.anchorOffset === newDomSelection.focusOffset;
                let domSelection;
                if (collapsed && !this._isInEditable(newDomSelection.anchorNode)) {
                    // Prevent a collapsed selection outside the editable
                    // context: keep the current selection.
                    domSelection = currentDomSelection;
                }
                else {
                    domSelection = newDomSelection;
                }
                const setSelectionAction = {
                    type: 'setSelection',
                    domSelection: domSelection,
                };
                return { actions: [setSelectionAction], mutatedElements: new Set([]) };
            });
            this._triggerEventBatch(this._keyboardSelectionTimeout.promise);
            this.initNextObservation();
        }
        else {
            if (this.currentStackObservation._events.length === 0) {
                // The queue is not initialized or has been reset, so this is a
                // new user action. Re-initialize the queue such that the
                // analysis is not polluted by previous observations.
                // this.initNextObservation();
                const stack = this.currentStackObservation;
                // Start observing mutations.
                this._mutationNormalizer.start();
                // All events of this tick will be processed in the next one.
                this._stackTimeout = new Timeout(() => {
                    return this._processEvents(stack);
                });
                this._triggerEventBatch(this._stackTimeout.promise);
            }
            // It is possible to have multiples keys that must trigger multiples
            // times that are being push in the same tick. To be able to handle
            // this case in `_processEvents`, we aggregate the informations in
            // `_multiKeyStack`.
            if (['keydown', 'keypress', 'input'].includes(ev.type)) {
                // In the multiple key case, a 'keydown' is always the first
                // event triggered between the three (keydown, keypress, input).
                // So we create a new map each time a 'keydown' is registred.
                if (ev.type === 'keydown') {
                    this.currentStackObservation._multiKeyStack.push({});
                }
                const lastMultiKeys = this.currentStackObservation._multiKeyStack[this.currentStackObservation._multiKeyStack.length - 1];
                if (lastMultiKeys) {
                    lastMultiKeys[ev.type] = ev;
                }
            }
            this.currentStackObservation._eventsMap[ev.type] = ev;
            if (ev.type.startsWith('composition')) {
                // In most cases we only need the last composition of the
                // registred events
                this.currentStackObservation._eventsMap.lastComposition = ev;
            }
            this.currentStackObservation._events.push(ev);
        }
    }
    /**
     * This function is the root of the normalization for most events.
     *
     * Process the events registered with `_regiterEvent` and call
     * `_triggerEventBatch` with one or more `NormalizedEvent` when sufficient
     * information has been gathered from all registred events.
     *
     * It could take up to two tick in the browser to gather all the sufficient
     * information. (e.g. Safari)
     *
     */
    /**
     * In some cases, the observation must be delayed to the next tick. In these
     * cases, this control variable will be set to true such that the analysis
     * process knows the current event queue processing has been delayed.
     */
    async _processEvents(currentStackObservation, secondTickObservation = false) {
        var _a;
        // In some cases, for example cutting with Cmd+X on Safari, the browser
        // triggers events in two different stacks. In such cases, observing
        // events occuring during one tick is not enough so we need to delay the
        // analysis after we observe events during two ticks instead.
        const needSecondTickObservation = currentStackObservation._events.every(ev => {
            return !MultiStackEventTypes.includes(ev.type);
        });
        if (needSecondTickObservation && !secondTickObservation) {
            return await new Promise((resolve) => {
                setTimeout(() => {
                    resolve(this._processEvents(currentStackObservation, true));
                });
            });
        }
        let normalizedActions = [];
        const keydownEvent = currentStackObservation._eventsMap.keydown;
        const keypressEvent = currentStackObservation._eventsMap.keypress;
        const inputEvent = currentStackObservation._eventsMap.input;
        const keyboardSelectAllEvent = currentStackObservation._eventsMap.keyboardSelectAll;
        const compositionEvent = currentStackObservation._eventsMap.lastComposition;
        const cutEvent = currentStackObservation._eventsMap.cut;
        const dropEvent = currentStackObservation._eventsMap.drop;
        const pasteEvent = currentStackObservation._eventsMap.paste;
        const compositionData = this._getCompositionData(compositionEvent, inputEvent);
        const isGoogleKeyboardBackspace = compositionData &&
            compositionData.compositionFrom.slice(0, -1) === compositionData.compositionTo &&
            keydownEvent &&
            keydownEvent.key === 'Unidentified';
        const inferredKeydownEvent = keydownEvent &&
            keydownEvent.key === 'Unidentified' &&
            this._inferKeydownEvent(inputEvent);
        //
        // First pass to get the informations
        //
        const key = (keypressEvent &&
            keypressEvent.key !== 'Unidentified' &&
            keypressEvent.key !== 'Dead' &&
            keypressEvent.key) ||
            (inputEvent && ((_a = inputEvent.data) === null || _a === void 0 ? void 0 : _a.length) === 1 && inputEvent.data) ||
            (keydownEvent &&
                keydownEvent.key !== 'Unidentified' &&
                keydownEvent.key !== 'Dead' &&
                keydownEvent.key) ||
            (isGoogleKeyboardBackspace && 'Backspace') ||
            (keydownEvent &&
                keydownEvent.key === 'Unidentified' &&
                inferredKeydownEvent &&
                inferredKeydownEvent.code);
        const inputType = (cutEvent && 'deleteByCut') ||
            (dropEvent && 'insertFromDrop') ||
            (pasteEvent && 'insertFromPaste') ||
            (inputEvent && inputEvent.inputType);
        // In case of accent inserted from a Mac, check that the char before was
        // one of the special accent temporarily inserted in the DOM (e.g. '^',
        // '`', ...).
        //
        const compositionReplaceOneChar = compositionData &&
            compositionData.compositionFrom.length === 1 &&
            compositionData.compositionTo.length === 1;
        const compositionAddOneChar = compositionData &&
            compositionData.compositionFrom === '' &&
            compositionData.compositionTo.length === 1;
        const isCompositionKeyboard = compositionAddOneChar || compositionReplaceOneChar;
        const isVirtualKeyboard = compositionEvent && key && key.length !== 1;
        // Compute the set of mutated elements accross all observed events.
        const mutatedElements = this._mutationNormalizer.getMutatedElements();
        this._mutationNormalizer.stop();
        // When the browser trigger multiples keydown at once, for each keydown
        // there is always also a keypress and an input that must be present.
        const possibleMultiKeydown = currentStackObservation._multiKeyStack.every(keydownMap => keydownMap.keydown &&
            keydownMap.keydown.key !== 'Unidentified' &&
            (keydownMap.input || keydownMap.keydown.key.length > 1));
        // if there is only one _multiKeyMap, it means that there is no
        // multiples keys pushed.
        if (currentStackObservation._multiKeyStack.length > 1 && possibleMultiKeydown) {
            currentStackObservation._multiKeyStack.map(keydownMap => {
                const keyboardAction = this._getKeyboardAction(keydownMap.keydown.key, (keydownMap.input && keydownMap.input.inputType) || '', !!mutatedElements.size);
                if (keyboardAction) {
                    normalizedActions.push(keyboardAction);
                }
            });
        }
        else if (cutEvent) {
            const deleteContentAction = {
                type: 'deleteContent',
                direction: Direction.FORWARD,
            };
            // remove previously parsed keyboard action as we only want to remove
            normalizedActions.push(deleteContentAction);
        }
        else if (dropEvent) {
            normalizedActions.push(...this._getDropActions(dropEvent));
        }
        else if (pasteEvent) {
            normalizedActions.push(this._getDataTransferAction(pasteEvent));
        }
        else if (keyboardSelectAllEvent) {
            const selectAllAction = {
                type: 'selectAll',
            };
            normalizedActions.push(selectAllAction);
        }
        else if (normalizedActions.length === 0 &&
            ((!compositionEvent && key) || isCompositionKeyboard || isVirtualKeyboard)) {
            const keyboardAction = this._getKeyboardAction(key, inputType, !!mutatedElements.size);
            if (keyboardAction) {
                normalizedActions.push(keyboardAction);
            }
            if (compositionReplaceOneChar) {
                normalizedActions = compositionData.actions;
            }
        }
        else if (normalizedActions.length === 0 && compositionData) {
            normalizedActions.push(...compositionData.actions);
        }
        if (inputEvent && inputEvent.inputType && inputEvent.inputType.indexOf('format') === 0) {
            const formatName = inputEvent.inputType.replace('format', '').toLowerCase();
            const applyFormatAction = {
                type: 'applyFormat',
                format: formatName,
                data: inputEvent.data,
            };
            normalizedActions.push(applyFormatAction);
        }
        else if (inputEvent && ['historyUndo', 'historyRedo'].includes(inputEvent.inputType)) {
            const historyAction = {
                type: inputEvent.inputType,
            };
            normalizedActions.push(historyAction);
        }
        this.initNextObservation();
        if (normalizedActions.length > 0) {
            const batch = {
                actions: normalizedActions,
                mutatedElements,
            };
            if (inferredKeydownEvent) {
                batch.inferredKeydownEvent = inferredKeydownEvent;
            }
            return batch;
        }
        return { actions: [] };
    }
    /**
     * Set the next observation.
     */
    initNextObservation() {
        this._followsPointerAction = false;
        this.currentStackObservation = {
            _events: [],
            _multiKeyStack: [],
            _eventsMap: {},
        };
    }
    _getCompositionData(compositionEvent, inputEvent) {
        if (compositionEvent && inputEvent) {
            let compositionDataString = compositionEvent.data;
            // Specific case for SwiftKey. Swiftkey add a space in the
            // inputEvent but not in the composition event.
            const isSwiftKeyAutocorrect = inputEvent.inputType === 'insertText' &&
                inputEvent.data &&
                inputEvent.data.length === 1 &&
                inputEvent.data !== compositionDataString &&
                inputEvent.data === ' ';
            if (isSwiftKeyAutocorrect) {
                compositionDataString += ' ';
            }
            return this._getCompositionFromString(compositionDataString);
        }
        else if (inputEvent && inputEvent.inputType === 'insertReplacementText') {
            // safari trigger an input with 'insertReplacementText' when it
            // correct a word.
            return this._getCompositionFromString(inputEvent.data);
        }
    }
    /**
     * Infer a `KeyboardEvent` `code` from an `InputEvent`
     */
    _inferKeydownEvent(inputEvent) {
        let code;
        if (inputEvent.inputType === 'insertParagraph') {
            code = 'Enter';
        }
        else if (inputEvent.inputType === 'deleteContentBackward') {
            code = 'Backspace';
        }
        else if (inputEvent.inputType === 'deleteContentForward') {
            code = 'Delete';
        }
        if (code) {
            return Object.assign(Object.assign({}, this._modifierKeys), { key: code, code: code });
        }
    }
    /**
     * Get a keyboard action if something has happned in the DOM (insert,
     * delete, navigation).
     *
     * @param key
     * @param inputType
     * @param hasMutataedElements
     * @param isMultiKey
     */
    _getKeyboardAction(key, inputType, hasMutatedElements) {
        const isInsertOrRemoveAction = hasMutatedElements && !inputTypeCommands.has(inputType);
        if (isInsertOrRemoveAction) {
            if (key === 'Backspace' || key === 'Delete') {
                return this._getRemoveAction(key, inputType);
            }
            else if (key === 'Enter') {
                if (inputType === 'insertLineBreak') {
                    const insertLineBreakAction = {
                        type: 'insertLineBreak',
                    };
                    return insertLineBreakAction;
                }
                else {
                    const insertParagraphAction = {
                        type: 'insertParagraphBreak',
                    };
                    return insertParagraphAction;
                }
            }
            else if (key.length === 1) {
                const insertTextAction = {
                    type: 'insertText',
                    text: key,
                };
                return insertTextAction;
            }
        }
    }
    /**
     * Get the actions for a event `ev` of type drop.
     *
     * @param ev
     */
    _getDropActions(ev) {
        const actions = [];
        if (ev.draggingFromEditable && !ev.files.length) {
            const selection = document.getSelection();
            if (!selection.isCollapsed) {
                const deleteContentAction = {
                    type: 'deleteContent',
                    direction: Direction.FORWARD,
                };
                actions.push(deleteContentAction);
            }
        }
        const setSelectionAction = {
            type: 'setSelection',
            domSelection: ev.selection,
        };
        actions.push(setSelectionAction);
        actions.push(this._getDataTransferAction(ev));
        return actions;
    }
    /**
     * Extract informations from dataTranser to know what has been done in the
     * DOM and return it a normalizedAction.
     *
     * when drag and dropping, most browsers wrap the element with tags and
     * styles.  And when dropping in the (same or different) browser, there is
     * many differents behavior.
     *
     * Some browser reload the page when dropping (img or link (from status
     * bar)).  For this reason, we block all the content from being added in the
     * editable. (otherwise reloading happen).
     *
     * Note: The user can drag and drop a link or an img, from the browser
     * navigation bar.
     *
     */
    _getDataTransferAction(dataTransfer) {
        if (dataTransfer.files.length) {
            const insertFilesAction = {
                type: 'insertFiles',
                files: dataTransfer.files,
            };
            return insertFilesAction;
        }
        const uri = dataTransfer['text/uri-list'];
        // eslint-disable-next-line no-control-regex
        const html = dataTransfer['text/html'].replace(/\x00/g, ''); // replace for drag&drop from firefox to chrome
        const text = dataTransfer['text/plain'];
        if (html && uri) {
            const temp = document.createElement('temp');
            temp.innerHTML = html;
            const element = temp.querySelector('a, img');
            if (element) {
                if (!dataTransfer.draggingFromEditable &&
                    nodeName(element) === 'A' &&
                    element.innerHTML === '') {
                    // add default content if it's external link
                    element.innerHTML = uri;
                }
                const insertHtmlAction = {
                    type: 'insertHtml',
                    html: element.outerHTML,
                    text: uri,
                };
                return insertHtmlAction;
            }
            else {
                const insertHtmlAction = {
                    type: 'insertHtml',
                    html: html,
                    text: uri,
                };
                return insertHtmlAction;
            }
        }
        else if (html) {
            const insertHtmlAction = {
                type: 'insertHtml',
                // Cross browser drag & drop will add useless meta tag at the
                // beginning of the html.
                html: html && html.replace(/^<meta[^>]+>/, ''),
                text: text,
            };
            return insertHtmlAction;
        }
        else if (uri) {
            const insertHtmlAction = {
                type: 'insertHtml',
                html: '<a href="' + uri + '">' + uri + '</a>',
                text: uri,
            };
            return insertHtmlAction;
        }
        else {
            const insertTextAction = {
                type: 'insertText',
                text: text,
            };
            return insertTextAction;
        }
    }
    /**
     * Process the composition to identify the text that was inserted.
     *
     * Attention, there is a case impossible to retrieve the complete
     * information. In the case of we don't have the event data and mutation
     * and we might have "a b" change from a composition to "a c". We receive
     * the word change "b" to "c" instead of "a b" to "a c".
     *
     */
    _getCompositionFromString(compositionData) {
        const charMap = this._mutationNormalizer.getCharactersMapping();
        // The goal of this function is to precisely find what was inserted by
        // a keyboard supporting spell-checking and suggestions.
        // Example (`|` represents the text cursor):
        //   Previous content: 'My friend Christofe| was here.'
        //   Current content:  'My friend Christophe Matthieu| was here.'
        //   Actual text inserted by the keyboard: 'Christophe Matthieu'
        let index = charMap.index;
        let insert = charMap.insert;
        let remove = charMap.remove;
        if (insert === remove && compositionData) {
            insert = compositionData;
            remove = compositionData;
        }
        // In mutation:
        // - we get the changes
        // - try to extract the word or a part of the word (with or without
        //   position)
        // - locate: where the change has been made
        const selection = this._getSelection();
        // if index === -1 it means we could not find the position in the mutated elements
        if (index === -1) {
            // It is possible that the index of the observed change are
            // undefined
            // Example (`|` represents the collapsed selection):
            //   Previous content: 'aa aa aa| aa aa'
            //   Current content:  'aa aa aa aa| aa aa'
            //   Actual text inserted by the keyboard: 'aa '
            //   Observed change:  'aa ]aa aa aa aa[ aa'
            // TODO CHM: the below min/max does not cover all cases
            // With most spell-checking mobile keyboards, the range is set right
            // after the inserted text. It can then be used as a marker to
            // identify the end of the change.
            let insertEnd = 0;
            // The text has been flattened in the characters mapping. When
            // the index of the node has been found, use the range offset
            // to find the index of the character proper.
            insertEnd += selection.focusOffset;
            index = insertEnd - insert.length;
        }
        else {
            let offset = index + insert.length - 1;
            if (charMap.current.nodes[offset] &&
                (selection.focusNode !== charMap.current.nodes[offset] ||
                    selection.focusOffset !== charMap.current.offsets[offset] + 1)) {
                offset++;
                while (charMap.current.nodes[offset] &&
                    (selection.focusNode !== charMap.current.nodes[offset] ||
                        selection.focusOffset > charMap.current.offsets[offset])) {
                    const text = charMap.current.chars[offset];
                    insert += text;
                    remove += text;
                    offset++;
                }
            }
        }
        const before = charMap.previous.chars.slice(0, index);
        const match = before.match(alphabetsContainingSpaces);
        if (match &&
            (insert === '' || alphabetsContainingSpaces.test(insert)) &&
            (remove === '' || alphabetsContainingSpaces.test(remove))) {
            // the word is write in a alphabet which contain space, search
            // to complete the change and include the rest of the word
            const beginWord = match[1];
            remove = beginWord + remove;
            insert = beginWord + insert;
            index -= beginWord.length;
            // Some virtual keyboards (e.g. SwiftKey) add a space at the end of
            // each composition such that the insert is ' '. We filter out those
            // events.
        }
        else if (compositionData &&
            insert &&
            (remove || insert !== ' ') &&
            compositionData !== insert) {
            const charIndex = compositionData.lastIndexOf(insert);
            if (charIndex !== -1) {
                index -= charIndex;
                insert = compositionData;
                const len = remove.length + charIndex;
                remove = charMap.previous.chars.slice(index, index + len + 1);
            }
        }
        // Trim the trailing space added by some virtual keyboards (e.g.
        // SwiftKey).
        const removedEndSpace = remove[remove.length - 1] === ' ';
        const insertedEndSpace = insert[insert.length - 1] === ' ';
        let rawRemove = remove;
        let rawInsert = insert;
        if (insertedEndSpace && removedEndSpace) {
            rawRemove = rawRemove.slice(0, -1);
        }
        if (insertedEndSpace) {
            rawInsert = rawInsert.slice(0, -1);
        }
        const previousNodes = charMap.previous.nodes;
        const previousOffsets = charMap.previous.offsets;
        const lastPreviousNode = previousNodes[previousNodes.length - 1];
        const lastPreviousOffset = previousOffsets[previousOffsets.length - 1] + 1;
        const offsetEnd = index + rawRemove.length;
        const setSelectionAction = {
            type: 'setSelection',
            domSelection: {
                anchorNode: previousNodes[index] || lastPreviousNode,
                anchorOffset: index in previousOffsets ? previousOffsets[index] : lastPreviousOffset,
                focusNode: previousNodes[offsetEnd] || lastPreviousNode,
                focusOffset: offsetEnd in previousOffsets ? previousOffsets[offsetEnd] : lastPreviousOffset,
                direction: Direction.FORWARD,
            },
        };
        const insertTextAction = {
            type: 'insertText',
            text: rawInsert,
        };
        const actions = [setSelectionAction, insertTextAction];
        if (insertedEndSpace) {
            if (removedEndSpace) {
                index += rawRemove.length;
                const setSelectionAction = {
                    type: 'setSelection',
                    domSelection: {
                        anchorNode: previousNodes[index],
                        anchorOffset: previousOffsets[index],
                        focusNode: previousNodes[offsetEnd],
                        focusOffset: previousOffsets[index + 1],
                        direction: Direction.FORWARD,
                    },
                };
                actions.push(setSelectionAction);
            }
            const insertTextAction = {
                type: 'insertText',
                text: ' ',
            };
            actions.push(insertTextAction);
        }
        return {
            compositionFrom: remove,
            compositionTo: insert,
            actions: actions,
        };
    }
    /**
     * Process the given compiled event as a backspace/delete to identify the
     * text that was removed and return an array of the corresponding
     * NormalizedAction.
     *
     * In the case of cut event, the direction will be `Direction.FORWARD`.
     *
     */
    _getRemoveAction(key, inputType) {
        const direction = key === 'Backspace' ? Direction.BACKWARD : Direction.FORWARD;
        // Get characterMapping to retrieve which word has been deleted.
        const characterMapping = this._mutationNormalizer.getCharactersMapping();
        const isSwiftKeyDeleteWord = (inputType === 'deleteContentForward' || inputType === 'deleteContentBackward') &&
            characterMapping.remove.length > 1;
        if (inputType === 'deleteWordForward' ||
            inputType === 'deleteWordBackward' ||
            isSwiftKeyDeleteWord) {
            const deleteWordAction = {
                type: 'deleteWord',
                direction: direction,
                text: characterMapping.remove,
            };
            return deleteWordAction;
        }
        if (inputType === 'deleteHardLineForward' ||
            inputType === 'deleteHardLineBackward' ||
            inputType === 'deleteSoftLineForward' ||
            inputType === 'deleteSoftLineBackward') {
            const deleteHardLineAction = {
                type: 'deleteHardLine',
                direction: direction,
                domSelection: {
                    anchorNode: characterMapping.previous.nodes[characterMapping.index],
                    anchorOffset: characterMapping.previous.offsets[characterMapping.index],
                    focusNode: characterMapping.previous.nodes[characterMapping.index + characterMapping.remove.length - 1],
                    focusOffset: characterMapping.previous.offsets[characterMapping.index + characterMapping.remove.length - 1] + 1,
                    direction: direction,
                },
            };
            return deleteHardLineAction;
        }
        const deleteContentAction = {
            type: 'deleteContent',
            direction: direction,
        };
        return deleteContentAction;
    }
    /**
     * Return true if the given node can be considered a textual node, that is
     * a text node or a BR node.
     *
     * @param node
     */
    _isTextualNode(node) {
        return node.nodeType === Node.TEXT_NODE || nodeName(node) === 'BR';
    }
    /**
     * Get the current selection from the DOM. If there is no selection in the
     * DOM, return a fake one at offset 0 of the editable element.
     * If an event is given, then the selection must be at least partially
     * contained in the target of the event, otherwise it means it took no
     * part in it. In this case, return the caret position instead.
     *
     * @param [ev]
     */
    _getSelection(ev) {
        var _a;
        let selectionDescription;
        let target;
        let root;
        if (ev) {
            target = this._getEventTarget(ev);
            root = getDocument(target);
        }
        else if ((_a = this._initialCaretPosition) === null || _a === void 0 ? void 0 : _a.offsetNode) {
            root = getDocument(this._initialCaretPosition.offsetNode);
        }
        else {
            root = document;
        }
        const selection = root.getSelection();
        let forward;
        if (!selection || selection.rangeCount === 0) {
            // No selection in the DOM. Create a fake one.
            selectionDescription = {
                anchorNode: document.body,
                anchorOffset: 0,
                focusNode: document.body,
                focusOffset: 0,
                direction: Direction.FORWARD,
            };
        }
        else {
            // The selection direction is sorely missing from the DOM api.
            const nativeRange = selection.getRangeAt(0);
            if (selection.anchorNode === selection.focusNode) {
                forward = selection.anchorOffset <= selection.focusOffset;
            }
            else {
                forward = selection.anchorNode === nativeRange.startContainer;
            }
            selectionDescription = {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset,
                direction: forward ? Direction.FORWARD : Direction.BACKWARD,
            };
        }
        // If an event is given, then the range must be at least partially
        // contained in the target of the event, otherwise it means it took no
        // part in it. In this case, consider the caret position instead.
        // This can happen when target is an input or a contenteditable=false.
        if (target instanceof Node) {
            if (!target.contains(selectionDescription.anchorNode) &&
                !target.contains(selectionDescription.focusNode)) {
                const caretPosition = this._getEventCaretPosition(ev);
                selectionDescription = {
                    anchorNode: caretPosition.offsetNode,
                    anchorOffset: caretPosition.offset,
                    focusNode: caretPosition.offsetNode,
                    focusOffset: caretPosition.offset,
                    direction: Direction.FORWARD,
                };
            }
        }
        return selectionDescription;
    }
    /**
     * Check if the given range is selecting the whole editable.
     *
     * @param selection
     */
    _isSelectAll(selection) {
        // The selection from the context menu or a shortcut never have
        // direction forward.
        if (selection.direction === Direction.BACKWARD) {
            return false;
        }
        let startContainer = selection.anchorNode;
        let startOffset = selection.anchorOffset;
        let endContainer = selection.focusNode;
        let endOffset = selection.focusOffset;
        // The selection might still be on a node which has since been removed.
        let invalidStart = true;
        let domNode = startContainer;
        while (domNode && invalidStart) {
            if (domNode instanceof ShadowRoot) {
                domNode = domNode.host;
            }
            else if (document.body.contains(domNode)) {
                invalidStart = false;
            }
            else {
                domNode = domNode.parentNode;
            }
        }
        let invalidEnd = true;
        domNode = endContainer;
        while (domNode && invalidEnd) {
            if (domNode instanceof ShadowRoot) {
                domNode = domNode.host;
            }
            else if (document.body.contains(domNode)) {
                invalidEnd = false;
            }
            else {
                domNode = domNode.parentNode;
            }
        }
        const invalidSelection = invalidStart || invalidEnd;
        // The selection might be collapsed in which case there is no selection.
        const onlyOneNodeSelected = startContainer === endContainer;
        const noCharacterSelected = startOffset === endOffset;
        const isCollapsed = onlyOneNodeSelected && noCharacterSelected;
        // If the selection is invalid or the selection is collapsed, it
        // definitely does not correspond to a select all action.
        if (invalidSelection || isCollapsed) {
            return false;
        }
        [startContainer, startOffset] = targetDeepest(startContainer, startOffset);
        [endContainer, endOffset] = targetDeepest(endContainer, endOffset);
        if (startOffset !== 0 ||
            (endContainer.nodeType === Node.TEXT_NODE &&
                endOffset !== endContainer.textContent.length)) {
            return false;
        }
        // Look for visible nodes in editable that would be outside the selection.
        const startInside = this._isInEditable(startContainer);
        const endInside = this._isInEditable(endContainer);
        const startEdge = startInside && this._isAtVisibleEdge(startContainer, 'start');
        const endEdge = endInside && this._isAtVisibleEdge(endContainer, 'end');
        return (startEdge && endEdge) || (startEdge && !endInside) || (!startInside && endEdge);
    }
    /**
     * Return true if the given element is at the edge of the editable node in
     * the given direction. An element is considered at the edge of the editable
     * node if there is no other visible element in editable that is located
     * beyond it in the given direction.
     *
     * @param node to check whether it is at the visible edge
     * @param side from which to look for textual nodes ('start' or 'end')
     */
    _isAtVisibleEdge(node, side) {
        const editable = this._getClosestElement(node).closest('[contentEditable=true]');
        // Start from the top and do a depth-first search trying to find a
        // visible node that would be in editable and beyond the given element.
        let currentNode = editable;
        const child = side === 'start' ? 'firstChild' : 'lastChild';
        const sibling = side === 'start' ? 'nextSibling' : 'previousSibling';
        let crossVisible = false;
        while (currentNode) {
            if (currentNode === node) {
                // The element was reached without finding another visible node.
                return !crossVisible;
            }
            if (this._isTextualNode(currentNode) && this._isVisible(currentNode, editable)) {
                // There is a textual node in editable beyond the given element.
                crossVisible = true;
            }
            // Continue the depth-first search.
            if (currentNode[child]) {
                currentNode = currentNode[child];
            }
            else if (currentNode[sibling]) {
                currentNode = currentNode[sibling];
            }
            else if (currentNode.parentNode === editable) {
                // Depth-first search has checked all elements in editable.
                return true;
            }
            else {
                currentNode = currentNode.parentNode[sibling];
            }
        }
        return false;
    }
    /**
     * Determine if a node is considered visible.
     */
    _isVisible(el, editable) {
        if (el === document) {
            return false;
        }
        if (el === editable) {
            // The editable node was reached without encountering a hidden
            // container. The editable node is supposed to be visible.
            return true;
        }
        // A <br> element with no next sibling is never visible.
        if (nodeName(el) === 'BR' && !el.nextSibling) {
            return false;
        }
        const style = window.getComputedStyle(this._getClosestElement(el));
        if (style.display === 'none' || style.visibility === 'hidden') {
            return false;
        }
        return this._isVisible(el.parentNode, editable);
    }
    /**
     * Return the node and offset targeted by a event, including if the target
     * is inside a shadow element
     *
     * @param ev
     */
    _getEventCaretPosition(ev) {
        const x = ev.constructor.name === 'TouchEvent'
            ? ev.touches[0].clientX
            : ev.clientX;
        const y = ev.constructor.name === 'TouchEvent'
            ? ev.touches[0].clientY
            : ev.clientY;
        const target = ev.target;
        let caretPosition = caretPositionFromPoint(x, y, target.ownerDocument);
        if (!caretPosition) {
            caretPosition = { offsetNode: ev.target, offset: 0 };
        }
        return caretPosition;
    }
    /**
     * Use the position to get the target from the event (including the target
     * in shadow element)
     *
     * @param ev
     */
    _getEventTarget(ev) {
        const x = ev.constructor.name === 'TouchEvent'
            ? ev.touches[0].clientX
            : ev.clientX;
        const y = ev.constructor.name === 'TouchEvent'
            ? ev.touches[0].clientY
            : ev.clientY;
        const target = ev.target;
        return elementFromPoint(x, y, target.ownerDocument) || target;
    }
    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
    /**
     * Catch setSelection and selectAll actions
     *
     * @param {MouseEvent} ev
     */
    _onContextMenu(ev) {
        var _a;
        if ((_a = this._pointerSelectionTimeout) === null || _a === void 0 ? void 0 : _a.pending) {
            this._pointerSelectionTimeout.fire();
        }
        this._pointerSelectionTimeout = new Timeout(() => {
            if (!this._selectionHasChanged || this._currentlySelectingAll) {
                return { actions: [] };
            }
            this._initialCaretPosition = this._getEventCaretPosition(ev);
            const setSelectionAction = {
                type: 'setSelection',
                domSelection: this._getSelection(ev),
            };
            this._selectionHasChanged = false;
            return {
                actions: [setSelectionAction],
                mutatedElements: new Set([]),
            };
        });
        this._triggerEventBatch(this._pointerSelectionTimeout.promise);
        // The _clickedInEditable property is used to assess whether the user is
        // currently changing the selection by using the mouse. If the context
        // menu ends up opening, the user is definitely not selecting.
        this._mousedownInEditable = false;
    }
    /**
     * Catch Enter, Backspace, Delete and insert actions
     *
     * @param {KeyboardEvent} ev
     */
    _onKeyDownOrKeyPress(ev) {
        this._updateModifiersKeys(ev);
        this._registerEvent(ev);
        const selection = this._getSelection();
        const [offsetNode, offset] = targetDeepest(selection.anchorNode, selection.anchorOffset);
        this._initialCaretPosition = { offsetNode, offset };
    }
    /**
     * Set internal properties of the pointer down event to retrieve them later
     * on when the user stops dragging its selection and the selection has
     * changed.
     *
     * @param {MouseEvent} ev
     */
    _onPointerDown(ev) {
        // Don't trigger events on the editable if the click was done outside of
        // the editable itself or on something else than an element.
        const target = this._getEventTarget(ev);
        const caretPosition = this._getEventCaretPosition(ev);
        if (target && this._isInEditable(caretPosition.offsetNode)) {
            this._mousedownInEditable = true;
            this._initialCaretPosition = caretPosition;
            this._selectionHasChanged = false;
            this._followsPointerAction = true;
        }
        else {
            this._mousedownInEditable = false;
            this._initialCaretPosition = undefined;
        }
    }
    /**
     * Catch setSelection actions coming from clicks.
     *
     * @param ev
     */
    _onPointerUp(ev) {
        // Don't trigger events on the editable if the click was done outside of
        // the editable itself or on something else than an element.
        if (this._mousedownInEditable && ev.target instanceof Element) {
            try {
                // When the users clicks in the DOM, the range is set in the next
                // tick. The observation of the resulting range must thus be delayed
                // to the next tick as well. Store the data we have now before it
                // gets invalidated by the redrawing of the DOM.
                this._initialCaretPosition = this._getEventCaretPosition(ev);
                this._pointerSelectionTimeout = new Timeout(() => {
                    return this._analyzeSelectionChange(ev);
                });
                this._triggerEventBatch(this._pointerSelectionTimeout.promise);
            }
            catch (e) {
                this._mousedownInEditable = false;
                this._initialCaretPosition = undefined;
            }
        }
        else if (ev.target instanceof Element) {
            // When within a contenteditable element but in a non-editable
            // context, prevent a collapsed selection by removing all ranges.
            // TODO: remove them from the VDocument as well.
            this._pointerSelectionTimeout = new Timeout(() => {
                const selection = this._getSelection();
                const collapsed = selection.anchorNode === selection.focusNode &&
                    selection.anchorOffset === selection.focusOffset;
                const target = this._getClosestElement(selection.focusNode);
                if (collapsed && !!target.closest('[contentEditable=true]')) {
                    document.getSelection().removeAllRanges();
                }
                return {
                    actions: [],
                };
            });
            this._triggerEventBatch(this._pointerSelectionTimeout.promise);
        }
    }
    /**
     * Analyze a change of selection to trigger a pointer event for it.
     *
     * @param ev
     */
    _analyzeSelectionChange(ev) {
        const eventBatch = {
            actions: [],
            mutatedElements: new Set([]),
        };
        if (this._selectionHasChanged) {
            const setSelectionAction = {
                type: 'setSelection',
                domSelection: this._getSelection(ev),
            };
            eventBatch.actions.push(setSelectionAction);
        }
        return eventBatch;
    }
    /**
     * Return a node's parent if it's not an instance of `Element`.
     *
     * @param node
     */
    _getClosestElement(node) {
        return node instanceof Element ? node : node.parentElement;
    }
    /**
     * If the drag start event is observed by the normalizer, it means the
     * dragging started in the editable itself. It means the user is dragging
     * content around in the editable zone.
     *
     */
    _onDragStart() {
        this._draggingFromEditable = true;
    }
    /**
     * Convert the drop event into a custom pre-processed format in order to
     * store additional information that are specific to this point in time,
     * such as the current range and the initial caret position.
     *
     * In some browser we need to infer the drop from other events.
     *
     * Example of droppable object are file, text, url.
     *
     * Drop event can originate from another software, outside the editor zone
     * or inside the editor zone.
     *
     * @param ev
     */
    _onDrop(ev) {
        // Prevent default behavior (e.g. prevent file from being opened in the
        // current tab).
        ev.preventDefault();
        const transfer = ev.dataTransfer;
        const files = [];
        for (const item of transfer.items) {
            if (item.kind === 'file') {
                files.push(item.getAsFile());
            }
        }
        const caretPosition = this._getEventCaretPosition(ev);
        const dropEvent = {
            type: 'drop',
            'text/plain': transfer.getData('text/plain'),
            'text/html': transfer.getData('text/html'),
            'text/uri-list': transfer.getData('text/uri-list'),
            files: files,
            originalEvent: ev,
            selection: {
                anchorNode: caretPosition.offsetNode,
                anchorOffset: caretPosition.offset,
                focusNode: caretPosition.offsetNode,
                focusOffset: caretPosition.offset,
                direction: Direction.FORWARD,
            },
            caretPosition: caretPosition,
            draggingFromEditable: this._draggingFromEditable,
        };
        this._registerEvent(dropEvent);
        // Dragging is over, reset this property.
        this._draggingFromEditable = false;
    }
    /**
     * Convert the clipboard event into a custom pre-processed format in order
     * to store additional information that are specific to this point in time,
     * such as the current range and the initial caret position.
     *
     * @param ev
     */
    _onClipboard(ev) {
        if (ev.type === 'paste') {
            // Prevent the default browser wild pasting behavior.
            ev.preventDefault();
        }
        const clipboard = ev.clipboardData;
        const pasteEvent = {
            type: ev.type,
            'text/plain': clipboard.getData('text/plain'),
            'text/html': clipboard.getData('text/html'),
            'text/uri-list': clipboard.getData('text/uri-list'),
            files: [],
            originalEvent: ev,
            selection: this._getSelection(),
            caretPosition: this._initialCaretPosition,
            draggingFromEditable: false,
        };
        this._registerEvent(pasteEvent);
    }
    /**
     * Update the modifiers keys to know which modifiers keys are pushed.
     *
     * @param e
     */
    _updateModifiersKeys(e) {
        this._modifierKeys = {
            ctrlKey: e.ctrlKey,
            altKey: e.altKey,
            metaKey: e.metaKey,
            shiftKey: e.shiftKey,
        };
    }
    /**
     * On each change of selection, check if it might be a "selectAll" action.
     *
     * A "selectAll" action can be triggered by:
     * - The shortcut 'CTRL+A'
     * - A user mapping of the OS or browser
     * - From the context menu
     * - Programmatically
     */
    _onSelectionChange() {
        if (!this._initialCaretPosition) {
            // Filter the events because we can have some Shadow root and each
            // normaliser bind event on document.
            return;
        }
        const keydownEvent = this.currentStackObservation._eventsMap.keydown;
        const isNavEvent = keydownEvent instanceof KeyboardEvent &&
            keydownEvent.type === 'keydown' &&
            navigationKey.has(keydownEvent.key);
        if (isNavEvent) {
            const setSelectionAction = {
                type: 'setSelection',
                domSelection: this._getSelection(),
            };
            this.initNextObservation();
            this._triggerEventBatch(new Promise((resolve) => {
                setTimeout(() => {
                    resolve({ actions: [setSelectionAction] });
                });
            }));
        }
        else {
            this._selectionHasChanged = true;
            // This heuristic protects against a costly `_isSelectAll` call.
            const modifiedKeyEvent = this._modifierKeys.ctrlKey || this._modifierKeys.metaKey;
            const heuristic = modifiedKeyEvent || this._followsPointerAction;
            const isSelectAll = heuristic && this._isSelectAll(this._getSelection());
            if (isSelectAll && !this._currentlySelectingAll) {
                if (modifiedKeyEvent) {
                    // This select all was triggered from the keyboard. Add a
                    // fake selectAll event to the queue as a marker for
                    // `_processEvents` to register that a select all was
                    // triggered in this stack.
                    this._registerEvent(new CustomEvent('keyboardSelectAll'));
                }
                else {
                    // The target of the select all specifies where the user caret
                    // was when the select all was triggered.
                    const selectAllAction = {
                        type: 'selectAll',
                    };
                    // We did not find any case where a select all triggered
                    // from the mouse actually resulted in a mutation, so the
                    // mutation normalizer is not listnening in this case. If it
                    // happens to be insufficient later on, the mutated elements
                    // will need to be retrieved from the mutation normalizer.
                    this._triggerEventBatch(Promise.resolve({
                        actions: [selectAllAction],
                        mutatedElements: new Set(),
                    }));
                }
            }
            // Safari on MacOS triggers a selection change when pressing Ctrl
            // even though the selection did not actually change. This property
            // is used to store whether the current state is considered to be a
            // select all. The point is to avoid triggering a new event for a
            // selection change if everything was already selected beforehand.
            this._currentlySelectingAll = isSelectAll;
        }
    }
    /**
     * Create an instance of EventNormalizer if the pointer touch a shadow node.
     *
     * @param {MouseEvent} ev
     */
    _onEventEnableNormalizer(ev) {
        this._enableNormalizer(ev.target);
    }
    /**
     * Create an instance of EventNormalizer for the given element with shadow
     * content or iframe content.
     * To be editable an iframe cannot have src because it must be an iframe
     * with content generated by the editor.
     *
     * @param {Element} el
     */
    _enableNormalizer(el) {
        const root = el.shadowRoot ||
            (el instanceof HTMLIFrameElement && !el.src && el.contentWindow.document);
        if (root && !this._shadowNormalizers.get(root)) {
            const eventNormalizer = new EventNormalizer_EventNormalizer(this._isInEditable, this._triggerEventBatch, root);
            this._shadowNormalizers.set(root, eventNormalizer);
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-dom-editable/src/DomEditable.ts







class DomEditable_DomEditable extends JWPlugin {
    constructor(editor, configuration) {
        super(editor, configuration);
        this.commands = {
            selectAll: {
                handler: this.selectAll,
            },
        };
        this._processKeydown = this._processKeydown.bind(this);
    }
    async start() {
        const domLayout = this.dependencies.get(DomLayout_DomLayout);
        this.eventNormalizer = new EventNormalizer_EventNormalizer(domLayout.isInEditable.bind(domLayout), this._onNormalizedEvent.bind(this));
        window.addEventListener('keydown', this._processKeydown);
    }
    async stop() {
        this.eventNormalizer.destroy();
        window.removeEventListener('keydown', this._processKeydown);
        return super.stop();
    }
    /**
     * Update the selection in such a way that it selects the entire document.
     *
     * @param params
     */
    selectAll() {
        const domEngine = this.dependencies.get(Layout_Layout).engines.dom;
        const editable = domEngine.components.editable[0];
        this.editor.selection.set({
            anchorNode: editable.firstLeaf(),
            anchorPosition: RelativePosition.BEFORE,
            focusNode: editable.lastLeaf(),
            focusPosition: RelativePosition.AFTER,
            direction: Direction.FORWARD,
        });
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Handle the received signal and dispatch the corresponding editor command,
     * based on the user's configuration and context.
     *
     * @param action
     */
    _matchCommand(action) {
        switch (action.type) {
            case 'insertLineBreak':
                return ['insertLineBreak', {}];
            case 'insertText':
            case 'insertHtml': {
                const params = { text: action.text };
                return ['insertText', params];
            }
            case 'selectAll':
                return ['selectAll', {}];
            case 'setSelection': {
                const layout = this.dependencies.get(Layout_Layout);
                const domLayoutEngine = layout.engines.dom;
                const vSelectionParams = {
                    vSelection: domLayoutEngine.parseSelection(action.domSelection),
                };
                return ['setSelection', vSelectionParams];
            }
            case 'insertParagraphBreak':
                return ['insertParagraphBreak', {}];
            case 'deleteWord':
                if (action.direction === Direction.FORWARD) {
                    const text = Array.from(action.text);
                    if (text[text.length - 1] === ' ') {
                        // Make sure to handle a space _before_ the word.
                        text.unshift(text.pop());
                    }
                    let end = this.editor.selection.range.end;
                    while (end && text.length) {
                        const next = end.nextSibling();
                        if ((next === null || next === void 0 ? void 0 : next.textContent) === text.shift()) {
                            end = next;
                        }
                    }
                    return [
                        'deleteForward',
                        {},
                        VRange_VRange.selecting(this.editor.selection.range.start, end),
                    ];
                }
                else {
                    let start = this.editor.selection.range.start;
                    const text = Array.from(action.text);
                    if (text[0] === ' ') {
                        // Make sure to treat a space _before_ the word.
                        text.push(text.shift());
                    }
                    while (start && text.length) {
                        const previous = start.previousSibling();
                        if ((previous === null || previous === void 0 ? void 0 : previous.textContent) === text.pop()) {
                            start = previous;
                        }
                    }
                    return [
                        'deleteBackward',
                        {},
                        VRange_VRange.selecting(start, this.editor.selection.range.end),
                    ];
                }
            case 'deleteContent': {
                if (action.direction === Direction.FORWARD) {
                    return ['deleteForward', {}];
                }
                else {
                    return ['deleteBackward', {}];
                }
            }
            default:
                break;
        }
    }
    /**
     * Handle the received signal and dispatch the corresponding editor command,
     * based on the user's configuration and context.
     *
     * @param batchPromise
     */
    async _onNormalizedEvent(batchPromise) {
        // TODO: The `nextEventMutex` shenanigans that were removed in this
        // commit should be reinstated unless we want the normalizer to call
        // `execCommand` regardless of the observation outcome like it used to
        // call `nextEventMutex` before calling `execCommand`.
        const batch = await batchPromise;
        const domEngine = this.dependencies.get(Layout_Layout).engines.dom;
        if (batch.mutatedElements) {
            domEngine.markForRedraw(batch.mutatedElements);
        }
        let processed = false;
        if (batch.inferredKeydownEvent) {
            const domLayout = this.dependencies.get(DomLayout_DomLayout);
            processed = !!(await domLayout.processKeydown(new KeyboardEvent('keydown', Object.assign(Object.assign({}, batch.inferredKeydownEvent), { key: batch.inferredKeydownEvent.key, code: batch.inferredKeydownEvent.code }))));
        }
        if (!processed) {
            for (const action of batch.actions) {
                const [commandName, commandParams, rangeBounds] = this._matchCommand(action);
                if (commandName && rangeBounds) {
                    await this.editor.execWithRange(rangeBounds, commandName, commandParams);
                }
                else if (commandName) {
                    await this.editor.execCommand(commandName, commandParams);
                }
            }
        }
    }
    /**
     * In DomLayout, KeyboardEvent listener to be added to the DOM that calls
     * `execCommand` if the keys pressed match one of the shortcut registered
     * in the keymap.
     * In case of the keydow are defaultPrevented it's means we executed a new
     * command. We split the event agragation of normalizer to ensure to have
     * the next execCommand at the right time.
     *
     * @param event
     */
    _processKeydown(event) {
        if (event.defaultPrevented) {
            this.eventNormalizer.initNextObservation();
        }
    }
}
DomEditable_DomEditable.dependencies = [DomLayout_DomLayout, Layout_Layout];

// CONCATENATED MODULE: ./packages/plugin-history/src/History.ts



class History_History extends JWPlugin {
    constructor(editor) {
        super(editor);
        this.loadables = {
            shortcuts: [
                {
                    pattern: 'CTRL+Z',
                    commandId: 'undo',
                },
                {
                    pattern: 'CTRL+SHIFT+Z',
                    commandId: 'redo',
                },
                {
                    pattern: 'CTRL+Y',
                    commandId: 'redo',
                },
            ],
            components: [
                {
                    id: 'UndoButton',
                    render: async () => {
                        const button = new ActionableNode_ActionableNode({
                            name: 'undo',
                            label: 'History undo',
                            commandId: 'undo',
                            enabled: () => this._memoryStep > 0,
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-undo fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'RedoButton',
                    render: async () => {
                        const button = new ActionableNode_ActionableNode({
                            name: 'redo',
                            label: 'History redo',
                            commandId: 'redo',
                            enabled: () => this._memoryKeys.length - 1 > this._memoryStep,
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-redo fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [
                ['UndoButton', ['actionables']],
                ['RedoButton', ['actionables']],
            ],
        };
        this.commands = {
            undo: {
                handler: this.undo,
            },
            redo: {
                handler: this.redo,
            },
        };
        this.commandHooks = {
            '@commit': this._registerMemoryKey,
        };
        this._memoryKeys = [];
        this._memoryCommands = [];
        this._memoryStep = -1;
        this.loadables.components.push();
    }
    undo() {
        this._memoryStep--;
        if (this._memoryStep < 0) {
            this._memoryStep = 0;
        }
        this.editor.memory.switchTo(this._memoryKeys[this._memoryStep]);
    }
    redo() {
        this._memoryStep++;
        const max = this._memoryKeys.length - 1;
        if (this._memoryStep > max) {
            this._memoryStep = max;
        }
        this.editor.memory.switchTo(this._memoryKeys[this._memoryStep]);
    }
    _registerMemoryKey(commitParams) {
        const sliceKey = this.editor.memory.sliceKey;
        if (!this._memoryKeys.includes(sliceKey)) {
            const commands = commitParams.commandNames;
            if (commands.length === 1 && commands[0] === 'setSelection') {
                if (this._memoryStep > this._memoryKeys.length - 1) {
                    // After an undo, don't replace history for setSelection.
                    return;
                }
                const prevCommand = this._memoryCommands[this._memoryStep];
                if (prevCommand && prevCommand.length === 1 && prevCommand[0] === 'setSelection') {
                    // Concat setSelection.
                    this._memoryKeys[this._memoryStep] = sliceKey;
                    return;
                }
            }
            else if (this.editor.memoryInfo.uiCommand) {
                return;
            }
            this._memoryStep++;
            this._memoryKeys.splice(this._memoryStep, Infinity, sliceKey);
            this._memoryCommands.splice(this._memoryStep, Infinity, [...commands]);
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-input/src/InputNode.ts

class InputNode_InputNode extends VElement_VElement {
    constructor(params = {}) {
        super({ htmlTag: 'INPUT' });
        this.inputName = params.inputName || '';
        this.inputType = params.inputType || 'text';
        this.value = params.value || '';
        if (params.change)
            this.change = params.change;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    change(editor) { }
}

// CONCATENATED MODULE: ./packages/plugin-input/src/InputXmlDomParser.ts




class InputXmlDomParser_InputXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'INPUT';
        };
    }
    async parse(item) {
        const input = new InputNode_InputNode({
            inputType: item.getAttribute('type'),
            inputName: item.getAttribute('name'),
            value: item.value,
        });
        const attributes = this.engine.parseAttributes(item);
        if (attributes) {
            attributes.remove('type'); // type is on input.inputType
            attributes.remove('name'); // type is on input.inputName
        }
        if (attributes.length) {
            input.modifiers.append(attributes);
        }
        const nodes = await this.engine.parse(...item.childNodes);
        input.append(...nodes);
        return [input];
    }
}
InputXmlDomParser_InputXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-input/src/InputDomObjectRenderer.ts



class InputDomObjectRenderer_InputDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = InputNode_InputNode;
    }
    /**
     * Render the VNode to the given format.
     */
    async render(node) {
        const input = {
            tag: 'INPUT',
            attributes: {
                type: node.inputType,
                name: node.inputName,
                value: node.value,
            },
        };
        let onInputChange;
        let mousedown;
        let changeHandler;
        input.attach = (el) => {
            onInputChange = this._onCommit.bind(this, node, el);
            changeHandler = () => {
                this.engine.editor.execCommand(() => {
                    node.value = el.value;
                    node.change(this.engine.editor);
                });
            };
            mousedown = (ev) => {
                ev.stopImmediatePropagation();
                ev.stopPropagation();
            };
            el.addEventListener('change', changeHandler);
            el.addEventListener('mousedown', mousedown);
            this.engine.editor.dispatcher.registerCommandHook('@commit', onInputChange);
        };
        input.detach = (el) => {
            el.removeEventListener('change', changeHandler);
            el.removeEventListener('mousedown', mousedown);
            this.engine.editor.dispatcher.removeCommandHook('@commit', onInputChange);
        };
        return input;
    }
    /**
     * On input change handler.
     *
     * Meant to be overriden.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    _onCommit(node, el) { }
}
InputDomObjectRenderer_InputDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-input/src/Input.ts



class Input_Input extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [InputXmlDomParser_InputXmlDomParser],
            renderers: [InputDomObjectRenderer_InputDomObjectRenderer],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-dialog/src/DialogZoneNode.ts

class DialogZoneNode_DialogZoneNode extends ZoneNode_ZoneNode {
}

// EXTERNAL MODULE: ./packages/plugin-dialog/assets/Dialog.xml
var assets_Dialog = __webpack_require__(4);
var Dialog_default = /*#__PURE__*/__webpack_require__.n(assets_Dialog);

// EXTERNAL MODULE: ./packages/plugin-dialog/assets/Dialog.css
var plugin_dialog_assets_Dialog = __webpack_require__(11);

// CONCATENATED MODULE: ./packages/plugin-dialog/src/DialogZoneDomObjectRenderer.ts







const DialogZoneDomObjectRenderer_container = document.createElement('jw-container');
DialogZoneDomObjectRenderer_container.innerHTML = Dialog_default.a;
const dialog = DialogZoneDomObjectRenderer_container.firstElementChild;
class DialogZoneDomObjectRenderer_DialogZoneDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = DialogZoneNode_DialogZoneNode;
    }
    async render(node, worker) {
        var _a;
        const float = document.createElement('jw-dialog-container');
        for (const child of node.childVNodes) {
            if (child.tangible || child instanceof MetadataNode_MetadataNode) {
                if (!((_a = node.hidden) === null || _a === void 0 ? void 0 : _a[child.id])) {
                    float.appendChild(await this._renderDialog(child));
                }
                worker.depends(child, node);
            }
        }
        return {
            dom: float.childNodes.length ? [float] : [],
        };
    }
    async _renderDialog(node) {
        const clone = dialog.cloneNode(true);
        const content = clone.querySelector('jw-content');
        content.appendChild(this.engine.renderPlaceholder(node));
        let componentId;
        const components = this.engine.editor.plugins.get(Layout_Layout).engines.dom.components;
        for (const id in components) {
            if (components[id].includes(node)) {
                componentId = id;
            }
        }
        clone.addEventListener('click', (ev) => {
            const target = ev.target;
            if (target.classList.contains('jw-close')) {
                this.engine.editor.execCommand('hide', { componentId: componentId });
            }
        });
        return clone;
    }
}
DialogZoneDomObjectRenderer_DialogZoneDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dialog/src/DialogZoneXmlDomParser.ts




class DialogZoneXmlDomParser_DialogZoneXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'T-DIALOG';
        };
    }
    async parse(item) {
        const zones = [];
        for (const child of item.querySelectorAll('t[t-zone]')) {
            zones.push(child.getAttribute('t-zone'));
        }
        return [new DialogZoneNode_DialogZoneNode({ managedZones: zones })];
    }
}
DialogZoneXmlDomParser_DialogZoneXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dialog/src/Dialog.ts






class Dialog_Dialog extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [DialogZoneXmlDomParser_DialogZoneXmlDomParser],
            renderers: [DialogZoneDomObjectRenderer_DialogZoneDomObjectRenderer],
        };
    }
}
Dialog_Dialog.dependencies = [Parser_Parser, Renderer_Renderer, DomLayout_DomLayout];

// CONCATENATED MODULE: ./packages/plugin-dom-follow-range/src/FollowRangeZoneNode.ts

class FollowRangeZoneNode_FollowRangeZoneNode extends ZoneNode_ZoneNode {
}

// CONCATENATED MODULE: ./packages/plugin-dom-follow-range/src/FollowRangeZoneNodeXmlDomParser.ts




class FollowRangeZoneNodeXmlDomParser_FollowRangeZoneNodeXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'T-RANGE';
        };
    }
    async parse(item) {
        const zones = [];
        for (const child of item.querySelectorAll('t[t-zone]')) {
            zones.push(child.getAttribute('t-zone'));
        }
        return [new FollowRangeZoneNode_FollowRangeZoneNode({ managedZones: zones })];
    }
}
FollowRangeZoneNodeXmlDomParser_FollowRangeZoneNodeXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// EXTERNAL MODULE: ./packages/plugin-dom-follow-range/assets/FollowRange.css
var assets_FollowRange = __webpack_require__(13);

// CONCATENATED MODULE: ./packages/plugin-dom-follow-range/src/FollowRangeZoneDomObjectRenderer.ts





class FollowRangeZoneDomObjectRenderer_FollowRangeZoneDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = FollowRangeZoneNode_FollowRangeZoneNode;
    }
    async render(node) {
        if (node.hasChildren()) {
            let debounce;
            let followRangeDebounced;
            const followRange = {
                tag: 'JW-FOLLOW-RANGE',
                children: node.children(),
                attributes: { style: { 'display': 'none' } },
                attach: (el) => {
                    followRangeDebounced = () => {
                        window.clearTimeout(debounce);
                        debounce = window.setTimeout(this._followChangedSelection.bind(this, el), 3);
                    };
                    document.addEventListener('selectionchange', followRangeDebounced, false);
                    window.addEventListener('resize', followRangeDebounced);
                },
                detach: () => {
                    document.removeEventListener('selectionchange', followRangeDebounced, false);
                    window.removeEventListener('resize', followRangeDebounced);
                },
            };
            return followRange;
        }
        else {
            return { children: [] };
        }
    }
    _followChangedSelection(container) {
        let selection;
        let doc = document;
        let isCollapsed = true;
        do {
            selection = doc.getSelection();
            doc = null;
            // don't use selection.isCollapsed because in shadowRoot the value
            // is every time true.
            isCollapsed =
                selection.anchorNode === selection.focusNode &&
                    selection.anchorOffset === selection.focusOffset;
            if (selection.rangeCount && isCollapsed) {
                const [el] = targetDeepest(selection.anchorNode, selection.anchorOffset);
                if (el instanceof Element && el.shadowRoot) {
                    doc = el.shadowRoot;
                }
            }
        } while (doc);
        const selectionIsInEditable = !!selection &&
            selection.anchorNode &&
            selection.anchorNode.parentElement.closest('[contenteditable="true"]');
        // If the selection goes into an input inside the jw-follow-range, do nothing.
        if (document.activeElement instanceof HTMLInputElement &&
            document.activeElement.closest('JW-FOLLOW-RANGE')) {
            return;
        }
        if (selection.rangeCount && !isCollapsed && selectionIsInEditable) {
            if (container.parentElement.tagName !== 'BODY') {
                document.body.append(container);
            }
            container.style.display = '';
            const size = container.getBoundingClientRect();
            const range = selection.getRangeAt(0);
            const box = range.getBoundingClientRect();
            container.style.top = window.scrollY + box.top - size.height + 'px';
            let leftPosition = box.left + (box.width - size.width) / 2;
            leftPosition = Math.max(0, leftPosition);
            container.style.left = leftPosition + 'px';
        }
        else if (container.style.display !== 'none') {
            // Use condition to have the minimum of mutations.
            container.style.display = 'none';
        }
    }
}
FollowRangeZoneDomObjectRenderer_FollowRangeZoneDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-dom-follow-range/src/FollowRange.ts







class FollowRange_FollowRange extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [FollowRangeZoneNodeXmlDomParser_FollowRangeZoneNodeXmlDomParser],
            renderers: [FollowRangeZoneDomObjectRenderer_FollowRangeZoneDomObjectRenderer],
        };
    }
}
FollowRange_FollowRange.dependencies = [Parser_Parser, Renderer_Renderer, DomLayout_DomLayout, Layout_Layout];

// CONCATENATED MODULE: ./packages/plugin-toolbar/src/ToolbarXmlDomParser.ts





class ToolbarXmlDomParser_ToolbarZoneXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'T-TOOLBAR';
        };
    }
    async parse(item) {
        var _a;
        const toolbar = new ToolbarNode_ToolbarNode();
        const nodes = await this.engine.parse(...item.childNodes);
        toolbar.append(...nodes);
        const toolbarPlugin = this.engine.editor.plugins.get(Toolbar_Toolbar);
        toolbarPlugin.addToolbarItems(toolbar, (_a = toolbarPlugin.configuration) === null || _a === void 0 ? void 0 : _a.layout);
        return [toolbar];
    }
}
ToolbarXmlDomParser_ToolbarZoneXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-toolbar/src/ToolbarDomObjectRenderer.ts



class ToolbarDomObjectRenderer_ToolbarZoneDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ToolbarNode_ToolbarNode;
    }
    async render(toolbar) {
        const objectToolbar = {
            tag: 'JW-TOOLBAR',
            children: toolbar.children(),
        };
        return objectToolbar;
    }
}
ToolbarDomObjectRenderer_ToolbarZoneDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-toolbar/src/Toolbar.ts











class Toolbar_Toolbar extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [ToolbarXmlDomParser_ToolbarZoneXmlDomParser],
            renderers: [ToolbarDomObjectRenderer_ToolbarZoneDomObjectRenderer],
            components: [
                {
                    id: 'toolbar',
                    render: async () => {
                        var _a;
                        const toolbar = new ToolbarNode_ToolbarNode();
                        this.addToolbarItems(toolbar, ((_a = this.configuration) === null || _a === void 0 ? void 0 : _a.layout) || []);
                        return [toolbar];
                    },
                },
            ],
            componentZones: [['toolbar', ['tools']]],
        };
        this.configuration = Object.assign({ layout: [] }, this.configuration);
    }
    addToolbarItems(node, items) {
        const domEngine = this.editor.plugins.get(Layout_Layout).engines.dom;
        for (const item of items) {
            if (typeof item === 'string') {
                if (item === '|') {
                    node.append(new SeparatorNode_SeparatorNode());
                }
                else if (domEngine.hasConfiguredComponents(item)) {
                    node.append(new ZoneNode_ZoneNode({ managedZones: [item] }));
                }
                else {
                    node.append(new LabelNode_LabelNode({ label: item }));
                }
            }
            else if (item instanceof AbstractNode_AbstractNode) {
                node.append(node);
            }
            else {
                const group = new ActionableGroupNode_ActionableGroupNode();
                this.addToolbarItems(group, item);
                node.append(group);
            }
        }
    }
}
Toolbar_Toolbar.dependencies = [DomLayout_DomLayout];

// CONCATENATED MODULE: ./packages/plugin-textarea/src/TextareaNode.ts

class TextareaNode_TextareaNode extends AtomicNode_AtomicNode {
    constructor(params) {
        super();
        this.value = '';
        this.value = (params && params.value) || '';
    }
}

// CONCATENATED MODULE: ./packages/plugin-textarea/src/TextareaXmlDomParser.ts



class TextareaXmlDomParser_TextareaXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => item instanceof HTMLTextAreaElement;
    }
    /**
     * Parse a list (UL, OL) and its children list elements (LI).
     *
     * @param context
     */
    async parse(item) {
        const textarea = new TextareaNode_TextareaNode({ value: item.value });
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            textarea.modifiers.append(attributes);
        }
        return [textarea];
    }
}
TextareaXmlDomParser_TextareaXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-textarea/src/TextareaDomObjectRenderer.ts



class TextareaDomObjectRenderer_TextareaDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = TextareaNode_TextareaNode;
    }
    /**
     * Render the TextareaNode.
     */
    async render(node) {
        const text = { text: node.value };
        const textarea = {
            tag: 'TEXTAREA',
            children: [text],
        };
        return textarea;
    }
}
TextareaDomObjectRenderer_TextareaDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-textarea/src/Textarea.ts



class Textarea_Textarea extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [TextareaXmlDomParser_TextareaXmlDomParser],
            renderers: [TextareaDomObjectRenderer_TextareaDomObjectRenderer],
        };
    }
}

// EXTERNAL MODULE: ./packages/bundle-basic-editor/basicLayout.xml
var basicLayout = __webpack_require__(5);
var basicLayout_default = /*#__PURE__*/__webpack_require__.n(basicLayout);

// EXTERNAL MODULE: ./packages/bundle-basic-editor/basicLayout.css
var bundle_basic_editor_basicLayout = __webpack_require__(15);

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooFieldNode.ts


class OdooFieldNode_OdooFieldNode extends VElement_VElement {
    constructor(params) {
        super(params);
        this.fieldInfo = makeVersionable(params.fieldInfo);
    }
    /**
     * Return a new VNode with the same type and attributes as this OdooFieldNode.
     */
    clone(deepClone, params) {
        const defaults = {
            htmlTag: this.htmlTag,
            fieldInfo: this.fieldInfo,
        };
        return super.clone(deepClone, Object.assign(Object.assign({}, defaults), params));
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooFieldDomObjectRenderer.ts




class OdooFieldDomObjectRenderer_OdooFieldDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = OdooFieldNode_OdooFieldNode;
    }
    async render(node) {
        const domObject = { tag: node.htmlTag };
        await this._renderValue(node, domObject);
        return domObject;
    }
    /**
     * Render the value of the given field node into the given container.
     *
     * @param node
     * @param container
     */
    async _renderValue(node, container) {
        // TODO CHM: not having default values is cumbersome
        const children = container.children || [];
        const renderedChildren = await this.engine.renderChildren(node);
        children.push(...renderedChildren);
        container.children = children;
        // TODO CHM: not having default values is cumbersome
        container.attributes = container.attributes || {};
        const classList = container.attributes.class || new Set();
        // Instances of the field containing the range are artificially focused.
        const focusedField = this.engine.editor.selection.range.start.ancestor(ancestor => ancestor instanceof OdooFieldNode_OdooFieldNode &&
            ancestor.fieldInfo.value === node.fieldInfo.value);
        if (focusedField) {
            classList.add('jw-focus');
        }
        classList.add('jw-odoo-field');
        if (!node.fieldInfo.isValid.get()) {
            classList.add('jw-odoo-field-invalid');
        }
        if (!node.descendants(AtomicNode_AtomicNode).length) {
            classList.add('jw-odoo-field-empty');
        }
        container.attributes.class = classList;
    }
}
OdooFieldDomObjectRenderer_OdooFieldDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooFieldMap.ts
class OdooFieldMap extends Map {
    static hash(field) {
        return `${field.modelId}-${field.recordId}-${field.fieldName}`;
    }
    get(key) {
        let hashedKey;
        if (typeof key === 'string') {
            hashedKey = key;
        }
        else {
            hashedKey = OdooFieldMap.hash(key);
        }
        return super.get(hashedKey);
    }
    set(key, value) {
        let hashedKey;
        if (typeof key === 'string') {
            hashedKey = key;
        }
        else {
            hashedKey = OdooFieldMap.hash(key);
        }
        super.set(hashedKey, value);
        return this;
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooFieldXmlDomParser.ts






class OdooFieldXmlDomParser_OdooFieldXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return (item instanceof Element &&
                item.attributes['data-oe-type'] &&
                item.attributes['data-oe-model'] &&
                (item.attributes['data-oe-type'].value === 'char' ||
                    item.attributes['data-oe-type'].value === 'text' ||
                    item.attributes['data-oe-type'].value === 'html' ||
                    item.attributes['data-oe-type'].value === 'float' ||
                    item.attributes['data-oe-type'].value === 'integer'));
            // TODO: Handle those fields when their dependecies are met.
            // item.attributes['data-oe-type'].value === 'many2one' ||
            // item.attributes['data-oe-type'].value === 'date' ||
            // item.attributes['data-oe-type'].value === 'datetime'
            // item.attributes['data-oe-type'].value === 'image' ||
            // item.attributes['data-oe-type'].value === 'contact'
        };
        this._reactiveChanges = new OdooFieldMap();
    }
    async parse(element) {
        const field = {
            modelId: element.attributes['data-oe-model'].value,
            recordId: element.attributes['data-oe-id'].value,
            fieldName: element.attributes['data-oe-field'].value,
        };
        // data-oe-type is kind of a widget in Odoo.
        const fieldType = element.attributes['data-oe-type'].value;
        const fieldsRegistry = this.engine.editor.plugins.get(OdooField_OdooField);
        const value = this._parseValue(element);
        const fieldInfo = fieldsRegistry.register(field, fieldType, value);
        const fieldNode = await this._parseField(element, fieldInfo);
        fieldNode.modifiers.append(this.engine.parseAttributes(element));
        // TODO: Remove the mute mechanism when changes come from memory.
        // This prevent cycling when regenerating children after a value change.
        let mute = false;
        fieldNode.on('childList', async () => {
            if (mute)
                return;
            this._reactiveChanges.set(fieldNode.fieldInfo, fieldNode);
            fieldNode.fieldInfo.value.set(this._parseValue(fieldNode));
        });
        // TODO: Replace this value listening mechanism by mirror nodes.
        fieldNode.fieldInfo.value.on('set', () => {
            // TODO: Retrieving the node that made the change is a slight hack
            // that will be removed when mirror nodes are available.
            const original = this._reactiveChanges.get(fieldNode.fieldInfo);
            if (fieldNode === original)
                return;
            mute = true;
            fieldNode.empty();
            fieldNode.append(...original.children().map(child => child.clone(true)));
            mute = false;
        });
        return [fieldNode];
    }
    /**
     * Get an `OdooFieldNode` from an element and a ReactiveValue.
     *
     * @param element
     * @param fieldInfo
     */
    async _parseField(element, fieldInfo) {
        const fieldNode = new OdooFieldNode_OdooFieldNode({ htmlTag: element.tagName, fieldInfo });
        const children = await this.engine.parse(...element.childNodes);
        fieldNode.append(...children);
        return fieldNode;
    }
    _parseValue(source) {
        if (source instanceof Element) {
            return source.innerHTML;
        }
        else {
            const chars = source.descendants(CharNode_CharNode).map(child => child.char);
            return chars.join('');
        }
    }
}
OdooFieldXmlDomParser_OdooFieldXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/utils/src/ReactiveValue.ts

class ReactiveValue_ReactiveValue extends EventMixin_EventMixin {
    constructor(_value) {
        super();
        this._value = _value;
    }
    /**
     * Set the value of this reactiveValue.
     *
     * @param {T} value The value to set.
     * @param {boolean} [fire=true] Fire an event if true.
     * @returns {Promise<void>}
     * @memberof ReactiveValue
     */
    set(value, fire = true) {
        if (value !== this._value) {
            this._value = value;
            if (fire) {
                this.trigger('set', value);
            }
        }
    }
    /**
     * Get the value of this reactiveValue.
     *
     * @returns {T}
     * @memberof ReactiveValue
     */
    get() {
        return this._value;
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooMonetaryFieldNode.ts

var CurrencyPosition;
(function (CurrencyPosition) {
    CurrencyPosition["BEFORE"] = "BEFORE";
    CurrencyPosition["AFTER"] = "AFTER";
})(CurrencyPosition || (CurrencyPosition = {}));
class OdooMonetaryFieldNode_OdooMonetaryFieldNode extends OdooFieldNode_OdooFieldNode {
}

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooMonetaryFieldXmlDomParser.ts


// TODO: retrieve the current decimal of the current lang in odoo
// const localDecimalSeparator = '.';
class OdooMonetaryFieldXmlDomParser_OdooMonetaryFieldXmlDomParser extends OdooFieldXmlDomParser_OdooFieldXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return (item instanceof Element &&
                item.attributes['data-oe-type'] &&
                item.attributes['data-oe-model'] &&
                item.attributes['data-oe-type'].value === 'monetary');
        };
    }
    async _parseField(element, fieldInfo) {
        const amountElement = element.querySelector('.oe_currency_value');
        const currencyElement = amountElement.previousSibling || amountElement.nextSibling;
        const fieldNode = new OdooMonetaryFieldNode_OdooMonetaryFieldNode({
            htmlTag: element.tagName,
            fieldInfo: Object.assign(Object.assign({}, fieldInfo), { currencyValue: currencyElement.textContent, currencyPosition: amountElement.previousSibling
                    ? CurrencyPosition.BEFORE
                    : CurrencyPosition.AFTER }),
        });
        const childNodesToParse = amountElement.childNodes;
        const children = await this.engine.parse(...childNodesToParse);
        fieldNode.append(...children);
        return fieldNode;
    }
    _parseValue(source) {
        if (source instanceof Element) {
            const amountElement = source.querySelector('.oe_currency_value');
            return amountElement.textContent;
        }
        else {
            return super._parseValue(source);
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooMonetaryFieldDomObjectRenderer.ts


class OdooMonetaryFieldDomObjectRenderer_OdooMonetaryFieldDomObjectRenderer extends OdooFieldDomObjectRenderer_OdooFieldDomObjectRenderer {
    constructor() {
        super(...arguments);
        this.predicate = OdooMonetaryFieldNode_OdooMonetaryFieldNode;
    }
    async _renderValue(node, container) {
        const valueContainer = {
            tag: 'span',
            attributes: {
                class: new Set(['oe_currency_value']),
            },
        };
        // TODO CHM: not having default values is cumbersome
        const children = container.children || [];
        children.push(valueContainer);
        const currency = { text: node.fieldInfo.currencyValue };
        if (node.fieldInfo.currencyPosition === CurrencyPosition.BEFORE) {
            children.unshift(currency);
        }
        else {
            children.push(currency);
        }
        container.children = children;
        await super._renderValue(node, valueContainer);
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo-field/src/OdooField.ts








/**
 * Regex used to validate a field.
 */
const fieldValidators = {
    integer: /^[0-9]+$/,
    float: /^[0-9.,]+$/,
    monetary: /^[0-9.,]+$/,
};
class OdooField_OdooField extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [OdooFieldXmlDomParser_OdooFieldXmlDomParser, OdooMonetaryFieldXmlDomParser_OdooMonetaryFieldXmlDomParser],
            renderers: [OdooMonetaryFieldDomObjectRenderer_OdooMonetaryFieldDomObjectRenderer, OdooFieldDomObjectRenderer_OdooFieldDomObjectRenderer],
        };
        this._registry = new OdooFieldMap();
    }
    /**
     * Register an Odoo record.
     *
     * No need to get the inforation from the network if it is already present
     * in the document when parsed by the editor.
     *
     * Create two `ReactiveValue`. One that represent the actual value of the
     * `recordDefinition` and the other represent the validity of the value.
     *
     * See `get` to retrieve the values from an `OdooFieldInfo`.
     */
    register(field, type, value) {
        if (!this._registry.get(field)) {
            // TODO: Retrieve the field from Odoo through RPC.
            const reactiveValue = new ReactiveValue_ReactiveValue();
            const isValid = new ReactiveValue_ReactiveValue(true);
            if (Object.keys(fieldValidators).includes(type)) {
                reactiveValue.on('set', (newValue) => {
                    isValid.set(!!newValue.match(fieldValidators[type]));
                });
            }
            reactiveValue.set(value);
            const reactiveOdooField = makeVersionable(Object.assign(Object.assign({}, field), { value: reactiveValue, isValid }));
            this._registry.set(field, reactiveOdooField);
        }
        return this._registry.get(field);
    }
    /**
     * Retrieve reactive values by providing an `OdooFieldDefinition`.
     *
     * @param field
     */
    get(field) {
        const reactiveOdooField = this._registry.get(field);
        if (!reactiveOdooField) {
            // TODO: Retrieve the field from Odoo through RPC.
            throw new Error(`Impossible to find the field ${field.fieldName} for model ${field.modelId} with id ${field.modelId}.`);
        }
        return reactiveOdooField;
    }
}

// CONCATENATED MODULE: ./packages/utils/src/DomMap.ts

class DomMap_DomMap {
    constructor() {
        this._fromDom = new Map();
        this._toDom = new Map();
    }
    /**
     * Map the given VNode to its corresponding DOM Node and its offset in it.
     *
     * @param node
     * @param domNode
     * @param offset
     * @param method
     */
    set(node, domNode, offset = 0, method = 'push') {
        if (node instanceof LayoutContainerNode_LayoutContainer) {
            return;
        }
        if (this._fromDom.has(domNode)) {
            const matches = this._fromDom.get(domNode);
            if (!matches.some((match) => match.id === node.id)) {
                matches[method](node);
            }
        }
        else {
            this._fromDom.set(domNode, [node]);
        }
        const locations = this._toDom.get(node) || [];
        locations.push([domNode, offset]);
        this._toDom.set(node, locations);
        // Set children.
        for (const renderedChild of domNode.childNodes) {
            const mapping = this.toDomPoint(node);
            if (!mapping) {
                this.set(node, renderedChild, -1, 'unshift');
            }
        }
    }
    /**
     * Return the VNode(s) corresponding to the given DOM Node.
     *
     * @param domNode
     */
    fromDom(domNode) {
        return this._fromDom.get(domNode);
    }
    /**
     * Return the array of tuple (node, number) corresponding to the given VNode.
     *
     * @param node
     */
    toDomPoint(node) {
        return this._toDom.get(node) || [];
    }
    /**
     * Return the DOM Node corresponding to the given VNode.
     *
     * @param node
     */
    toDom(node) {
        const domNodes = [];
        for (const point of this._toDom.get(node) || []) {
            domNodes.push(point[0]);
        }
        return domNodes;
    }
    /**
     * Clear the map of all correspondances.
     *
     * @param [node]
     */
    clear(node) {
        if (node) {
            for (const point of this._toDom.get(node) || []) {
                const nodes = this._fromDom.get(point[0]);
                const index = nodes.indexOf(node);
                if (index !== -1) {
                    nodes.splice(index, 0);
                }
                if (nodes.length === 0) {
                    this._fromDom.delete(point[0]);
                }
            }
            this._toDom.delete(node);
        }
        else {
            this._fromDom.clear();
            this._toDom.clear();
        }
    }
}

// CONCATENATED MODULE: ./packages/utils/src/configuration.ts








async function parseElement(editor, element) {
    const parser = editor.plugins.get(Parser_Parser);
    const domParserEngine = parser.engines['dom/html'];
    if (!domParserEngine) {
        throw new Error('To use this parsing utils you must add the Html plugin.');
    }
    const parsedVNodes = await domParserEngine.parse(element);
    const domSelection = element.ownerDocument.getSelection();
    const anchorNode = domSelection.anchorNode;
    if (element === anchorNode || element.contains(anchorNode)) {
        const domMap = new DomMap_DomMap();
        // Construct DOM map from the parsing in order to parse the selection.
        for (const node of parsedVNodes) {
            domMap.set(node, element);
        }
        for (const [domNode, nodes] of domParserEngine.parsingMap) {
            for (const node of nodes) {
                domMap.set(node, domNode);
            }
        }
        const _locate = (domNode, domOffset) => {
            /**
             * Return a position in the VNodes as a tuple containing a reference
             * node and a relative position with respect to this node ('BEFORE' or
             * 'AFTER'). The position is always given on the leaf.
             *
             * @param container
             * @param offset
             */
            let forceAfter = false;
            let forcePrepend = false;
            let container = domNode.childNodes[domOffset] || domNode;
            let offset = container === domNode ? domOffset : 0;
            if (container === domNode && container.childNodes.length) {
                container = container.childNodes[container.childNodes.length - 1];
                offset = nodeLength(container);
                forceAfter = true;
            }
            while (!domMap.fromDom(container)) {
                forceAfter = false;
                forcePrepend = false;
                if (container.previousSibling) {
                    forceAfter = true;
                    container = container.previousSibling;
                    offset = nodeLength(container);
                }
                else {
                    forcePrepend = true;
                    offset = [].indexOf.call(container.parentNode.childNodes, container);
                    container = container.parentNode;
                }
            }
            // When targetting the end of a node, the DOM gives an offset that is
            // equal to the length of the container. In order to retrieve the last
            // descendent, we need to make sure we target an existing node, ie. an
            // existing index.
            const isAfterEnd = offset >= nodeLength(container);
            let index = isAfterEnd ? nodeLength(container) - 1 : offset;
            // Move to deepest child of container.
            while (container.hasChildNodes()) {
                const child = container.childNodes[index];
                if (!domMap.fromDom(child)) {
                    break;
                }
                container = child;
                index = isAfterEnd ? nodeLength(container) - 1 : 0;
                // Adapt the offset to be its equivalent within the new container.
                offset = isAfterEnd ? nodeLength(container) : index;
            }
            const nodes = domMap.fromDom(container);
            // Get the VNodes matching the container.
            let reference;
            if (container.nodeType === Node.TEXT_NODE) {
                // The reference is the index-th match (eg.: text split into chars).
                reference = forceAfter ? nodes[nodes.length - 1] : nodes[index];
            }
            else {
                reference = nodes[0];
            }
            if (forceAfter) {
                return [reference, RelativePosition.AFTER];
            }
            if (forcePrepend && reference instanceof ContainerNode_ContainerNode) {
                return [reference, RelativePosition.INSIDE];
            }
            return reference.locate(container, offset);
        };
        // Parse the dom selection into the description of a VSelection.
        const start = _locate(domSelection.anchorNode, domSelection.anchorOffset);
        const end = _locate(domSelection.focusNode, domSelection.focusOffset);
        const [startVNode, startPosition] = start;
        const [endVNode, endPosition] = end;
        let direction;
        if (domSelection instanceof Selection) {
            const domRange = domSelection.rangeCount && domSelection.getRangeAt(0);
            if (domRange.startContainer === domSelection.anchorNode &&
                domRange.startOffset === domSelection.anchorOffset) {
                direction = Direction.FORWARD;
            }
            else {
                direction = Direction.BACKWARD;
            }
        }
        const selection = {
            anchorNode: startVNode,
            anchorPosition: startPosition,
            focusNode: endVNode,
            focusPosition: endPosition,
            direction: direction,
        };
        editor.selection.set(selection);
        domMap.clear();
    }
    return parsedVNodes;
}
async function parseEditable(editor, element, autofocus = false) {
    const nodes = await parseElement(editor, element);
    nodes[0].editable = false;
    nodes[0].breakable = false;
    nodes[0].modifiers.get(Attributes_Attributes).set('contentEditable', 'true');
    if (autofocus && !editor.selection.anchor.parent) {
        if (nodes[0].hasChildren()) {
            editor.selection.setAt(nodes[0].firstChild(), RelativePosition.BEFORE);
        }
        else {
            editor.selection.setAt(nodes[0], RelativePosition.INSIDE);
        }
    }
    return nodes;
}
async function createEditable(editor, autofocus = false) {
    const root = new VElement_VElement({ htmlTag: 'jw-editable' });
    // Semantic elements are inline by default.
    // We need to guarantee it's a block so it can contain
    // other blocks.
    root.modifiers.get(Attributes_Attributes).set('style', 'display: block;');
    root.editable = false;
    root.breakable = false;
    root.modifiers.get(Attributes_Attributes).set('contentEditable', 'true');
    if (autofocus && !editor.selection.anchor.parent) {
        editor.selection.setAt(root, RelativePosition.INSIDE);
    }
    return [root];
}

// EXTERNAL MODULE: ./packages/plugin-fullscreen/assets/Fullscreen.css
var assets_Fullscreen = __webpack_require__(17);

// CONCATENATED MODULE: ./packages/plugin-fullscreen/src/FullscreenButtonDomObjectRenderer.ts






class FullscreenButtonDomObjectRenderer_FullscreenButtonDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = (node) => node instanceof ActionableNode_ActionableNode && node.actionName === 'fullscreen';
    }
    /**
     * Render the FullscreenNode.
     */
    async render(button, worker) {
        const domObject = (await this.super.render(button, worker));
        const fullscreenPlugin = this.engine.editor.plugins.get(Fullscreen_Fullscreen);
        const domLayoutEngine = this.engine.editor.plugins.get(Layout_Layout).engines
            .dom;
        let elButton;
        domObject.handler = () => {
            var _a;
            // only one component can be display in fullscreen
            const component = (_a = domLayoutEngine.components[fullscreenPlugin.configuration.component]) === null || _a === void 0 ? void 0 : _a[0];
            if (component) {
                // only one element can be display in fullscreen
                const element = domLayoutEngine.getDomNodes(component)[0];
                if (element instanceof Element) {
                    if (fullscreenPlugin.isFullscreen) {
                        element.classList.remove('jw-fullscreen');
                        elButton.classList.remove('pressed');
                        elButton.setAttribute('aria-pressed', 'false');
                    }
                    else {
                        fullscreenPlugin.isFullscreen = true;
                        document.body.classList.add('jw-fullscreen');
                        element.classList.add('jw-fullscreen');
                        elButton.classList.add('pressed');
                        elButton.setAttribute('aria-pressed', 'true');
                        window.dispatchEvent(new CustomEvent('resize'));
                        return;
                    }
                }
            }
            if (fullscreenPlugin.isFullscreen) {
                fullscreenPlugin.isFullscreen = false;
                document.body.classList.remove('jw-fullscreen');
                window.dispatchEvent(new CustomEvent('resize'));
            }
        };
        const attach = domObject.attach;
        // TODO: Replace these handlers by a `stop` mechanism for renderers.
        domObject.attach = function (el) {
            elButton = el;
            attach.call(this, el);
            if (fullscreenPlugin.isFullscreen) {
                document.body.classList.add('jw-fullscreen');
            }
        };
        const detach = domObject.detach;
        // TODO: Replace these handlers by a `stop` mechanism for renderers.
        domObject.detach = function (el) {
            elButton = null;
            detach.call(this, el);
            document.body.classList.remove('jw-fullscreen');
        };
        return domObject;
    }
}
FullscreenButtonDomObjectRenderer_FullscreenButtonDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-fullscreen/src/Fullscreen.ts




class Fullscreen_Fullscreen extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            renderers: [FullscreenButtonDomObjectRenderer_FullscreenButtonDomObjectRenderer],
            components: [
                {
                    id: 'FullscreenButton',
                    render: async () => {
                        const button = new ActionableNode_ActionableNode({
                            name: 'fullscreen',
                            label: 'Toggle Fullscreen',
                            selected: () => this.isFullscreen,
                            modifiers: [new Attributes_Attributes({ class: 'fas fa-expand fa-fw' })],
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [['FullscreenButton', ['actionables']]],
        };
        this.isFullscreen = false;
    }
}

// CONCATENATED MODULE: ./packages/plugin-code/src/CodeViewNode.ts

class CodeViewNode_CodeViewNode extends AtomicNode_AtomicNode {
    constructor() {
        super(...arguments);
        this.value = '';
    }
}

// CONCATENATED MODULE: ./packages/plugin-code/src/CodeViewDomObjectRenderer.ts



class CodeViewDomObjectRenderer_CodeViewDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = CodeViewNode_CodeViewNode;
    }
    async render(codeView) {
        const domCodeView = document.createElement('TEXTAREA');
        domCodeView.value = codeView.value;
        domCodeView.setAttribute('style', [
            'width: 100%',
            'height: 100%',
            'background-color: black',
            'color: white',
            'padding: 5px',
            'font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;',
        ].join('; '));
        return { dom: [domCodeView] };
    }
}
CodeViewDomObjectRenderer_CodeViewDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-code/src/Code.ts








class Code_Code extends JWPlugin {
    constructor() {
        super(...arguments);
        this.codeView = new CodeViewNode_CodeViewNode();
        this.loadables = {
            renderers: [CodeViewDomObjectRenderer_CodeViewDomObjectRenderer],
            components: [
                {
                    id: 'CodeButton',
                    render: async () => {
                        const button = new ActionableNode_ActionableNode({
                            name: 'code',
                            label: 'Toggle Code view',
                            commandId: 'toggleCodeView',
                            selected: () => this.active,
                            modifiers: [new Attributes_Attributes({ class: 'fas fa-code fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'code',
                    render: async () => {
                        return [this.codeView];
                    },
                },
            ],
            componentZones: [['CodeButton', ['actionables']]],
        };
        this.commands = {
            toggleCodeView: {
                handler: this.toggle.bind(this),
            },
        };
        this.active = false;
    }
    async start() {
        await super.start();
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    async toggle(params) {
        if (this.active) {
            return this.deactivate(params);
        }
        else {
            return this.activate(params);
        }
    }
    async activate(params) {
        this.active = true;
        const domLayoutEngine = this.editor.plugins.get(Layout_Layout).engines.dom;
        const editable = domLayoutEngine.components.editable[0];
        // Update the view's contents.
        const domEditable = domLayoutEngine.getDomNodes(editable)[0];
        this.codeView.value = this._formatElementHtml(domEditable).innerHTML.trim() || '';
        // Show the code view and hide the editable.
        await this.editor.plugins.get(Layout_Layout).append('code', 'main');
        await params.context.execCommand('hide', { componentId: 'editable' });
    }
    async deactivate(params) {
        this.active = false;
        const domLayoutEngine = this.editor.plugins.get(Layout_Layout).engines.dom;
        const editable = domLayoutEngine.components.editable[0];
        // Parse the code view into the editable.
        const codeContainer = document.createElement('div');
        codeContainer.innerHTML = domLayoutEngine.getDomNodes(this.codeView)[0].value;
        const newEditable = await parseEditable(this.editor, codeContainer);
        editable.empty();
        editable.append(...newEditable[0].children());
        // Show the editable and hide the code view.
        await params.context.execCommand('show', { componentId: 'editable' });
        await this.editor.plugins.get(Layout_Layout).remove('code', 'main');
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Format an element's inner HTML by recursively adding inner indentation
     * where it is relevant.
     *
     * @param element
     * @param [_level]
     */
    _formatElementHtml(element, _level = 0) {
        element = element.cloneNode(true);
        const indentBefore = new Array(_level + 1).join('    ');
        const indentAfter = new Array(_level).join('    ');
        for (const child of element.children) {
            const isChildBlock = isBlock(child);
            if (isChildBlock) {
                element.insertBefore(document.createTextNode('\n' + indentBefore), child);
            }
            this._formatElementHtml(child, _level + 1);
            if (isChildBlock && element.lastElementChild === child) {
                element.appendChild(document.createTextNode('\n' + indentAfter));
            }
        }
        return element;
    }
}

// CONCATENATED MODULE: ./packages/plugin-font-size/src/FontSizeDomObjectRenderer.ts






class FontSizeDomObjectRenderer_FontSizeDomObjectRenderer extends InputDomObjectRenderer_InputDomObjectRenderer {
    constructor() {
        super(...arguments);
        this.predicate = (node) => node instanceof InputNode_InputNode && node.inputName === 'font-size';
    }
    /**
     * @override
     */
    _onCommit(node, input) {
        var _a, _b;
        super._onCommit(node, input);
        const range = this.engine.editor.selection.range;
        const fontNodes = range.selectedNodes(CharNode_CharNode);
        const fontSize = fontNodes[0] && ((_b = (_a = fontNodes[0].modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.get('font-size'));
        input.style.display = 'block';
        if (fontSize) {
            input.value = parseInt(fontSize).toString();
        }
        else if (fontNodes[0]) {
            const layout = this.engine.editor.plugins.get(Layout_Layout);
            const domLayout = layout.engines.dom;
            const firstDomNode = domLayout.getDomNodes(fontNodes[0])[0];
            const firstDomElement = firstDomNode instanceof HTMLElement ? firstDomNode : firstDomNode.parentElement;
            const style = firstDomElement ? getComputedStyle(firstDomElement) : { 'font-size': '' };
            input.value = parseInt(style['font-size']).toString();
        }
        else {
            input.value = '';
            input.style.display = 'none';
        }
    }
}
FontSizeDomObjectRenderer_FontSizeDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-font-size/src/FontSize.ts






class FontSize_FontSize extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            renderers: [FontSizeDomObjectRenderer_FontSizeDomObjectRenderer],
            components: [
                {
                    id: 'FontSizeInput',
                    async render() {
                        const input = new InputNode_InputNode({
                            inputType: 'number',
                            inputName: 'font-size',
                            change: (editor) => {
                                editor.execCommand('setFontSize', { value: parseInt(input.value) });
                            },
                        });
                        return [input];
                    },
                },
            ],
        };
        this.commands = {
            setFontSize: {
                handler: this.setFontSize,
            },
        };
    }
    /**
     * Set the font size of the context range
     */
    setFontSize(params) {
        let nodes = [];
        if (!params.context.range.isCollapsed()) {
            nodes = params.context.range.targetedNodes(CharNode_CharNode);
        }
        for (const node of nodes) {
            node.modifiers.get(Attributes_Attributes).style.set('font-size', `${params.value}px`);
        }
    }
}
FontSize_FontSize.dependencies = [Input_Input];

// CONCATENATED MODULE: ./packages/bundle-basic-editor/BasicEditor.ts
















































class BasicEditor_BasicEditor extends src_JWEditor {
    constructor(params) {
        super();
        this.configure({
            defaults: {
                Container: ParagraphNode_ParagraphNode,
                Separator: LineBreakNode_LineBreakNode,
            },
            plugins: [
                [Parser_Parser],
                [Renderer_Renderer],
                [Layout_Layout],
                [Keymap_Keymap],
                [DomObjectRenderer_DomObjectRenderer],
                [Html_Html],
                [DomLayout_DomLayout],
                [DomEditable_DomEditable],
                [History_History],
                [Inline_Inline],
                [Char_Char],
                [LineBreak_LineBreak],
                [Heading_Heading],
                [Paragraph_Paragraph],
                [Textarea_Textarea],
                [List_List],
                [Indent_Indent],
                [FontSize_FontSize],
                [Span_Span],
                [Bold_Bold],
                [Italic_Italic],
                [Underline_Underline],
                [Link_Link],
                [Divider_Divider],
                [Image_Image],
                [Subscript_Subscript],
                [Superscript_Superscript],
                [Blockquote_Blockquote],
                [Youtube_Youtube],
                [Table_Table],
                [Metadata_Metadata],
                [Align_Align],
                [Pre_Pre],
                [TextColor_TextColor],
                [BackgroundColor_BackgroundColor],
                [Input_Input],
                [Dialog_Dialog],
                [FollowRange_FollowRange],
                [Fullscreen_Fullscreen, { component: 'editor' }],
                [OdooField_OdooField],
                [Code_Code],
            ],
        });
        const config = {
            loadables: {
                components: [
                    {
                        id: 'editor',
                        render(editor) {
                            return editor.plugins.get(Parser_Parser).parse('text/html', basicLayout_default.a);
                        },
                    },
                ],
                componentZones: [['editor', ['root']]],
            },
        };
        this.configure(config);
        this.configure(DomLayout_DomLayout, {
            location: (params === null || params === void 0 ? void 0 : params.editable) ? [params.editable, 'replace'] : null,
            components: [
                {
                    id: 'editable',
                    render: async (editor) => {
                        if (params === null || params === void 0 ? void 0 : params.editable) {
                            return parseEditable(editor, params.editable);
                        }
                        else {
                            return createEditable(editor);
                        }
                    },
                },
            ],
            componentZones: [['editable', ['main']]],
        });
        this.configure(Toolbar_Toolbar, {
            layout: [
                [
                    [
                        'ParagraphButton',
                        'Heading1Button',
                        'Heading2Button',
                        'Heading3Button',
                        'Heading4Button',
                        'Heading5Button',
                        'Heading6Button',
                        'PreButton',
                    ],
                ],
                ['FontSizeInput'],
                ['BoldButton', 'ItalicButton', 'UnderlineButton', 'RemoveFormatButton'],
                ['AlignLeftButton', 'AlignCenterButton', 'AlignRightButton', 'AlignJustifyButton'],
                ['OrderedListButton', 'UnorderedListButton', 'ChecklistButton'],
                ['IndentButton', 'OutdentButton'],
                ['LinkButton', 'UnlinkButton'],
                ['TableButton'],
                ['CodeButton'],
                ['UndoButton', 'RedoButton'],
            ],
        });
    }
}

// CONCATENATED MODULE: ./packages/plugin-owl/src/OwlDomObjectRenderer.ts




class OwlDomObjectRenderer_OwlDomObjectRenderer extends NodeRenderer {
    constructor(engine) {
        super(engine);
        this.predicate = OwlNode_OwlNode;
        this.env = this.engine.editor.plugins.get(Owl_Owl).env;
    }
    async render(node) {
        const components = this.engine.editor.plugins.get(Owl_Owl).components;
        const oldOwlComponent = components.get(node);
        const placeholder = document.createElement('jw-placeholer');
        document.body.appendChild(placeholder);
        node.params.Component.env = this.env;
        const component = new node.params.Component(null, node.params.props);
        components.set(node, component);
        await component.mount(placeholder);
        placeholder.remove();
        const domNodes = [...placeholder.childNodes];
        if (oldOwlComponent) {
            if (oldOwlComponent.el.parentNode) {
                for (const domNode of domNodes) {
                    oldOwlComponent.el.parentNode.insertBefore(domNode, oldOwlComponent.el);
                }
            }
            oldOwlComponent.destroy();
        }
        return {
            dom: domNodes,
        };
    }
}
OwlDomObjectRenderer_OwlDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-owl/src/Owl.ts



// Temporary fix waiting for the `Env` interface of Owl to let the `browser`
// property be optional
const browser = {
    setTimeout: window.setTimeout.bind(window),
    clearTimeout: window.clearTimeout.bind(window),
    setInterval: window.setInterval.bind(window),
    clearInterval: window.clearInterval.bind(window),
    requestAnimationFrame: window.requestAnimationFrame.bind(window),
    random: Math.random,
    Date: window.Date,
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    fetch: (window.fetch || (() => { })).bind(window),
    localStorage: window.localStorage,
};
class Owl_Owl extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            renderers: [OwlDomObjectRenderer_OwlDomObjectRenderer],
        };
        this.loaders = {
            owlTemplates: this._loadTemplates,
        };
        this.env = {
            qweb: new owl["QWeb"](),
            editor: this.editor,
            browser: browser,
        };
        this.components = new Map();
    }
    async stop() {
        for (const [, component] of this.components) {
            component.destroy();
        }
        this.components.clear();
    }
    _loadTemplates(templates) {
        for (const template of templates) {
            this.env.qweb.addTemplates(template);
        }
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/utils.ts
function argsRepr(args) {
    if (args === undefined)
        return '';
    return `{ ${Object.keys(args)
        .map(key => key + ': ' + args[key])
        .join(', ')} }`;
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/CommandsComponent.ts




class CommandsComponent_CommandsComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        this.state = {
            currentTab: 'queue',
            registry: this.env.editor.dispatcher.commands,
            selectedCommandIndex: null,
            selectedCommandIdentifier: null,
            selectedCommandImplementationIndex: null,
        };
        this.localStorage = ['currentTab'];
        this.argsRepr = argsRepr;
        this.stringifyPattern = this.env.editor.plugins.get(Keymap_Keymap).stringifyPattern;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Take a payload value and format it for display (mostly to ensure that
     * we can display it properly as a string).
     *
     * @param value
     */
    formatPayloadValue(value) {
        if (value && value instanceof Node && nodeName(value)) {
            return '<' + nodeName(value).toLowerCase() + '>';
        }
        return '' + value;
    }
    /**
     * Handle keydown event to navigate in the command stack.
     */
    onKeydown(event) {
        if (this.state.currentTab === 'queue') {
            if (event.code === 'ArrowDown') {
                this.state.selectedCommandIndex = Math.max(this.state.selectedCommandIndex - 1, 0);
            }
            else if (event.code === 'ArrowUp') {
                this.state.selectedCommandIndex = Math.min(this.state.selectedCommandIndex + 1, this.props.commands.length - 1);
            }
            else {
                return;
            }
        }
        else if (this.state.currentTab === 'registry') {
            const identifiers = Object.keys(this.state.registry).sort();
            const currentIndex = identifiers.indexOf(this.state.selectedCommandIdentifier);
            if (event.code === 'ArrowDown') {
                this.state.selectedCommandIdentifier =
                    identifiers[Math.min(currentIndex + 1, identifiers.length - 1)];
            }
            else if (event.code === 'ArrowUp') {
                this.state.selectedCommandIdentifier = identifiers[Math.max(currentIndex - 1, 0)];
            }
            else {
                return;
            }
        }
        event.preventDefault();
        event.stopImmediatePropagation();
    }
    /**
     * Open the tab with the given tabName.
     *
     * @param tabName
     */
    openTab(tabName) {
        this.state.currentTab = tabName;
    }
    /**
     * Select the command at given index.
     *
     * @param index
     */
    selectCommandByIndex(index) {
        this.state.selectedCommandIndex = index;
        this.state.selectedCommandIdentifier = this.props.commands[index][0];
    }
    /**
     * Select the command with given identifier.
     *
     * @param commandIdentifier
     */
    selectCommand(commandIdentifier) {
        this.state.selectedCommandIdentifier = commandIdentifier;
    }
    /**
     * Return the key mappings matching the given command identifier.
     *
     * @param commandIdentifier
     */
    matchingMappings(commandIdentifier) {
        return flat(this.env.editor.plugins.get(Keymap_Keymap).mappings).filter(mapping => mapping.configuredCommand.commandId === commandIdentifier);
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/InfoComponent.ts



class InfoComponent_InfoComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        this.aboutMeProps = ['id', 'name', 'length', 'atomic', 'modifiers'];
        this.familyProps = ['parent', 'children', 'siblings'];
        this.customPropsBlacklist = this.aboutMeProps.concat(this.familyProps).concat(['childVNodes']);
        this.state = {
            currentTab: 'vNode',
        };
        this.localStorage = ['currentTab'];
    }
    /**
     * Open the tab with the given `tabName`
     *
     * @param {string} tabName
     */
    openTab(tabName) {
        this.state.currentTab = tabName;
    }
    /**
     * Trigger a 'node-selected' custom event
     * with the given `vNode` to select it
     *
     * @param {VNode} vNode
     */
    selectNode(vNode) {
        this.trigger('node-selected', {
            vNode: vNode,
        });
    }
    /**
     * Return the name of the class of the given VNode.
     *
     * @param vNode
     */
    className(vNode) {
        return vNode.constructor.name;
    }
    /**
     * Return a string representing the contents of a property of a VNode.
     *
     * @param vNode
     * @param propName
     */
    propRepr(vNode, propName) {
        let prop = vNode[propName];
        if (propName === 'atomic') {
            if (vNode instanceof AtomicNode_AtomicNode) {
                return 'true';
            }
            else if (vNode instanceof ContainerNode_ContainerNode) {
                return 'false';
            }
            else {
                return '?';
            }
        }
        else if (propName === 'modifiers') {
            if (!vNode.modifiers.length)
                return '[]';
            return `[ ${vNode.modifiers.map(m => m.toString()).join(', ')} ]`;
        }
        else {
            if ({}.toString.call(prop) === '[object Function]') {
                prop = vNode[propName]();
            }
            return this._propRepr(prop);
        }
    }
    /**
     * Return an object representing the given VNode's public properties as
     * alphabetically sorted pairs of key and value strings.
     *
     * @param vNode
     */
    nodeProperties(vNode) {
        return Object.keys(vNode)
            .filter(key => !key.startsWith('_') && !this.customPropsBlacklist.includes(key))
            .sort()
            .map(key => {
            return { key: key, value: this._propRepr(vNode[key]) };
        });
    }
    /**
     * Return the length of this node and all its descendents.
     *
     * @param __current
     */
    totalLength(vNode, __current = 0) {
        __current += vNode.length;
        vNode.children().forEach((child) => {
            if (child.hasChildren()) {
                __current = this.totalLength(child, __current);
            }
        });
        return __current;
    }
    /**
     * Log a `VNode` to the console.
     *
     * @param vNode
     */
    logVNode(vNode) {
        console.log(vNode);
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    _repr(vNode) {
        const nextSibling = vNode.nextSibling();
        const prevSibling = vNode.previousSibling();
        const position = nextSibling ? 'BEFORE' : prevSibling ? 'AFTER' : 'INSIDE';
        const reference = nextSibling || prevSibling || vNode.parent;
        if (reference) {
            return `${position} ${reference.id} (${reference.name})`;
        }
        else {
            return 'Not in VDocument';
        }
    }
    /**
     * Return a string representing the contents of a property of a VNode.
     *
     * @param vNode
     * @param propName
     */
    _propRepr(prop) {
        let value = '' + prop;
        if (typeof prop === 'object') {
            if (Array.isArray(prop) && !prop.length) {
                value = '[]';
            }
            else if (prop === null) {
                value = 'null';
            }
            else if (prop === undefined) {
                value = 'undefined';
            }
            else if (prop instanceof Set) {
                const items = [];
                prop.forEach(item => {
                    items.push(item);
                });
                value = items.join('\n');
            }
            else if (!prop || !Object.keys(prop).length) {
                value = '{}';
            }
            else if (prop.toString === {}.toString) {
                value = this._objectRepr(prop);
            }
        }
        else if (typeof prop === 'string') {
            value = '"' + value + '"';
        }
        return value;
    }
    /**
     * Return a string representing all key/value pairs of an object.
     *
     * @param vNode
     * @param propName
     */
    _objectRepr(obj) {
        return Object.keys(obj)
            .filter(key => key !== 'toString')
            .map(key => {
            return key + ': ' + obj[key];
        })
            .join('\n');
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/PathComponent.ts


class PathComponent_PathComponent extends OwlComponent_OwlComponent {
    getNodeRepr(vNode) {
        let repr = vNode.name || '?';
        for (const format of vNode.modifiers.filter(Format_Format)) {
            repr += '.' + format.name;
        }
        return repr;
    }
    /**
     * Trigger a 'node-selected' custom event
     * with the given `vNode` to select it
     *
     * @param {VNode} vNode
     */
    selectNode(vNode) {
        this.trigger('node-selected', {
            vNode: vNode,
        });
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/TreeComponent.ts





/**
 * Note: `TreeComponent` requires three properties passed by the parent
 *       Component (`DevToolsComponent`) via the template (see `DevTools.xml`):
 *       - vNode: VNode
 *       - isRoot: boolean
 *       - selectedID: number (the ID of the selected VNode)
 */
class TreeComponent_TreeComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        // User-friendly representation of the node
        this._repr = this._getNodeRepr(this.props.vNode);
        this.state = {
            // Show the selected node and root by default
            folded: !this.props.isRoot && !this.props.selectedPath.includes(this.props.vNode),
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Update `state.folded` when `props.selectedPath` changes if `props.vNode`
     * is in `props.selectedPath`, unless it is the last item. Also update
     * `state.folded` for the ancestors of the selection marker nodes.
     */
    async willUpdateProps(nextProps) {
        // The selected node itself should stay folded even when selected. Only
        // the nodes in the path leading to it should actually be unfolded. By
        // construction, the last item of `selected path` is always the selected
        // node itself so it can safely be omitted from the check.
        const path = nextProps.selectedPath.slice(0, -1);
        if (path.some(node => node.id === nextProps.vNode.id)) {
            this.state.folded = false;
        }
        const selectionMarkersPath = this._getSelectionMarkersAncestors();
        if (selectionMarkersPath.has(nextProps.vNode.id)) {
            this.state.folded = false;
        }
    }
    /**
     * Handle a click event on a node of the tree: toggle its fold on click its
     * caret, select it otherwise
     *
     * @param {MouseEvent} event
     */
    onClickNode(event) {
        const didClickCaret = event.offsetX < 10;
        if (didClickCaret) {
            this.toggleFolded();
        }
        else {
            this.trigger('node-selected', {
                vNode: this.props.vNode,
            });
        }
    }
    onDblClickNode() {
        const location = {
            anchorNode: this.props.vNode,
            focusNode: this.props.vNode,
            direction: Direction.FORWARD,
        };
        this.env.editor.execCommand('setSelection', { vSelection: location });
    }
    /**
     * Handle folding/unfolding on press Enter
     *
     * @param {KeyboardEvent} event
     */
    onKeydown(event) {
        if (event.code === 'Enter') {
            event.preventDefault();
            this.toggleFolded();
            event.stopImmediatePropagation();
        }
    }
    repr() {
        if (this.props.vNode.tangible) {
            return this._repr;
        }
        else {
            // Representation of intangible nodes (e.g. markers) might change
            // depending on the context in which they are referenced, even
            // though they did not actually change per se.
            return this._getNodeRepr(this.props.vNode);
        }
    }
    /**
     * Unfold all of a node's direct ancestors on select it
     * TODO: find a way to do this cross-components
     *
     * @param {CustomEvent} event
     */
    selectNode(event) {
        if (event.detail.vNode.id !== this.props.vNode.id) {
            this.state.folded = false;
        }
    }
    /**
     * Toggle the `folded` propoerty of the state
     */
    toggleFolded() {
        this.state.folded = !this.state.folded;
    }
    /**
     * Return true if the given node has the given format.
     *
     * @param node
     */
    isFormat(node, formatName) {
        return (node instanceof InlineNode_InlineNode &&
            !!node.modifiers.find(format => format.name === formatName));
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Return a user-friendly representation of the node
     *
     * @param {VNode} node
     * @returns {string}
     */
    _getNodeRepr(node) {
        if (node === this.env.editor.selection.anchor) {
            return ANCHOR_CHAR;
        }
        if (node === this.env.editor.selection.focus) {
            return FOCUS_CHAR;
        }
        if (node.name) {
            return toUnicode(node.name).replace(/Node/, '');
        }
        return '?';
    }
    /**
     * Return a set of the IDs of all ancestors of both selection marker nodes.
     */
    _getSelectionMarkersAncestors() {
        const selectionMarkersAncestors = new Set();
        let ancestor = this.env.editor.selection.anchor.parent;
        while (ancestor) {
            selectionMarkersAncestors.add(ancestor.id);
            ancestor = ancestor.parent;
        }
        ancestor = this.env.editor.selection.focus.parent;
        while (ancestor) {
            selectionMarkersAncestors.add(ancestor.id);
            ancestor = ancestor.parent;
        }
        return selectionMarkersAncestors;
    }
}
// This is a recursive Component: each node of the tree is itself a tree
TreeComponent_TreeComponent.components = { TreeComponent: TreeComponent_TreeComponent };

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/InspectorComponent.ts








const hoverStyle = 'box-shadow: inset 0 0 0 100vh rgba(95, 146, 204, 0.5); cursor: pointer;';
class InspectorComponent_InspectorComponent extends OwlComponent_OwlComponent {
    constructor(parent, props) {
        var _a;
        super(parent, props);
        this.domEngine = this.env.editor.plugins.get(Layout_Layout).engines.dom;
        this._hoveredTargets = [];
        this.state = {
            selectedID: ((_a = this.domEngine.components.editable[0]) === null || _a === void 0 ? void 0 : _a.id) || this.domEngine.root.id,
        };
        this.selectedNode = this.getNode(this.state.selectedID);
        this._inspecting = new Set();
        this._onInspectorMouseEnter = this._onInspectorMouseEnter.bind(this);
        this._onInspectorMouseMove = this._onInspectorMouseMove.bind(this);
        this._onInspectorMouseLeave = this._onInspectorMouseLeave.bind(this);
        this._onInspectorMouseDown = this._onInspectorMouseDown.bind(this);
        this._onInspectorClick = this._onInspectorClick.bind(this);
    }
    willUnmount() {
        this._hoveredTargets = [];
        this.selectedNode = null;
    }
    async render(force = false) {
        var _a;
        await super.render(force);
        (_a = this.el.querySelector('devtools-nodename.selected')) === null || _a === void 0 ? void 0 : _a.scrollIntoView();
    }
    /**
     * Handle keyboard navigation in DevTools (arrows to move in the tree)
     *
     * @param {KeyboardEvent} event
     */
    onKeydown(event) {
        const selected = this.getNode(this.state.selectedID);
        let newSelection;
        switch (event.code) {
            case 'ArrowDown':
                newSelection = selected.nextSibling() || selected.firstChild();
                break;
            case 'ArrowUp':
                newSelection = selected.previousSibling() || selected.parent;
                break;
            case 'ArrowLeft':
                newSelection = selected.previousSibling();
                break;
            case 'ArrowRight':
                newSelection = selected.nextSibling();
                break;
            default:
                return;
        }
        if (newSelection) {
            event.preventDefault();
            this.state.selectedID = newSelection.id;
            this.selectedNode = this.getNode(this.state.selectedID);
        }
    }
    /**
     * Handle the selection of a node. A subcomponent triggers a 'select-node'
     * custom event and this method listens to it, retrieves the `vNode` that it
     * passes in its `detail` key, and modifies its state to account for the
     * change in selection.
     *
     * @param {CustomEvent} event
     * @param {VNode} event.detail.vNode
     */
    selectNode(event) {
        this.state.selectedID = event.detail.vNode.id;
        this.selectedNode = this.getNode(this.state.selectedID);
    }
    getNode(id) {
        return this.domEngine.root.descendants(node => node.id === id)[0] || this.domEngine.root;
    }
    /**
     * Return the path between the given `vNode` and the root vNode, as an array
     * of VNode, sorted from the highest parent (the root) to the given vNode.
     *
     * @param {VNode} vNode
     * @returns {VNode []}
     */
    getPath(vNode) {
        const path = [vNode];
        let parent = vNode.parent;
        while (parent) {
            path.unshift(parent);
            parent = parent.parent;
        }
        return path;
    }
    patched() {
        super.patched();
        const selected = this.el.querySelector('.selected');
        if (selected) {
            //selected.scrollIntoView();
        }
    }
    /**
     * Bind mouse handler to allow the selection of the node in the devtools inspector.
     * When the mouse will move, we add a class to highlight the targeted node (linked to VNode).
     * Will be unbind when the user click inside the dom.
     *
     * @param ev
     */
    inspectDom(doc = document) {
        if (!this._inspecting.has(doc)) {
            this._inspecting.add(doc);
            doc.addEventListener('mouseenter', this._onInspectorMouseEnter, true);
            doc.addEventListener('mousemove', this._onInspectorMouseMove, true);
            doc.addEventListener('mouseleave', this._onInspectorMouseLeave, true);
            doc.addEventListener('mousedown', this._onInspectorMouseDown, true);
            doc.addEventListener('click', this._onInspectorClick, true);
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    async _onInspectorMouseEnter(ev) {
        var _a;
        const el = ev.target;
        if (nodeName(el) === 'IFRAME') {
            const doc = (_a = ev.target.contentWindow) === null || _a === void 0 ? void 0 : _a.document;
            if (doc) {
                this.inspectDom(doc);
            }
        }
        else if (el.shadowRoot) {
            this.inspectDom(el.shadowRoot);
        }
    }
    /**
     * Add a class to highlight the targeted node (like to VNode).
     *
     * @param ev
     */
    async _onInspectorMouseMove(ev) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
        for (const inspected of this._hoveredTargets) {
            inspected.element.setAttribute('style', inspected.oldStyle);
        }
        this._hoveredTargets = [];
        const elements = [];
        for (const node of this._getNodeFromPosition(ev.clientX, ev.clientY, ev.target.ownerDocument)) {
            for (const domNode of this.domEngine.getDomNodes(node)) {
                const element = domNode instanceof HTMLElement ? domNode : domNode.parentElement;
                if (!elements.includes(element)) {
                    elements.push(element);
                }
            }
        }
        for (const element of elements) {
            const style = element.getAttribute('style') || '';
            this._hoveredTargets.push({
                element: element,
                oldStyle: style,
            });
            element.setAttribute('style', style + ';' + hoverStyle);
        }
    }
    /**
     * remove class to remove the highlight.
     *
     * @param ev
     */
    _onInspectorMouseLeave(ev) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
        for (const inspected of this._hoveredTargets) {
            if (inspected.element === ev.target) {
                this._hoveredTargets.splice(this._hoveredTargets.indexOf(inspected), 1);
                inspected.element.setAttribute('style', inspected.oldStyle);
            }
        }
    }
    /**
     * Prevent default behavior (domEditable normalisation).
     *
     * @param ev
     */
    _onInspectorMouseDown(ev) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
    }
    _getNodeFromPosition(clientX, clientY, doc) {
        const caretPosition = caretPositionFromPoint(clientX, clientY, doc);
        let node = caretPosition === null || caretPosition === void 0 ? void 0 : caretPosition.offsetNode;
        let nodes = [];
        while (!nodes.length && node) {
            nodes = this.domEngine.getNodes(node);
            node = node.parentNode;
        }
        if (nodes[0] instanceof CharNode_CharNode && nodes[caretPosition.offset]) {
            return [nodes[caretPosition.offset]];
        }
        return nodes;
    }
    /**
     * Select the targeted node in the devtools inspector and unbind the mouse handler
     *
     * @param ev
     */
    async _onInspectorClick(ev) {
        for (const doc of this._inspecting) {
            doc.removeEventListener('mouseenter', this._onInspectorMouseEnter, true);
            doc.removeEventListener('mousemove', this._onInspectorMouseMove, true);
            doc.removeEventListener('mouseleave', this._onInspectorMouseLeave, true);
            doc.removeEventListener('mousedown', this._onInspectorMouseDown, true);
            doc.removeEventListener('click', this._onInspectorClick, true);
        }
        this._inspecting.clear();
        ev.stopImmediatePropagation();
        ev.preventDefault();
        for (const inspected of this._hoveredTargets) {
            inspected.element.setAttribute('style', inspected.oldStyle);
        }
        this._hoveredTargets = [];
        const nodes = this._getNodeFromPosition(ev.clientX, ev.clientY, ev.target.ownerDocument);
        if (nodes.length) {
            this.state.selectedID = nodes[0].id;
            this.selectedNode = this.getNode(this.state.selectedID);
        }
    }
}
InspectorComponent_InspectorComponent.components = { InfoComponent: InfoComponent_InfoComponent, PathComponent: PathComponent_PathComponent, TreeComponent: TreeComponent_TreeComponent };

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/ShortcutsComponent.ts




class ShortcutsComponent_ShortcutsComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        this.mappings = flat(this.env.editor.plugins.get(Keymap_Keymap).mappings).sort((a, b) => {
            if (a.configuredCommand.commandId < b.configuredCommand.commandId)
                return -1;
            if (a.configuredCommand.commandId > b.configuredCommand.commandId)
                return 1;
            return 0;
        });
        this.localStorage = ['currentTab'];
        this.argsRepr = argsRepr;
        this.stringifyPattern = this.env.editor.plugins.get(Keymap_Keymap).stringifyPattern;
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/PluginsComponent.ts

class PluginsComponent_PluginsComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        this.plugins = Array.from(this.env.editor.plugins.values())
            .map(plugin => plugin.constructor.name)
            .sort();
        this.localStorage = ['currentTab'];
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/ModesComponent.ts

class ModesComponent_ModesComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        this.modes = this.env.editor.modes;
        this.localStorage = ['currentTab'];
        this.state = {
            selectedMode: null,
            currentMode: this.env.editor.mode,
        };
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Select the mode at given index.
     *
     * @param index
     */
    selectModeByIndex(index) {
        this.state.selectedMode = this.modes[Object.keys(this.modes)[index]];
    }
    /**
     * Select the mode with given identifier.
     *
     * @param modeIdentifier
     */
    selectMode(modeIdentifier) {
        this.state.selectedMode = this.modes[modeIdentifier];
    }
    /**
     * Handle keydown event to navigate in the modes list.
     */
    onKeydown(event) {
        const modeIdentifiers = Object.keys(this.modes);
        const currentModeIndex = modeIdentifiers.findIndex(key => key === this.state.selectedMode.id);
        if (event.code === 'ArrowDown') {
            this.selectModeByIndex(Math.min(currentModeIndex + 1, modeIdentifiers.length - 1));
        }
        else if (event.code === 'ArrowUp') {
            this.selectModeByIndex(Math.max(currentModeIndex - 1, 0));
        }
        else {
            return;
        }
        event.preventDefault();
        event.stopImmediatePropagation();
    }
    setMode(modeIdentifier) {
        this.env.editor.setMode(modeIdentifier);
        this.state.currentMode = this.env.editor.mode;
    }
    /**
     * Log a selector to the console.
     *
     * @param selector
     */
    logSelector(selector) {
        console.log(selector);
    }
}

// CONCATENATED MODULE: ./packages/plugin-devtools/src/components/DevToolsComponent.ts








class DevToolsComponent_DevToolsComponent extends OwlComponent_OwlComponent {
    constructor() {
        super(...arguments);
        this.inspectorRef = owl["hooks"].useRef('inspector');
        this.state = {
            closed: true,
            currentTab: 'inspector',
            height: 300,
            commands: [],
        };
        this.localStorage = ['closed', 'currentTab', 'height'];
    }
    async willStart() {
        this.env.editor.dispatcher.registerCommandHook('*', this.addCommand.bind(this));
        this.env.editor.dispatcher.registerCommandHook('@commit', this.render.bind(this));
        return super.willStart();
    }
    willUnmount() {
        this.state.commands = [];
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Open the tab with the given `tabName`
     *
     * @param {string} tabName
     */
    openTab(tabName) {
        this.state.currentTab = tabName;
    }
    /**
     * Bind mouse handler to allow the selection of the node in the devtools inspector.
     * When the mouse will move, we add a class to highlight the targeted node (linked to VNode).
     * Will be unbind when the user click inside the dom.
     *
     * @param ev
     */
    inspectDom() {
        var _a;
        this.state.currentTab = 'inspector';
        (_a = this.inspectorRef.comp) === null || _a === void 0 ? void 0 : _a.inspectDom();
    }
    /**
     * Add the recent dispatching of the given command with the given arguments.
     */
    addCommand(params, id) {
        this.state.commands.push([id, params]);
    }
    /**
     * Drag the DevTools to resize them
     *
     * @param {MouseEvent} event
     */
    startResize(event) {
        event.preventDefault();
        this._heightOnLastMousedown = this.state.height;
        if (this.state.closed) {
            return; // Do not resize if the DevTools are closed
        }
        const startY = event instanceof MouseEvent ? event.pageY : event.targetTouches[0].pageY; // Y position of the mousedown
        /**
         * Perform the resizing on every mouse mouvement
         *
         * @param ev
         */
        const doResize = (ev) => {
            const currentY = ev instanceof MouseEvent ? ev.pageY : ev.targetTouches[0].pageY;
            const offset = startY - currentY;
            this.state.height = this._heightOnLastMousedown + offset;
        };
        /**
         * Stop resizing on mouse up
         */
        const stopResize = () => {
            window.removeEventListener('mousemove', doResize, false);
            window.removeEventListener('mouseup', stopResize, false);
            window.removeEventListener('touchmove', doResize, false);
            window.removeEventListener('touchend', stopResize, false);
        };
        window.addEventListener('mousemove', doResize);
        window.addEventListener('mouseup', stopResize);
        window.addEventListener('touchmove', doResize);
        window.addEventListener('touchend', stopResize);
    }
    /**
     * Toggle the `closed` state of the DevTools (only on a simple click: not
     * if some resizing occurred between mousedown and mouseup)
     */
    toggleClosed(event) {
        const didJustResize = this._heightOnLastMousedown !== this.state.height;
        const isOnButton = nodeName(event.target) === 'DEVTOOLS-BUTTON';
        if (!didJustResize && !(isOnButton && !this.state.closed)) {
            this.state.closed = !this.state.closed;
        }
    }
}
DevToolsComponent_DevToolsComponent.components = {
    CommandsComponent: CommandsComponent_CommandsComponent,
    InspectorComponent: InspectorComponent_InspectorComponent,
    ShortcutsComponent: ShortcutsComponent_ShortcutsComponent,
    PluginsComponent: PluginsComponent_PluginsComponent,
    ModesComponent: ModesComponent_ModesComponent,
};
DevToolsComponent_DevToolsComponent.template = 'devtools';

// EXTERNAL MODULE: ./packages/plugin-devtools/assets/DevTools.xml
var assets_DevTools = __webpack_require__(6);
var DevTools_default = /*#__PURE__*/__webpack_require__.n(assets_DevTools);

// EXTERNAL MODULE: ./packages/plugin-devtools/assets/DevTools.css
var plugin_devtools_assets_DevTools = __webpack_require__(19);

// CONCATENATED MODULE: ./packages/plugin-devtools/src/DevTools.ts








class DevTools_DevTools extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            components: [
                {
                    id: 'devTools',
                    async render() {
                        return [new OwlNode_OwlNode({ Component: DevToolsComponent_DevToolsComponent, props: {} })];
                    },
                },
            ],
            componentZones: [['devTools', ['debug']]],
            owlTemplates: [DevTools_default.a],
        };
    }
}
DevTools_DevTools.dependencies = [Owl_Owl, DomObjectRenderer_DomObjectRenderer, DomLayout_DomLayout];

// CONCATENATED MODULE: ./packages/plugin-odoo-video/src/OdooVideoNode.ts

class OdooVideoNode_OdooVideoNode extends AtomicNode_AtomicNode {
    constructor(params) {
        super(params);
        this.src = params.src;
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo-video/src/OdooVideoXmlDomParser.ts




class OdooVideoXmlDomParser_OdooVideoXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (node) => {
            const isVideo = node instanceof Element &&
                nodeName(node) === 'DIV' &&
                node.classList.contains('media_iframe_video') &&
                node.attributes['data-oe-expression'] &&
                node.attributes['data-oe-expression'].value;
            return isVideo;
        };
    }
    async parse(element) {
        const video = new OdooVideoNode_OdooVideoNode({ src: element.attributes['data-oe-expression'].value });
        video.modifiers.append(this.engine.parseAttributes(element));
        return [video];
    }
}
OdooVideoXmlDomParser_OdooVideoXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-odoo-video/src/OdooVideoDomObjectRenderer.ts




class OdooVideoDomObjectRenderer_OdooVideoHtmlDomRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = OdooVideoNode_OdooVideoNode;
    }
    async render(node) {
        const setSelection = () => {
            this.engine.editor.execCommand('setSelection', {
                vSelection: {
                    anchorNode: node,
                    direction: Direction.FORWARD,
                },
            });
        };
        const openMedia = () => {
            this.engine.editor.execCommand('openMedia');
        };
        const wrapper = {
            tag: 'DIV',
            attributes: {
                class: new Set(['media_iframe_video']),
                'data-oe-expression': node.src,
            },
            children: [
                {
                    tag: 'DIV',
                    attributes: { class: new Set(['css_editable_mode_display']) },
                    children: [{ text: '\u00A0' }],
                    attach: (el) => {
                        el.addEventListener('click', setSelection);
                        el.addEventListener('dblclick', openMedia);
                    },
                    detach: (el) => {
                        el.removeEventListener('click', setSelection);
                        el.removeEventListener('dblclick', openMedia);
                    },
                },
                {
                    tag: 'DIV',
                    attributes: { class: new Set(['media_iframe_video_size']) },
                    children: [{ text: '\u00A0' }],
                },
                {
                    tag: 'IFRAME',
                    attributes: {
                        src: node.src,
                        frameborder: '0',
                        allowfullscreen: 'allowfullscreen',
                    },
                },
            ],
        };
        return wrapper;
    }
}
OdooVideoDomObjectRenderer_OdooVideoHtmlDomRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-odoo-video/src/OdooVideo.ts



class OdooVideo_OdooVideo extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [OdooVideoXmlDomParser_OdooVideoXmlDomParser],
            renderers: [OdooVideoDomObjectRenderer_OdooVideoHtmlDomRenderer],
        };
    }
}

// CONCATENATED MODULE: ./packages/plugin-dom-helpers/src/DomHelpers.ts








function getAllAttributesModifiers(modifiers) {
    return flat(modifiers
        .filter(modifier => modifier instanceof Attributes_Attributes || modifier instanceof Format_Format)
        .map((modifier) => {
        if (modifier instanceof Format_Format) {
            return getAllAttributesModifiers(modifier.modifiers);
        }
        else {
            return [modifier];
        }
    }));
}
class DomHelpers_DomHelpers extends JWPlugin {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Add a class or a list of classes to a DOM node or a list of DOM nodes.
     *
     * @param params
     */
    async addClass(context, domNode, className) {
        return context.execCommand(async () => {
            const classes = Array.isArray(className) ? className : [className];
            for (const node of this.getNodes(domNode)) {
                node.modifiers.get(Attributes_Attributes).classList.add(...classes);
            }
        });
    }
    /**
     * Remove a class or a list of classes from a DOM node or a list of DOM nodes.
     *
     * @param params
     */
    async removeClass(context, domNode, className) {
        return context.execCommand(async () => {
            const classes = Array.isArray(className) ? className : [className];
            for (const node of this.getNodes(domNode)) {
                if (node.modifiers) {
                    const modifiers = getAllAttributesModifiers(node.modifiers);
                    for (const modifier of modifiers) {
                        modifier.classList.remove(...classes);
                    }
                }
            }
        });
    }
    /**
     * Add or remove a class or a list of classes from a DOM node or a list of
     * DOM nodes.
     *
     * @param params
     */
    async toggleClass(context, domNode, className) {
        return context.execCommand(async () => {
            const classes = Array.isArray(className) ? className : [className];
            for (const node of this.getNodes(domNode)) {
                node.modifiers.get(Attributes_Attributes).classList.toggle(...classes);
            }
        });
    }
    /**
     * Set an attribute on a DOM node or a list of DOM nodes.
     *
     * @param params
     */
    async setAttribute(context, domNode, name, value) {
        return context.execCommand(async () => {
            for (const node of this.getNodes(domNode)) {
                node.modifiers.get(Attributes_Attributes).set(name, value);
            }
        });
    }
    /**
     * Update the attributes with the given dictionnary and clear all previous
     * attributes.
     */
    async updateAttributes(context, domNode, attributes) {
        return context.execCommand(async () => {
            for (const node of this.getNodes(domNode)) {
                node.modifiers.get(Attributes_Attributes).clear();
                for (const [name, value] of Object.entries(attributes)) {
                    node.modifiers.get(Attributes_Attributes).set(name, value);
                }
            }
        });
    }
    /**
     * Set a style key/value pair on a DOM node or a list of DOM nodes.
     *
     * @param params
     */
    async setStyle(context, domNode, name, value, important) {
        return context.execCommand(async () => {
            for (const node of this.getNodes(domNode)) {
                value = important ? value + ' !important' : value;
                node.modifiers.get(Attributes_Attributes).style.set(name, value);
            }
        });
    }
    /**
     * Remove a DOM node or a list of DOM nodes.
     *
     * @param params
     */
    async remove(context, domNode) {
        return context.execCommand(async () => {
            for (const node of this.getNodes(domNode)) {
                node.remove();
            }
        });
    }
    /**
     * Remove the contents of a DOM node or of a list of DOM nodes.
     *
     * @param params
     */
    async empty(context, domNode) {
        return context.execCommand(async () => {
            for (const node of this.getNodes(domNode)) {
                node.empty();
            }
        });
    }
    /**
     * Replace a DOM node or a list of DOM nodes with the given HTML content.
     *
     * @param params
     */
    async replace(context, domNodes, html) {
        return context.execCommand(async () => {
            const nodes = this.getNodes(domNodes);
            const parsedNodes = await this._parseHtmlString(html);
            const firstNode = nodes[0];
            for (const parsedNode of parsedNodes) {
                firstNode.before(parsedNode);
            }
            for (const node of nodes) {
                node.remove();
            }
        });
    }
    /**
     * Wrap the given HTML content within a DOM container.
     *
     * @param params
     */
    async wrap(context, domContainer, html) {
        return context.execCommand(async () => {
            const container = this.getNodes(domContainer)[0];
            if (!(container instanceof ContainerNode_ContainerNode)) {
                throw new Error('The provided container must be a ContainerNode in the Jabberwock structure.');
            }
            const parsedNodes = await this._parseHtmlString(html);
            for (const parsedNode of parsedNodes) {
                container.wrap(parsedNode);
            }
        });
    }
    /**
     * Move a DOM Node before another.
     *
     * @param params
     */
    async moveBefore(context, fromDomNode, toDomNode) {
        return context.execCommand(async () => {
            const toNode = this.getNodes(toDomNode)[0];
            for (const fromNode of this.getNodes(fromDomNode)) {
                fromNode.before(toNode);
            }
        });
    }
    /**
     * Move a DOM Node after another.
     *
     * @param params
     */
    async moveAfter(context, fromDomNode, toDomNode) {
        return context.execCommand(async () => {
            const toNodes = this.getNodes(toDomNode);
            const toNode = toNodes[toNodes.length - 1];
            for (const fromNode of this.getNodes(fromDomNode).reverse()) {
                fromNode.after(toNode);
            }
        });
    }
    /**
     * Prepend a DOM Node inside the child of another.
     *
     * @param params
     */
    async prepend(fromDomNode, toDomNode) {
        return this.editor.execCommand(async () => {
            const toNodes = this.getNodes(toDomNode);
            const toNode = toNodes[toNodes.length - 1];
            for (const fromNode of this.getNodes(fromDomNode).reverse()) {
                fromNode.prepend(toNode);
            }
        });
    }
    /**
     * Insert html content before, after or inside a DOM Node. If no DOM Node
     * was provided, empty the range and insert the html content before the it.
     *
     * @param params
     */
    async insertHtml(context, html, domNode, position) {
        let parsedNodes;
        await context.execCommand(async () => {
            let nodes;
            if (domNode) {
                nodes = this.getNodes(domNode);
                if (!nodes.length) {
                    throw new Error('The given DOM node does not have a corresponding VNode.');
                }
                position = position || RelativePosition.BEFORE;
            }
            else {
                this.editor.selection.range.empty();
                nodes = [this.editor.selection.range.start];
                position = RelativePosition.BEFORE;
            }
            parsedNodes = await this._parseHtmlString(html);
            switch (position.toUpperCase()) {
                case RelativePosition.BEFORE:
                    for (const parsedNode of parsedNodes) {
                        nodes[0].before(parsedNode);
                    }
                    break;
                case RelativePosition.AFTER:
                    for (const parsedNode of [...parsedNodes].reverse()) {
                        nodes[nodes.length - 1].after(parsedNode);
                    }
                    break;
                case RelativePosition.INSIDE:
                    for (const parsedNode of [...parsedNodes]) {
                        nodes[nodes.length - 1].append(parsedNode);
                    }
                    break;
            }
        });
        return parsedNodes;
    }
    /**
     * Return the `VNode`(s) matching a DOM Node or a list of DOM Nodes.
     *
     * @param domNode
     */
    getNodes(domNode) {
        const layout = this.editor.plugins.get(Layout_Layout);
        const domEngine = layout.engines.dom;
        let nodes = [];
        if (Array.isArray(domNode)) {
            for (const oneDomNode of domNode) {
                nodes.push(...domEngine.getNodes(oneDomNode));
            }
        }
        else {
            nodes = domEngine.getNodes(domNode);
        }
        return nodes;
    }
    /**
     * Return the DOM Node(s) matching a VNode or a list of VNodes.
     *
     * @param node
     */
    getDomNodes(node) {
        const layout = this.editor.plugins.get(Layout_Layout);
        const domEngine = layout.engines.dom;
        let domNodes = [];
        if (Array.isArray(node)) {
            for (const oneNode of node) {
                domNodes.push(...domEngine.getDomNodes(oneNode));
            }
        }
        else {
            domNodes = domEngine.getDomNodes(node);
        }
        return domNodes;
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Parse an HTML string and return the resulting `VNodes`.
     *
     * @param html
     */
    async _parseHtmlString(html) {
        const parser = this.editor.plugins.get(Parser_Parser);
        const div = document.createElement('div');
        div.innerHTML = html;
        return parser.parse('dom/html', ...div.childNodes);
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo/src/OdooStructureNode.ts

class OdooStructureNode_OdooStructureNode extends VElement_VElement {
    constructor(params) {
        super(params);
        this.breakable = false;
        this.xpath = params.xpath;
        this.viewId = params.viewId;
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo/src/OdooStructureXmlDomParser.ts




class OdooStructureXmlDomParser_OdooStructureXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return (item instanceof Element &&
                item.classList.contains('oe_structure') &&
                item.attributes &&
                item.attributes['data-oe-xpath'] &&
                item.attributes['data-oe-id']);
        };
    }
    /**
     * Parse a structure node.
     *
     * @param item
     */
    async parse(item) {
        const odooStructure = new OdooStructureNode_OdooStructureNode({
            htmlTag: nodeName(item),
            xpath: item.attributes['data-oe-xpath'].value,
            viewId: item.attributes['data-oe-id'].value,
        });
        odooStructure.modifiers.append(this.engine.parseAttributes(item));
        const children = await this.engine.parse(...item.childNodes);
        odooStructure.append(...children);
        return [odooStructure];
    }
}
OdooStructureXmlDomParser_OdooStructureXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-odoo/src/OdooImageDomObjectRenderer.ts


class OdooImageDomObjectRenderer_OdooImageDomObjectRenderer extends ImageDomObjectRenderer_ImageDomObjectRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ImageNode_ImageNode;
    }
    async render(node, worker) {
        const image = await this.super.render(node, worker);
        if (image && 'tag' in image) {
            const savedAttach = image.attach;
            const savedDetach = image.detach;
            const handleClick = () => {
                const params = { image: node };
                this.engine.editor.execCommand('openMedia', params);
            };
            image.attach = (el) => {
                if (savedAttach) {
                    savedAttach(el);
                }
                el.addEventListener('dblclick', handleClick);
            };
            image.detach = (el) => {
                if (savedDetach) {
                    savedDetach(el);
                }
                el.removeEventListener('dblclick', handleClick);
            };
        }
        return image;
    }
}

// CONCATENATED MODULE: ./packages/plugin-fontawesome/src/FontAwesomeNode.ts

class FontAwesomeNode_FontAwesomeNode extends InlineNode_InlineNode {
    constructor(params) {
        super(params);
        this.htmlTag = params.htmlTag;
    }
}
FontAwesomeNode_FontAwesomeNode.atomic = true;

// CONCATENATED MODULE: ./packages/plugin-fontawesome/src/FontAwesomeDomObjectRenderer.ts



const zeroWidthSpace = '\u200b';
class FontAwesomeDomObjectRenderer_FontAwesomeDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = FontAwesomeNode_FontAwesomeNode;
    }
    async render(node, worker) {
        const fontawesome = { tag: node.htmlTag };
        // Surround the fontawesome with two invisible characters so the
        // selection can navigate around it.
        const domObject = {
            children: [
                // We are targetting the invisible character BEFORE the
                // fontawesome node.
                // If offset 1:
                // Moving from before the fontawesome node to after it.
                // (DOM is `<invisible/>[]<fontawesome/><invisible/>` but
                // should be `<invisible/><fontawesome/><invisible/>[]`).
                // else:
                // Stay before the fontawesome node.
                { text: zeroWidthSpace },
                // If we are targetting the fontawesome directyle then stay
                // before the fontawesome node.
                fontawesome,
                // We are targetting the invisible character AFTER the
                // fontawesome node.
                // If offset 0:
                // Moving from after the fontawesome node to before it.
                // (DOM is `<invisible/><fontawesome/>[]<invisible/>` but
                // should be `[]<invisible/><fontawesome/><invisible/>`).
                // else:
                // Stay after the fontawesome node.
                { text: zeroWidthSpace },
            ],
        };
        worker.locate([node], domObject.children[0]);
        worker.locate([node], fontawesome);
        worker.locate([node], domObject.children[2]);
        return domObject;
    }
}
FontAwesomeDomObjectRenderer_FontAwesomeDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-odoo/src/OdooFontAwesomeDomObjectRenderer.ts


class OdooFontAwesomeDomObjectRenderer_OdooFontAwesomeDomObjectRenderer extends FontAwesomeDomObjectRenderer_FontAwesomeDomObjectRenderer {
    constructor() {
        super(...arguments);
        this.predicate = FontAwesomeNode_FontAwesomeNode;
    }
    async render(node, worker) {
        const domObject = await super.render(node, worker);
        if (domObject && 'children' in domObject) {
            const fa = domObject.children[1];
            if ('tag' in fa) {
                const savedAttach = fa.attach;
                fa.attach = (el) => {
                    if (savedAttach) {
                        savedAttach(el);
                    }
                    el.addEventListener('dblclick', () => {
                        const params = { image: node };
                        this.engine.editor.execCommand('openMedia', params);
                    });
                };
            }
        }
        return domObject;
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo/src/OdooTranslationFormat.ts


class OdooTranslationFormat_OdooTranslationFormat extends Format_Format {
    constructor(htmlTag, translationId) {
        super(htmlTag);
        this.breakable = false;
        this.translationId = translationId;
    }
    get name() {
        return `OdooTranslation: ${super.name}`;
    }
    // TODO: Attributes on OdooTranslation should reactively read the values set
    // on the node itself rather than having to manually synchronize them.
    get translationId() {
        var _a;
        return (_a = this.modifiers.find(Attributes_Attributes)) === null || _a === void 0 ? void 0 : _a.get('data-oe-translation-id');
    }
    set translationId(translationId) {
        this.modifiers.get(Attributes_Attributes).set('data-oe-translation-id', translationId);
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * @override
     */
    clone() {
        const clone = super.clone();
        clone.translationId = this.translationId;
        return clone;
    }
}

// CONCATENATED MODULE: ./packages/plugin-odoo/src/OdooTranslationXmlDomParser.ts





class OdooTranslationXmlDomParser_OdooTranslationXmlDomParser extends FormatXmlDomParser_FormatXmlDomParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && item.attributes['data-oe-translation-state'];
        };
    }
    /**
     * Parse a translation node.
     *
     * @param item
     */
    async parse(item) {
        const odooTranslation = new OdooTranslationFormat_OdooTranslationFormat(nodeName(item), item.getAttribute('data-oe-translation-id'));
        odooTranslation.modifiers.replace(Attributes_Attributes, this.engine.parseAttributes(item));
        const children = await this.engine.parse(...item.childNodes);
        this.applyFormat(odooTranslation, children);
        return children;
    }
}
OdooTranslationXmlDomParser_OdooTranslationXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-odoo/src/Odoo.ts














var OdooPaddingClasses;
(function (OdooPaddingClasses) {
    OdooPaddingClasses["NONE"] = "padding-none";
    OdooPaddingClasses["SMALL"] = "padding-small";
    OdooPaddingClasses["MEDIUM"] = "padding-medium";
    OdooPaddingClasses["LARGE"] = "padding-large";
    OdooPaddingClasses["XL"] = "padding-xl";
})(OdooPaddingClasses || (OdooPaddingClasses = {}));
const paddingClassesLabels = {
    [OdooPaddingClasses.NONE]: 'None',
    [OdooPaddingClasses.SMALL]: 'Small',
    [OdooPaddingClasses.MEDIUM]: 'Medium',
    [OdooPaddingClasses.LARGE]: 'Large',
    [OdooPaddingClasses.XL]: 'XL',
};
const paddingClasses = Object.keys(paddingClassesLabels);
var OdooImageClasses;
(function (OdooImageClasses) {
    OdooImageClasses["ROUNDED"] = "rounded";
    OdooImageClasses["ROUNDED_CIRCLE"] = "rounded-circle";
    OdooImageClasses["SHADOW"] = "shadow";
    OdooImageClasses["IMG_THUMBNAIL"] = "img-thumbnail";
})(OdooImageClasses || (OdooImageClasses = {}));
const imageClassesLabels = {
    [OdooImageClasses.ROUNDED]: 'Rounded',
    [OdooImageClasses.ROUNDED_CIRCLE]: 'Circle',
    [OdooImageClasses.SHADOW]: 'Shadow',
    [OdooImageClasses.IMG_THUMBNAIL]: 'Thumbnail',
};
/**
 * Get one image targeted within the range.
 * If more images are within the range, return undefined.
 */
function getSingleImage(range) {
    const imageNodes = range.targetedNodes(ImageNode_ImageNode);
    return imageNodes.length === 1 && imageNodes[0];
}
/**
 * Check if there is at exactly one image within the editor range
 */
function isImageVisible(editor) {
    return !!getSingleImage(editor.selection.range);
}
class Odoo_Odoo extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [OdooStructureXmlDomParser_OdooStructureXmlDomParser, OdooTranslationXmlDomParser_OdooTranslationXmlDomParser],
            renderers: [OdooImageDomObjectRenderer_OdooImageDomObjectRenderer, OdooFontAwesomeDomObjectRenderer_OdooFontAwesomeDomObjectRenderer],
            components: [
                {
                    id: 'OdooLinkButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'link',
                            label: 'Insert link',
                            commandId: 'openLinkDialog',
                            selected: (editor) => {
                                const range = editor.selection.range;
                                const node = range.start.nextSibling() || range.start.previousSibling();
                                return (node &&
                                    node instanceof InlineNode_InlineNode &&
                                    !!node.modifiers.find(LinkFormat_LinkFormat));
                            },
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-link fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'OdooMediaButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'media',
                            label: 'Media',
                            commandId: 'openMedia',
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-file-image-o fa-fw' })],
                        });
                        return [button];
                    },
                },
                {
                    id: 'OdooTextColorButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'textcolorpicker',
                            label: 'Text Color picker',
                            commandId: 'openTextColorPicker',
                            modifiers: [
                                new Attributes_Attributes({ class: 'fa fa-font fa-fw dropdown-toggle' }),
                                new Attributes_Attributes({ 'data-toggle': 'dropdown' }),
                            ],
                        });
                        const dropdownContent = new DividerNode_DividerNode();
                        dropdownContent.modifiers.append(new Attributes_Attributes({ class: 'dropdown-menu' }));
                        const dropdownContainer = new DividerNode_DividerNode();
                        dropdownContainer.modifiers.append(new Attributes_Attributes({ class: 'dropdown jw-dropdown jw-dropdown-textcolor' }));
                        dropdownContainer.append(button);
                        dropdownContainer.append(dropdownContent);
                        return [dropdownContainer];
                    },
                },
                {
                    id: 'OdooBackgroundColorButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'backgroundcolorpicker',
                            label: 'Background Color picker',
                            commandId: 'openBackgroundColorPicker',
                            modifiers: [
                                new Attributes_Attributes({ class: 'fa fa-paint-brush fa-fw dropdown-toggle' }),
                                new Attributes_Attributes({ 'data-toggle': 'dropdown' }),
                            ],
                        });
                        const dropdownContent = new DividerNode_DividerNode();
                        dropdownContent.modifiers.append(new Attributes_Attributes({ class: 'dropdown-menu' }));
                        const dropdownContainer = new DividerNode_DividerNode();
                        dropdownContainer.modifiers.append(new Attributes_Attributes({
                            class: 'dropdown jw-dropdown jw-dropdown-backgroundcolor',
                        }));
                        dropdownContainer.append(button);
                        dropdownContainer.append(dropdownContent);
                        return [dropdownContainer];
                    },
                },
                {
                    id: 'OdooDiscardButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'discard',
                            label: 'Discard',
                            commandId: 'discardOdoo',
                            modifiers: [
                                new Attributes_Attributes({ class: 'fa fa-times fa-fw jw-danger-button' }),
                            ],
                        });
                        return [button];
                    },
                },
                {
                    id: 'OdooSaveButton',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'save',
                            label: 'Save',
                            commandId: 'saveOdoo',
                            modifiers: [
                                new Attributes_Attributes({ class: 'fa fa-save fa-fw jw-primary-button' }),
                            ],
                        });
                        return [button];
                    },
                },
                this._makeImagePaddingComponent('OdooImagePaddingNoneActionable', OdooPaddingClasses.NONE),
                this._makeImagePaddingComponent('OdooImagePaddingSmallActionable', OdooPaddingClasses.SMALL),
                this._makeImagePaddingComponent('OdooImagePaddingMediumActionable', OdooPaddingClasses.MEDIUM),
                this._makeImagePaddingComponent('OdooImagePaddingLargeActionable', OdooPaddingClasses.LARGE),
                this._makeImagePaddingComponent('OdooImagePaddingXLActionable', OdooPaddingClasses.XL),
                this._makeImageWidthComponent('OdooImageWidthAutoActionable', 'auto'),
                this._makeImageWidthComponent('OdooImageWidth25Actionable', '25'),
                this._makeImageWidthComponent('OdooImageWidth50Actionable', '50'),
                this._makeImageWidthComponent('OdooImageWidth75Actionable', '75'),
                this._makeImageWidthComponent('OdooImageWidth100Actionable', '100'),
                this._makeImageClassComponent('OdooImageRoundedActionable', OdooImageClasses.ROUNDED, 'fa-square'),
                this._makeImageClassComponent('OdooImageRoundedCircleActionable', OdooImageClasses.ROUNDED_CIRCLE, 'fa-circle-o'),
                this._makeImageClassComponent('OdooImageRoundedShadowActionable', OdooImageClasses.SHADOW, 'fa-sun-o'),
                this._makeImageClassComponent('OdooImageRoundedThumbnailActionable', OdooImageClasses.IMG_THUMBNAIL, 'fa-picture-o'),
                {
                    id: 'OdooCropActionable',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'crop-image',
                            label: 'Crop',
                            commandId: 'cropImage',
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-crop fa-fw' })],
                            visible: isImageVisible,
                        });
                        return [button];
                    },
                },
                {
                    id: 'OdooTransformActionable',
                    async render() {
                        const button = new ActionableNode_ActionableNode({
                            name: 'transform-image',
                            label: 'Transform',
                            commandId: 'transformImage',
                            modifiers: [new Attributes_Attributes({ class: 'fa fa-object-ungroup fa-fw' })],
                            visible: isImageVisible,
                        });
                        return [button];
                    },
                },
            ],
            componentZones: [
                ['OdooLinkButton', ['actionables']],
                ['OdooMediaButton', ['actionables']],
                ['OdooDiscardButton', ['actionables']],
                ['OdooSaveButton', ['actionables']],
            ],
        };
        this.commands = {
            setImagePadding: {
                handler: this.setImagePadding,
            },
            setImageWidth: {
                handler: this.setImageWidth,
            },
            setImageClass: {
                handler: this.setImageClass,
            },
        };
    }
    setImagePadding(params) {
        const image = getSingleImage(params.context.range);
        if (image) {
            const classList = image.modifiers.get(Attributes_Attributes).classList;
            for (const className of paddingClasses) {
                classList.remove(className);
            }
            if (params.className === 'padding-none')
                return;
            classList.add(params.className);
        }
    }
    setImageWidth(params) {
        const image = getSingleImage(params.context.range);
        if (image) {
            const style = image.modifiers.get(Attributes_Attributes).style;
            if (params.width === 'auto') {
                style.remove('width');
            }
            else {
                style.set('width', params.width + '%');
            }
        }
    }
    setImageClass(params) {
        const image = getSingleImage(params.context.range);
        if (image) {
            const classList = image.modifiers.get(Attributes_Attributes).classList;
            classList.toggle(params.className);
        }
    }
    _makeImagePaddingComponent(componentId, className) {
        const component = {
            id: componentId,
            async render() {
                const params = {
                    className: className,
                };
                const button = new ActionableNode_ActionableNode({
                    name: `set-${className}`,
                    label: paddingClassesLabels[className],
                    commandId: 'setImagePadding',
                    commandArgs: params,
                    visible: isImageVisible,
                    selected: (editor) => {
                        const image = getSingleImage(editor.selection.range);
                        if (image) {
                            const imageAttribute = image.modifiers.get(Attributes_Attributes);
                            if (className === OdooPaddingClasses.NONE) {
                                if (paddingClasses.every(className => !imageAttribute.has(className))) {
                                    return true;
                                }
                            }
                            else {
                                imageAttribute.classList.has(className);
                            }
                        }
                        return false;
                    },
                });
                return [button];
            },
        };
        return component;
    }
    _makeImageWidthComponent(componentId, width) {
        const component = {
            id: componentId,
            async render() {
                const params = {
                    width: width,
                };
                const button = new ActionableNode_ActionableNode({
                    name: `set-image-width-${width}`,
                    label: width === 'auto' ? 'auto' : width + '%',
                    commandId: 'setImageWidth',
                    commandArgs: params,
                    visible: isImageVisible,
                    selected: (editor) => {
                        const image = getSingleImage(editor.selection.range);
                        if (image) {
                            const imageAttribute = image.modifiers.get(Attributes_Attributes);
                            return parseInt(imageAttribute.style.get('width')) === parseInt(width);
                        }
                        return false;
                    },
                });
                return [button];
            },
        };
        return component;
    }
    _makeImageClassComponent(componentId, className, faIcon) {
        const component = {
            id: componentId,
            async render() {
                const params = { className };
                const button = new ActionableNode_ActionableNode({
                    name: `set-image-class-${className}`,
                    label: imageClassesLabels[className],
                    commandId: 'setImageClass',
                    commandArgs: params,
                    modifiers: [new Attributes_Attributes({ class: `fa ${faIcon} fa-fw` })],
                    visible: isImageVisible,
                    selected: (editor) => {
                        const image = getSingleImage(editor.selection.range);
                        if (image) {
                            const imageAttribute = image.modifiers.get(Attributes_Attributes);
                            return imageAttribute.classList.has(className);
                        }
                        return false;
                    },
                });
                return [button];
            },
        };
        return component;
    }
}
Odoo_Odoo.dependencies = [Inline_Inline, Link_Link, Xml_Xml];

// CONCATENATED MODULE: ./packages/plugin-shadow/src/ShadowNode.ts

class ShadowNode_ShadowNode extends ContainerNode_ContainerNode {
    constructor() {
        super(...arguments);
        this.editable = false;
        this.breakable = false;
    }
}

// CONCATENATED MODULE: ./packages/plugin-shadow/src/ShadowHtmlDomParser.ts





class ShadowHtmlDomParser_ShadowHtmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof HTMLElement && !!item.shadowRoot;
        };
    }
    /**
     * Parse a shadow node and extract styling from shadow root.
     *
     * @param item
     */
    async parse(item) {
        const shadowRoot = item.shadowRoot;
        const shadow = new ShadowNode_ShadowNode();
        const childNodes = Array.from(shadowRoot.childNodes);
        const nodes = await this.engine.parse(...childNodes);
        shadow.append(...nodes);
        if (nodeName(item) === 'JW-SHADOW') {
            return [shadow];
        }
        else {
            const element = new VElement_VElement({ htmlTag: nodeName(item) });
            const attributes = this.engine.parseAttributes(item);
            if (attributes.length) {
                element.modifiers.append(attributes);
            }
            element.append(shadow);
            return [element];
        }
    }
}
ShadowHtmlDomParser_ShadowHtmlDomParser.id = HtmlDomParsingEngine_HtmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-shadow/src/ShadowXmlDomParser.ts




class ShadowXmlDomParser_ShadowXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return item instanceof Element && nodeName(item) === 'T-SHADOW';
        };
    }
    /**
     * Parse a shadow node and extract styling.
     *
     * @param item
     */
    async parse(item) {
        const shadow = new ShadowNode_ShadowNode();
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            shadow.modifiers.append(attributes);
        }
        const nodes = await this.engine.parse(...item.childNodes);
        shadow.append(...nodes);
        return [shadow];
    }
}
ShadowXmlDomParser_ShadowXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-shadow/src/ShadowDomObjectRenderer.ts




class ShadowDomObjectRenderer_ShadowDomObjectRenderer extends NodeRenderer {
    constructor() {
        super(...arguments);
        this.predicate = ShadowNode_ShadowNode;
    }
    async render(shadow) {
        const domObject = {
            tag: 'JW-SHADOW',
            shadowRoot: true,
            children: shadow.childVNodes.filter(child => child.tangible || child instanceof MetadataNode_MetadataNode),
        };
        return domObject;
    }
}
ShadowDomObjectRenderer_ShadowDomObjectRenderer.id = DomObjectRenderingEngine_DomObjectRenderingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-shadow/src/Shadow.ts






class Shadow_Shadow extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [ShadowXmlDomParser_ShadowXmlDomParser, ShadowHtmlDomParser_ShadowHtmlDomParser],
            renderers: [ShadowDomObjectRenderer_ShadowDomObjectRenderer],
        };
    }
}
Shadow_Shadow.dependencies = [Parser_Parser, Renderer_Renderer];

// CONCATENATED MODULE: ./packages/plugin-fontawesome/src/FontAwesomeXmlDomParser.ts




const FontAwesomeRegex = /(^|[\s*\n*])fa[bdlrs]?[\s*\n*$]/;
class FontAwesomeXmlDomParser_FontAwesomeXmlDomParser extends AbstractParser {
    constructor() {
        super(...arguments);
        this.predicate = (item) => {
            return FontAwesomeXmlDomParser_FontAwesomeXmlDomParser.isFontAwesome(item);
        };
    }
    async parse(item) {
        const fontawesome = new FontAwesomeNode_FontAwesomeNode({ htmlTag: nodeName(item) });
        const attributes = this.engine.parseAttributes(item);
        if (attributes.length) {
            fontawesome.modifiers.append(attributes);
        }
        return [fontawesome];
    }
    /**
     * Return true if the given DOM node is a fontawesome.
     *
     * @param item
     */
    static isFontAwesome(item) {
        return item instanceof Element && FontAwesomeRegex.test(item.className);
    }
}
FontAwesomeXmlDomParser_FontAwesomeXmlDomParser.id = XmlDomParsingEngine_XmlDomParsingEngine.id;

// CONCATENATED MODULE: ./packages/plugin-fontawesome/src/FontAwesome.ts



class FontAwesome_FontAwesome extends JWPlugin {
    constructor() {
        super(...arguments);
        this.loadables = {
            parsers: [FontAwesomeXmlDomParser_FontAwesomeXmlDomParser],
            renderers: [FontAwesomeDomObjectRenderer_FontAwesomeDomObjectRenderer],
        };
    }
}

// EXTERNAL MODULE: ./packages/bundle-odoo-website-editor/odooLayout.css
var odooLayout = __webpack_require__(21);

// CONCATENATED MODULE: ./packages/bundle-odoo-website-editor/OdooWebsiteEditor.ts

















































const defaultToolbarLayout = [
    [
        [
            'ParagraphButton',
            'Heading1Button',
            'Heading2Button',
            'Heading3Button',
            'Heading4Button',
            'Heading5Button',
            'Heading6Button',
            'PreButton',
        ],
    ],
    ['FontSizeInput'],
    [
        'BoldButton',
        'ItalicButton',
        'UnderlineButton',
        'OdooTextColorButton',
        'OdooBackgroundColorButton',
        'RemoveFormatButton',
    ],
    ['AlignLeftButton', 'AlignCenterButton', 'AlignRightButton', 'AlignJustifyButton'],
    ['OrderedListButton', 'UnorderedListButton', 'ChecklistButton'],
    ['IndentButton', 'OutdentButton'],
    ['OdooLinkButton'],
    ['OdooMediaButton'],
];
class OdooWebsiteEditor_OdooWebsiteEditor extends src_JWEditor {
    constructor(options) {
        super();
        class CustomPlugin extends JWPlugin {
            constructor() {
                super(...arguments);
                this.commands = Object.assign(options.customCommands);
            }
        }
        this.configure({
            defaults: {
                Container: ParagraphNode_ParagraphNode,
                Separator: LineBreakNode_LineBreakNode,
            },
            plugins: [
                [Parser_Parser],
                [Renderer_Renderer],
                [Layout_Layout],
                [Keymap_Keymap],
                [Html_Html],
                [Inline_Inline],
                [Char_Char],
                [LineBreak_LineBreak],
                [Heading_Heading],
                [Paragraph_Paragraph],
                [List_List],
                [Textarea_Textarea],
                [Indent_Indent],
                [Span_Span],
                [Bold_Bold],
                [Italic_Italic],
                [Underline_Underline],
                [Input_Input],
                [FontSize_FontSize],
                [Link_Link],
                [FontAwesome_FontAwesome],
                [Divider_Divider],
                [Image_Image],
                [Subscript_Subscript],
                [Superscript_Superscript],
                [Blockquote_Blockquote],
                [Youtube_Youtube],
                [Table_Table],
                [Metadata_Metadata],
                [Align_Align],
                [Pre_Pre],
                [TextColor_TextColor],
                [BackgroundColor_BackgroundColor],
                [Dialog_Dialog],
                [Shadow_Shadow],
                [DomHelpers_DomHelpers],
                [Odoo_Odoo],
                [OdooVideo_OdooVideo],
                [CustomPlugin],
                [FollowRange_FollowRange],
                ...(options.plugins || []),
            ],
        });
        this.configure(Toolbar_Toolbar, {
            layout: [...(options.toolbarLayout || defaultToolbarLayout)],
        });
        const defaultTemplate = `
        <t-dialog><t t-zone="default"/></t-dialog>
        <div class="wrap_editor d-flex flex-column">
            <div class="d-flex flex-grow-1 flex-row overflow-auto">
                <t t-zone="main_sidebar"/>
                <div class="d-flex flex-column o_editor_center">
                    <div class="o_toolbar">
                        <t t-zone="tools"/>
                    </div>
                    <div class="d-flex flex-grow-1 overflow-auto">
                        <t t-zone="snippetManipulators"/>
                        <t t-zone="main"/>
                    </div>
                </div>
            </div>
            <div class="o_debug_zone">
                <t t-zone="debug"/>
            </div>
        </div>
    `;
        this.configure(DomLayout_DomLayout, {
            components: [
                {
                    id: 'main_template',
                    render(editor) {
                        return editor.plugins
                            .get(Parser_Parser)
                            .parse('text/html', options.template || defaultTemplate);
                    },
                },
                {
                    id: 'snippet_menu',
                    render() {
                        const node = options.snippetMenuElement
                            ? new HtmlNode_HtmlNode({ domNode: () => options.snippetMenuElement })
                            : new LineBreakNode_LineBreakNode();
                        return Promise.resolve([node]);
                    },
                },
                {
                    id: 'snippetManipulators',
                    render() {
                        const node = options.snippetMenuElement
                            ? new HtmlNode_HtmlNode({ domNode: () => options.snippetManipulators })
                            : new LineBreakNode_LineBreakNode();
                        return Promise.resolve([node]);
                    },
                },
                {
                    id: 'editable',
                    render: async (editor) => {
                        return parseEditable(editor, options.source);
                    },
                },
            ],
            componentZones: [
                ['main_template', ['root']],
                ['snippet_menu', ['main_sidebar']],
                ['snippetManipulators', ['snippetManipulators']],
                ['editable', ['main']],
            ],
            location: options.location,
            pressedActionablesClassName: 'active',
        });
        this.configure(DomEditable_DomEditable, {
            autoFocus: true,
            source: options.source.firstElementChild,
        });
        this.configure(Table_Table, {
            inlineUI: true,
        });
        if (options.mode) {
            this.configure({
                modes: [options.mode],
            });
            this.configure({ mode: options.mode.id });
        }
    }
    /**
     * Get the value by rendering the "editable" component of the editor.
     */
    async getValue() {
        const renderer = this.plugins.get(Renderer_Renderer);
        const layout = this.plugins.get(Layout_Layout);
        const domLayout = layout.engines.dom;
        const editable = domLayout.components.editable[0];
        const nodes = await renderer.render('dom/html', editable);
        return nodes && nodes[0];
    }
}

// CONCATENATED MODULE: ./packages/bundle-odoo-website-editor/odoo-integration.ts























/***/ })
/******/ ]);
//# sourceMappingURL=odoo-integration.js.map
return JWEditor
});